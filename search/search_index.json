{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yocto/GL: Tiny C++ Libraries for Data-Oriented Physically-based Graphics Yocto/GL is a collection of small C++17 libraries for building physically-based graphics algorithms released under the MIT license. Yocto/GL is written in a deliberately data-oriented style for ease of development and use. Libraries Yocto/GL is split into small libraries to make code navigation easier. See each header file for documentation. Yocto/Math : fixed-size vectors, matrices, rigid frames, rays, bounding boxes, transforms Yocto/Color : color conversion, color adjustment, tone mapping functions, Perlin noise, shading and integration utilities Yocto/Geometry : geometry functions, ray-primitive intersection, point-primitive overlap Yocto/Noise : Perlin noise Yocto/Sampling : random number generation, generation of points and directions, Monte Carlo utilities Yocto/Shading : evaluation and sampling of fresnel functions, bsdf lobes, transmittance lobes, phase functions Yocto/Shape : various utilities for manipulating triangle meshes, quads meshes and line sets, computation of normals and tangents, linear and Catmull-Clark subdivision, mesh loading and saving, procedural shapes generation, ray intersection and closest point queries Yocto/Mesh : computational geometry utilities for triangle meshes, mesh geodesic, mesh cutting, mesh loading and saving Yocto/Bvh : ray intersection and closest point queries of triangle meshes, quads meshes, line sets and instances scenes using a two-level bounding volume hierarchy Yocto/Image : simple image data type, image resizing, tonemapping, color correction, image loading and saving, procedural images, procedural sun-sky, advanced color conversion utilities Yocto/Scene : simple scene representation useful for rendering [Yocto/SceneIO](yocto/yocto_sceneio.md`: scene loading and saving of Ply/Obj/Pbrt/glTF and a custom and scalable Json format Yocto/Trace : path tracing of surfaces and hairs supporting area and environment illumination, microfacet GGX and subsurface scattering, multiple importance sampling Yocto/ModelIO : parsing and writing for Ply/Obj/Pbrt formats Yocto/CommonIO : printing utilities, file io utilities, command line parsing Yocto/CommonIO : container, iterators and concurrency utilities Example Applications You can see Yocto/GL in action in the following applications written to test the library: apps/yscenetrace.cpp : command-line path-tracer apps/ysceneitrace.cpp : interactive path-tracer apps/ysceneitraces.cpp : simpler version of apps/ysceneitrace.cpp for demos apps/ysceneproc.cpp : command-line scene manipulation and conversion apps/yshapeproc.cpp : command-line mesh manipulation and conversion apps/yimageview.cpp : Hdr/Ldr image viewer with tonemapping and color grading apps/yimageviews.cpp : simpler version of apps/yimageview.cpp for demos apps/yimageproc.cpp : command-line image manipulation apps/ysceneview.cpp : simple OpenGL viewer Here are some test images rendered with the path tracer. More images are included in the project site . Design Considerations Yocto/GL follows a \"data-oriented programming model\" that makes data explicit. Data is stored in simple structs and accessed with free functions or directly. All data is public, so we make no attempt at encapsulation. Most objects is Yocto/GL have value semantic, while large data structures use reference semantic with strict ownership. This means that everything can be trivially serialized and there is no need for memory management. We do this since this makes Yocto/GL easier to extend and quicker to learn, with a more explicit data flow that is easier when writing parallel code. Since Yocto/GL is mainly used for research and teaching, explicit data is both more hackable and easier to understand. In terms of code style we prefer a functional approach rather than an object oriented one, favoring free functions to class methods. All functions and data are defined in sibling namespaces contained in the yocto namespace so libraries can call all others, but have to do so explicitly. The use of templates in Yocto was the reason for many refactoring, going from no template to heavy template use. At this point, Yocto uses some templates for readability. In the future, we will increase the use of templates in math code, while keeping many APIs explicitly typed. We do not use exception for error reporting, but only to report \"programmers\" errors. For example, IO operations use boolean flags and error strings for human readable errors, while exceptions are used when preconditions or postconditions are violatd in functions. The current version of the library (2.x) is a major refactoring of the previous library versions (1.x) in three main aspects. First, we now allow the use of reference semantic via pointers and adopt it for all large objects, while keeping value semantic for all others. We did this to avoid erroneous copies that cannot detected and avoided at compile time. Second, we had trouble interacting with C libraries that mostly use reference semantic. Third, we reduce the use of exceptions, again for better integration with external code. Credits Main contributors: Fabio Pellacini (lead developer): web , github Edoardo Carra: github Giacomo Nazzaro: github This library includes code from the PCG random number generator , boost hash_combine , and public domain code from github.com/sgorsten/linalg , gist.github.com/badboy/6267743 . Other external libraries are included with their own license. Compilation This library requires a C++17 compiler and is know to compiled on OsX (Xcode >= 11), Windows (MSVC 2019) and Linux (gcc >= 9, clang >= 9). You can build the example applications using CMake with mkdir build; cd build; cmake ..; cmake --build Yocto/GL depends on stb_image.h , stb_image_write.h , stb_image_resize.h and tinyexr.h for image loading, saving and resizing, cgltf.h and json.hpp for glTF and JSON support, and filesystem.hpp to support C++17 filesystem API when missing. All dependencies are included in the distribution. Yocto/GL optionally supports building OpenGL demos, which are handled by including glad, GLFW, ImGui as dependencies in apps. OpenGL support might eventually become part of the Yocto/GL libraries. OpenGL support is enabled by defining the cmake option YOCTO_OPENGL and contained in the yocto_gui library. Yocto/GL optionally supports the use of Intel's Embree for ray casting. At this point, we rely on prebuilt binaries distributed by Intel. See the main CMake file for how to link to it. Embree support is enabled by defining the cmake option YOCTO_EMBREE . Yocto/GL optionally supports the use of Intel's Open Image Denoise for denoising renders. At this point, we rely on prebuilt binaries distributed by Intel. See the main CMake file for how to link to it. Open Image Denoise support is enabled by defining the cmake option YOCTO_DENOISE . See apps/yimagedenoise for a demonstration.","title":"About"},{"location":"#yoctogl-tiny-c-libraries-for-data-oriented-physically-based-graphics","text":"Yocto/GL is a collection of small C++17 libraries for building physically-based graphics algorithms released under the MIT license. Yocto/GL is written in a deliberately data-oriented style for ease of development and use.","title":"Yocto/GL: Tiny C++ Libraries for Data-Oriented Physically-based Graphics"},{"location":"#libraries","text":"Yocto/GL is split into small libraries to make code navigation easier. See each header file for documentation. Yocto/Math : fixed-size vectors, matrices, rigid frames, rays, bounding boxes, transforms Yocto/Color : color conversion, color adjustment, tone mapping functions, Perlin noise, shading and integration utilities Yocto/Geometry : geometry functions, ray-primitive intersection, point-primitive overlap Yocto/Noise : Perlin noise Yocto/Sampling : random number generation, generation of points and directions, Monte Carlo utilities Yocto/Shading : evaluation and sampling of fresnel functions, bsdf lobes, transmittance lobes, phase functions Yocto/Shape : various utilities for manipulating triangle meshes, quads meshes and line sets, computation of normals and tangents, linear and Catmull-Clark subdivision, mesh loading and saving, procedural shapes generation, ray intersection and closest point queries Yocto/Mesh : computational geometry utilities for triangle meshes, mesh geodesic, mesh cutting, mesh loading and saving Yocto/Bvh : ray intersection and closest point queries of triangle meshes, quads meshes, line sets and instances scenes using a two-level bounding volume hierarchy Yocto/Image : simple image data type, image resizing, tonemapping, color correction, image loading and saving, procedural images, procedural sun-sky, advanced color conversion utilities Yocto/Scene : simple scene representation useful for rendering [Yocto/SceneIO](yocto/yocto_sceneio.md`: scene loading and saving of Ply/Obj/Pbrt/glTF and a custom and scalable Json format Yocto/Trace : path tracing of surfaces and hairs supporting area and environment illumination, microfacet GGX and subsurface scattering, multiple importance sampling Yocto/ModelIO : parsing and writing for Ply/Obj/Pbrt formats Yocto/CommonIO : printing utilities, file io utilities, command line parsing Yocto/CommonIO : container, iterators and concurrency utilities","title":"Libraries"},{"location":"#example-applications","text":"You can see Yocto/GL in action in the following applications written to test the library: apps/yscenetrace.cpp : command-line path-tracer apps/ysceneitrace.cpp : interactive path-tracer apps/ysceneitraces.cpp : simpler version of apps/ysceneitrace.cpp for demos apps/ysceneproc.cpp : command-line scene manipulation and conversion apps/yshapeproc.cpp : command-line mesh manipulation and conversion apps/yimageview.cpp : Hdr/Ldr image viewer with tonemapping and color grading apps/yimageviews.cpp : simpler version of apps/yimageview.cpp for demos apps/yimageproc.cpp : command-line image manipulation apps/ysceneview.cpp : simple OpenGL viewer Here are some test images rendered with the path tracer. More images are included in the project site .","title":"Example Applications"},{"location":"#design-considerations","text":"Yocto/GL follows a \"data-oriented programming model\" that makes data explicit. Data is stored in simple structs and accessed with free functions or directly. All data is public, so we make no attempt at encapsulation. Most objects is Yocto/GL have value semantic, while large data structures use reference semantic with strict ownership. This means that everything can be trivially serialized and there is no need for memory management. We do this since this makes Yocto/GL easier to extend and quicker to learn, with a more explicit data flow that is easier when writing parallel code. Since Yocto/GL is mainly used for research and teaching, explicit data is both more hackable and easier to understand. In terms of code style we prefer a functional approach rather than an object oriented one, favoring free functions to class methods. All functions and data are defined in sibling namespaces contained in the yocto namespace so libraries can call all others, but have to do so explicitly. The use of templates in Yocto was the reason for many refactoring, going from no template to heavy template use. At this point, Yocto uses some templates for readability. In the future, we will increase the use of templates in math code, while keeping many APIs explicitly typed. We do not use exception for error reporting, but only to report \"programmers\" errors. For example, IO operations use boolean flags and error strings for human readable errors, while exceptions are used when preconditions or postconditions are violatd in functions. The current version of the library (2.x) is a major refactoring of the previous library versions (1.x) in three main aspects. First, we now allow the use of reference semantic via pointers and adopt it for all large objects, while keeping value semantic for all others. We did this to avoid erroneous copies that cannot detected and avoided at compile time. Second, we had trouble interacting with C libraries that mostly use reference semantic. Third, we reduce the use of exceptions, again for better integration with external code.","title":"Design Considerations"},{"location":"#credits","text":"Main contributors: Fabio Pellacini (lead developer): web , github Edoardo Carra: github Giacomo Nazzaro: github This library includes code from the PCG random number generator , boost hash_combine , and public domain code from github.com/sgorsten/linalg , gist.github.com/badboy/6267743 . Other external libraries are included with their own license.","title":"Credits"},{"location":"#compilation","text":"This library requires a C++17 compiler and is know to compiled on OsX (Xcode >= 11), Windows (MSVC 2019) and Linux (gcc >= 9, clang >= 9). You can build the example applications using CMake with mkdir build; cd build; cmake ..; cmake --build Yocto/GL depends on stb_image.h , stb_image_write.h , stb_image_resize.h and tinyexr.h for image loading, saving and resizing, cgltf.h and json.hpp for glTF and JSON support, and filesystem.hpp to support C++17 filesystem API when missing. All dependencies are included in the distribution. Yocto/GL optionally supports building OpenGL demos, which are handled by including glad, GLFW, ImGui as dependencies in apps. OpenGL support might eventually become part of the Yocto/GL libraries. OpenGL support is enabled by defining the cmake option YOCTO_OPENGL and contained in the yocto_gui library. Yocto/GL optionally supports the use of Intel's Embree for ray casting. At this point, we rely on prebuilt binaries distributed by Intel. See the main CMake file for how to link to it. Embree support is enabled by defining the cmake option YOCTO_EMBREE . Yocto/GL optionally supports the use of Intel's Open Image Denoise for denoising renders. At this point, we rely on prebuilt binaries distributed by Intel. See the main CMake file for how to link to it. Open Image Denoise support is enabled by defining the cmake option YOCTO_DENOISE . See apps/yimagedenoise for a demonstration.","title":"Compilation"},{"location":"gallery/","text":"Gallery This page contains a collection of images rendered with the Yocto/GL path tracer. Environments Interiors Objects {: style=\"max-height: 416px\"} {: style=\"text-align: center\"} {: style=\"max-height: 416px\"} {: style=\"text-align: center\"} Vehicles Minecraft","title":"Gallery"},{"location":"gallery/#gallery","text":"This page contains a collection of images rendered with the Yocto/GL path tracer.","title":"Gallery"},{"location":"gallery/#environments","text":"","title":"Environments"},{"location":"gallery/#interiors","text":"","title":"Interiors"},{"location":"gallery/#objects","text":"{: style=\"max-height: 416px\"} {: style=\"text-align: center\"} {: style=\"max-height: 416px\"} {: style=\"text-align: center\"}","title":"Objects"},{"location":"gallery/#vehicles","text":"","title":"Vehicles"},{"location":"gallery/#minecraft","text":"","title":"Minecraft"},{"location":"yocto/yocto_bvh/","text":"Yocto/Bvh: Accelerated ray-intersection and point-overlap Yocto/Bvh provides ray-intersection and point-overlap queries accelerated by a two-level BVH using an internal or wrapping Embree. Yocto/Bvh is implemented in yocto_bvh.h and yocto_bvh.cpp . This library is experimental and will be documented appropriately when the code reaches stability. For now, use the Yocto/Scene support for this.","title":"Ray-scene intersection"},{"location":"yocto/yocto_bvh/#yoctobvh-accelerated-ray-intersection-and-point-overlap","text":"Yocto/Bvh provides ray-intersection and point-overlap queries accelerated by a two-level BVH using an internal or wrapping Embree. Yocto/Bvh is implemented in yocto_bvh.h and yocto_bvh.cpp . This library is experimental and will be documented appropriately when the code reaches stability. For now, use the Yocto/Scene support for this.","title":"Yocto/Bvh: Accelerated ray-intersection and point-overlap"},{"location":"yocto/yocto_color/","text":"Yocto/Color: Color operations Yocto/Color provides basic color utilities for writing graphics applications. In particular, we support color conversion to/from linear rgb, srgb, hsv, xyz, byte to float color conversions, colormaps, and a few color manipulations like contrast and saturation. Yocto/Color is implemented in yocto_color.h . Color Representation Yocto/Color follows the conventions of using generic vector types to represent color quantities rather than defining specific types, and performing color computation in floats for increased precision. Colors are represented as vec3f for three channels and vec4f for four channel types. This way, colors support all arithmetic operations defined in Yocto/Math . Yocto/Color supports storing colors in 8-bit representations as vec3b and vec4b . Conversion between float and byte representation are performed with byte_to_float(c8) and float_to_byte(cf) . auto red = vec3f { 1 , 0 , 0 }, green = vec3f { 0 , 1 , 0 }; // red and green colors auto yellow = red + green , darker = red * 0.5f ; // color arithmetic auto reddish = lerp ( red , green , 0.1f ); // color interpolation auto red8 = float_to_byte ( red ); // 8bit conversion Color Conversions Like most 3D graphics libraries, Yocto/Color does not explicitly track color spaces. Instead, we use conventions between library facilities to carry out color operations. Most color operations are defined on linear RGB colors. By default, Yocto/Color uses a linear color space with sRGB primaries, mostly since lots of freely available graphics data encodes colors in that manner. Yocto/Color supports conversions between linear RGB, sRGB, XYZ, xyY and HSV. Color conversion functions are named as <from>_to_<to> where <from> and <to> are the name of the color spaces. auto c_rgb = vec3f { 1 , 0.5 , 0 }; // color in linear RGB auto c_xyz = rgb_to_xyz ( c_rgb ); // convert to XYZ auto c_srgb = rgb_to_srgb ( c_rgb ); // convert to sRGB auto c_hsv = rgb_ro_hsv ( c_srgb ); // sRGB to HSV auto c_8bit = float_to_byte ( rgb_to_srgb ( c_rgb )); // encode in 8-bit sRGB Tonal Adjustment Yocto/Color provides minimal tonal adjustment functionality, mostly helpful when displaying images on screens. HDR images can be tone mapped with tonemap(hdr,e,f) that applies a simple exposure correction to the HDR colors and optionally a filmic tone curve. This functions converts from linear RGB to sRGB by default, but the latter conversion can be disabled. Saturation adjustment are implemented in sature(rgb,s) that interpolates to color with gray. Contrast adjustments are notoriously more complex since they depend on both the contrast function used and the color space it is applied with. To cater to most uses, Yocto/Color provides three contrast curves. contrast(rgb,c) generate smooth contrast variations by applying an S-shaped curve that typically used in non-linear color spaces. lincontrast(rgb,c,g) has a harsher look due to clipped colors and is obtained by applying linear scaling around a gray level. logcontrast(rgb,c,g) is suitable to contrast manipulation in HDR since it does not clip colors. This is implemented by applying scaling in the logarithm domain. Both linear and logarithmic contrast can be used for HDR and LDR by adjusting the gray level to 0.18 and 0.5 respectively. auto exposure = 1 ; auto filomic = true ; auto ldr = tonemap ( hdr , exposure , filmic ); // HDR to LDR tone mapping ldr = contrast ( saturate ( ldr , 0.7 ), 0.7 ); // contrast and saturation auto hdr2 = logcontrast ( hdr * tint , 0.7 , 0.18 ); // contrast and tint in HDR Color map Yocto/Color defines functions to apply standard color maps. Use colormap(t, type) to apply a color map from a value in [0,1] and for different color map types. The library currently supports fitted Matplotlib colormaps from here . auto c0 = colormap ( 0.5 , colormap_type :: viridis ); auto c1 = colormap ( 0.5 , colormap_type :: plasma ); auto c2 = colormap ( 0.5 , colormap_type :: magma ); auto c3 = colormap ( 0.5 , colormap_type :: inferno );","title":"Color operations"},{"location":"yocto/yocto_color/#yoctocolor-color-operations","text":"Yocto/Color provides basic color utilities for writing graphics applications. In particular, we support color conversion to/from linear rgb, srgb, hsv, xyz, byte to float color conversions, colormaps, and a few color manipulations like contrast and saturation. Yocto/Color is implemented in yocto_color.h .","title":"Yocto/Color: Color operations"},{"location":"yocto/yocto_color/#color-representation","text":"Yocto/Color follows the conventions of using generic vector types to represent color quantities rather than defining specific types, and performing color computation in floats for increased precision. Colors are represented as vec3f for three channels and vec4f for four channel types. This way, colors support all arithmetic operations defined in Yocto/Math . Yocto/Color supports storing colors in 8-bit representations as vec3b and vec4b . Conversion between float and byte representation are performed with byte_to_float(c8) and float_to_byte(cf) . auto red = vec3f { 1 , 0 , 0 }, green = vec3f { 0 , 1 , 0 }; // red and green colors auto yellow = red + green , darker = red * 0.5f ; // color arithmetic auto reddish = lerp ( red , green , 0.1f ); // color interpolation auto red8 = float_to_byte ( red ); // 8bit conversion","title":"Color Representation"},{"location":"yocto/yocto_color/#color-conversions","text":"Like most 3D graphics libraries, Yocto/Color does not explicitly track color spaces. Instead, we use conventions between library facilities to carry out color operations. Most color operations are defined on linear RGB colors. By default, Yocto/Color uses a linear color space with sRGB primaries, mostly since lots of freely available graphics data encodes colors in that manner. Yocto/Color supports conversions between linear RGB, sRGB, XYZ, xyY and HSV. Color conversion functions are named as <from>_to_<to> where <from> and <to> are the name of the color spaces. auto c_rgb = vec3f { 1 , 0.5 , 0 }; // color in linear RGB auto c_xyz = rgb_to_xyz ( c_rgb ); // convert to XYZ auto c_srgb = rgb_to_srgb ( c_rgb ); // convert to sRGB auto c_hsv = rgb_ro_hsv ( c_srgb ); // sRGB to HSV auto c_8bit = float_to_byte ( rgb_to_srgb ( c_rgb )); // encode in 8-bit sRGB","title":"Color Conversions"},{"location":"yocto/yocto_color/#tonal-adjustment","text":"Yocto/Color provides minimal tonal adjustment functionality, mostly helpful when displaying images on screens. HDR images can be tone mapped with tonemap(hdr,e,f) that applies a simple exposure correction to the HDR colors and optionally a filmic tone curve. This functions converts from linear RGB to sRGB by default, but the latter conversion can be disabled. Saturation adjustment are implemented in sature(rgb,s) that interpolates to color with gray. Contrast adjustments are notoriously more complex since they depend on both the contrast function used and the color space it is applied with. To cater to most uses, Yocto/Color provides three contrast curves. contrast(rgb,c) generate smooth contrast variations by applying an S-shaped curve that typically used in non-linear color spaces. lincontrast(rgb,c,g) has a harsher look due to clipped colors and is obtained by applying linear scaling around a gray level. logcontrast(rgb,c,g) is suitable to contrast manipulation in HDR since it does not clip colors. This is implemented by applying scaling in the logarithm domain. Both linear and logarithmic contrast can be used for HDR and LDR by adjusting the gray level to 0.18 and 0.5 respectively. auto exposure = 1 ; auto filomic = true ; auto ldr = tonemap ( hdr , exposure , filmic ); // HDR to LDR tone mapping ldr = contrast ( saturate ( ldr , 0.7 ), 0.7 ); // contrast and saturation auto hdr2 = logcontrast ( hdr * tint , 0.7 , 0.18 ); // contrast and tint in HDR","title":"Tonal Adjustment"},{"location":"yocto/yocto_color/#color-map","text":"Yocto/Color defines functions to apply standard color maps. Use colormap(t, type) to apply a color map from a value in [0,1] and for different color map types. The library currently supports fitted Matplotlib colormaps from here . auto c0 = colormap ( 0.5 , colormap_type :: viridis ); auto c1 = colormap ( 0.5 , colormap_type :: plasma ); auto c2 = colormap ( 0.5 , colormap_type :: magma ); auto c3 = colormap ( 0.5 , colormap_type :: inferno );","title":"Color map"},{"location":"yocto/yocto_common/","text":"Yocto/Common: Common utilities Yocto/Common is a collection of utilities helpful in implementing other Yocto/GL libraries. Yocto/Common is implemented in yocto_common.h . This library is experimental and will be documented appropriately when the code reaches stability.","title":"Generic utilities"},{"location":"yocto/yocto_common/#yoctocommon-common-utilities","text":"Yocto/Common is a collection of utilities helpful in implementing other Yocto/GL libraries. Yocto/Common is implemented in yocto_common.h . This library is experimental and will be documented appropriately when the code reaches stability.","title":"Yocto/Common: Common utilities"},{"location":"yocto/yocto_commonio/","text":"Yocto/CommonIO: Utilities for writing command-line apps Yocto/CommonIO is a collection of utilities used in writing command-line applications, including parsing command line arguments, simple path manipulation, file lading and saving, and printing values, timers and progress bars. Printing values Use print_info(message) to print a message, and print_fatal(message) to print and exit. To time a block of code use print_timed(message) to use an RIIA timer or call print_elapsed(timer) to print the elapsed time as needed. Use print_progress(message, current, total) to print a progress bar with a message for a given current and total number of tasks. print_info ( \"Message\" ); // print message print_fatal ( \"Error and exit\" ); // print error and exit { auto timer = print_timed ( \"Timer\" ); ... } // time a block of code auto timer = print_timed ( \"Timer\" ); // start timer print_elapsed ( timer ); // Print elapsed time for ( auto task : range ( 10 )) // iterate over tasks print_progress ( \"Progress bar\" , task , 10 ); // print progress bar Command-Line Parsing Yocto/CommonIO includes a simple command-line parser that supports optional and positional arguments, automatic help generation, and error checking. The command-line parser is initialized with make_cli(name, help) that takes a program name and a help string. Then add command-line options with add_option(cli, name, value, help, req) where name is the option name, value is a reference to the variable that we want to set, help is a usage message and req is a flag that determines whether or not the argument is required. After adding all arguments, use parse_cli(cli) to parse the command-line. If an error occurs, the parser exists. A help flag is also handled in this function. The argument name determines the argument type. If the arguments name starts with '--' or '-' then it is an option, otherwise it is a positional argument. An argument may have multiple names separated by commas. Options and arguments may be intermixed. The type of each option is determined by the passed reference. The parser supports integers, floating point numbers, strings, bool options and arrays of strings. Boolean flags are indicated with a pair of names \"--name/--no-name\", so that we have both options available. auto samples = 10 ; auto flag = false ; // state auto out = \"\" s , name = \"\" s ; auto names = vector < string > {}; auto cli = make_cli ( \"app\" , \"testing cli\" ); // initialize cli add_option ( cli , \"--out\" , out , \"out\" , true ); // required argument add_option ( cli , \"--samples,-s\" , samples , \"samples\" ); // optional argument add_option ( cli , \"--flag/--no-flag\" , flag , \"flag\" ); // optional flag add_option ( cli , \"name\" , name , \"name\" , true ); // positional argument add_option ( cli , \"names\" , names , \"names\" ); // positional arguments parse_cli ( cli ); Text and binary serialization Text files are loaded with load_text(filename, text, error) and saved with save_text(filename, text, error) . Binary files are loaded with load_binary(filename, binary, error) and saved with save_binary(filename, binary, error) . Both loading and saving take a filename, a text or binary buffer, and return whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto error = string {}; // error buffer auto text = string {}; // text buffer if ( ! load_text ( filename , text , error )) // load a text file print_error ( error ); // check and print error if ( ! save_text ( filename , text , error )) // save a text file print_error ( error ); // check and print error auto data = vector < byte > {}; // data buffer if ( ! load_binary ( filename , data , error )) // load a binary file print_error ( error ); // check and print error if ( ! save_binary ( filename , data , error )) // save a binary file print_error ( error ); // check and print error","title":"Command-line utilities"},{"location":"yocto/yocto_commonio/#yoctocommonio-utilities-for-writing-command-line-apps","text":"Yocto/CommonIO is a collection of utilities used in writing command-line applications, including parsing command line arguments, simple path manipulation, file lading and saving, and printing values, timers and progress bars.","title":"Yocto/CommonIO: Utilities for writing command-line apps"},{"location":"yocto/yocto_commonio/#printing-values","text":"Use print_info(message) to print a message, and print_fatal(message) to print and exit. To time a block of code use print_timed(message) to use an RIIA timer or call print_elapsed(timer) to print the elapsed time as needed. Use print_progress(message, current, total) to print a progress bar with a message for a given current and total number of tasks. print_info ( \"Message\" ); // print message print_fatal ( \"Error and exit\" ); // print error and exit { auto timer = print_timed ( \"Timer\" ); ... } // time a block of code auto timer = print_timed ( \"Timer\" ); // start timer print_elapsed ( timer ); // Print elapsed time for ( auto task : range ( 10 )) // iterate over tasks print_progress ( \"Progress bar\" , task , 10 ); // print progress bar","title":"Printing values"},{"location":"yocto/yocto_commonio/#command-line-parsing","text":"Yocto/CommonIO includes a simple command-line parser that supports optional and positional arguments, automatic help generation, and error checking. The command-line parser is initialized with make_cli(name, help) that takes a program name and a help string. Then add command-line options with add_option(cli, name, value, help, req) where name is the option name, value is a reference to the variable that we want to set, help is a usage message and req is a flag that determines whether or not the argument is required. After adding all arguments, use parse_cli(cli) to parse the command-line. If an error occurs, the parser exists. A help flag is also handled in this function. The argument name determines the argument type. If the arguments name starts with '--' or '-' then it is an option, otherwise it is a positional argument. An argument may have multiple names separated by commas. Options and arguments may be intermixed. The type of each option is determined by the passed reference. The parser supports integers, floating point numbers, strings, bool options and arrays of strings. Boolean flags are indicated with a pair of names \"--name/--no-name\", so that we have both options available. auto samples = 10 ; auto flag = false ; // state auto out = \"\" s , name = \"\" s ; auto names = vector < string > {}; auto cli = make_cli ( \"app\" , \"testing cli\" ); // initialize cli add_option ( cli , \"--out\" , out , \"out\" , true ); // required argument add_option ( cli , \"--samples,-s\" , samples , \"samples\" ); // optional argument add_option ( cli , \"--flag/--no-flag\" , flag , \"flag\" ); // optional flag add_option ( cli , \"name\" , name , \"name\" , true ); // positional argument add_option ( cli , \"names\" , names , \"names\" ); // positional arguments parse_cli ( cli );","title":"Command-Line Parsing"},{"location":"yocto/yocto_commonio/#text-and-binary-serialization","text":"Text files are loaded with load_text(filename, text, error) and saved with save_text(filename, text, error) . Binary files are loaded with load_binary(filename, binary, error) and saved with save_binary(filename, binary, error) . Both loading and saving take a filename, a text or binary buffer, and return whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto error = string {}; // error buffer auto text = string {}; // text buffer if ( ! load_text ( filename , text , error )) // load a text file print_error ( error ); // check and print error if ( ! save_text ( filename , text , error )) // save a text file print_error ( error ); // check and print error auto data = vector < byte > {}; // data buffer if ( ! load_binary ( filename , data , error )) // load a binary file print_error ( error ); // check and print error if ( ! save_binary ( filename , data , error )) // save a binary file print_error ( error ); // check and print error","title":"Text and binary serialization"},{"location":"yocto/yocto_geometry/","text":"Yocto/Geometry: Geometry operations Yocto/Geometry defines basic geometry operations, including computation of basic geometry quantities, ray-primitive intersection, point-primitive distance, primitive bounds, and several interpolation functions. Yocto/Geometry is implemented in yocto_geometry.h . Primitive parametrization Yocto/Geometry supports operations on lines, triangles, quads and beziers. In these functions, triangles are parameterized with barycentric coordinates uv written with respect to the p1-p0 and p2-p0 axes respectively. Quads are internally handled as pairs of triangles p0,p1,p3 and p2,p3,p1 , with the uv coordinates of the second triangle corrected as 1-u and 1-v to produce a quad parametrization where u and v go from 0 to 1. Degenerate quads with p2==p3 represent triangles correctly. This parametrization is equivalent to Intel's Embree. Geometric properties For lines, Yocto/Geometry supports the computation of line lengths, with line_length(p0,p1) , and line tangents, with line_tangent(p0,p1) . For triangles, Yocto/Geometry supports the computation of triangle areas, with triangle_area(p0,p1,p2) , and triangle normals, triangle_normal(p0,p1,p2) . Similarly for quads, use quad_area(p0,p1,p2,p3) , quad_normal(p0,p1,p2,p3) for areas and normals. For triangles and quads, Yocto/Geometry also supports computing tangents and bitangents from texture coordinates. This is helpful for applying normal or bump mapping during rendering. Use triangle_tangents_fromuv(p0,p1,p2,uv0,uv1,uv2) for triangles and quad_tangents_fromuv(p0,p1,p2,p3,uv0,uv1,uv2,uv3,uv) for quads. For triangles, tangents and bitangents are defined with respect to the first vertex as the origin. For quads, we define the vectors on the two triangles and do not compute the average. For this pass an additional texture coordinate since internally we split the triangle into two and we need to known where to do it. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto ta = triangle_area ( p0 , p1 , p2 ); // triangle area auto qa = quad_area ( p0 , p1 , p2 , p3 ); // quad area auto tn = triangle_normal ( p0 , p1 , p2 ); // triangle normal auto qn = quad_normal ( p0 , p1 , p2 , p3 ); // quad normal auto uv0 = vec2f { 0 , 0 }, uv1 = vec2f { 1 , 0 }, uv2 = vec2f { 1 , 1 }, uv3 = vec2f { 0 , 1 }; auto [ tu , tv ] = triangle_tangents_fromuv ( p0 , p1 , p2 , uv0 , uv1 , uv2 ); // tangents Interpolation on primitives For all primitives, Yocto/Geometry defines interpolation functions that take values defined at the primitive vertices and compute the interpolate value at the parametrized point. Lines and beziers are parametrized with their natural parameter, while triangles and quads use barycentric interpolation as defined above. Use interpolate_line(p0,p1,u) for lines, interpolate_triangle(p0,p1,p2,uv) for triangles, interpolate_quad(p0,p1,p2,p3,uv) for quads and interpolate_bezier(p0,p1,p2,p3,u) for cubic Bezier segments, whose derivatives can be computed with interpolate_bezier_derivative(p0,p1,p2,p3,u) . auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto tp = interpolate_triangle ( p0 , p1 , p2 ,{ 0.3 , 0.5 }); // triangle point auto qp = interpolate_quad ( p0 , p1 , p2 , p3 ,{ 0.3 , 0.5 }); // quad point auto lp = interpolate_line ( p0 , p1 , 0.3 ); // line point auto bp = interpolate_bezier ( p0 , p1 , p2 , p3 , 0.3 ); // bezier point Primitive bounding boxes Yocto/Geometry provides functions to compute bounding boxes for all primitives types. For points and lines, vertices might have a thickness associate with them. Use point_bounds(p0,r0) for points, line_bounds(p0,p1,r0,r1) for lines, triangle_bounds(p0,p1,p2) for triangles, quad_bounds(p0,p1,p2,p3) for quads. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto tb = triangle_bounds ( p0 , p1 , p2 ); // triangle bounding box auto qb = quad_bounds ( p0 , p1 , p2 , p3 ); // quad bounding box auto r0 = 0.01 , r1 = 0.01 ; auto lb = line_bounds ( p0 , p1 , r0 , r1 ); // line bounding box auto pb = point_bounds ( p0 , r0 ); // point bounding box Ray-primitive intersections Yocto/Geometry defines functions for ray-primitive intersection. Each function returns wether the primitive was hit and, if so, sets the primitive parameters and the intersection distance as output variables. Triangle intersection are computed using the Moller-Trombone intersection algorithm. Quad intersections are computed by treating quads as two triangles. Point intersections are compute approximately, by treating points as ray-oriented disks. Line intersections are computed approximately, by treating lines as ray-oriented ribbons. Use intersect_point(ray,p0,r0,uv,d) for points, intersect_line(ray,p0,p1,r0,r1,uv,d) for lines, intersect_triangle(ray,p0,p1,p2,uv,d) for triangles, intersect_quad(ray,p0,p1,p2,p3,uv,d) for quads. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto r0 = 0.01 , r1 = 0.01 ; auto ray = ray3f {{ 0 , 0 , 0.5 },{ 0 , 0 , - 1 }}; // ray auto uv = vec2f { 0 , 0 }; auto dist = float { 0 }; // hit distance and uvs auto th = intersect_triangle ( ray , p0 , p1 , p2 , uv , dist )); // triangle intersection auto qh = intersect_quad ( ray , p0 , p1 , p2 , p3 , uv , dist )); // quad intersection auto lh = intersect_line ( ray , p0 , p1 , r0 , r1 , uv , dist )); // line intersection auto ph = intersect_point ( ray , p0 , r0 , uv , dist )); // point intersection Yocto/Geometry defines two functions to test whether a ray hits a bounding box. In this case, we do not return the ray distance or hit, but just check for intersection, which is useful when defining BVH hierarchies. Use intersect_bbox(ray,bbox) as a simple alternative and intersect_bbox(ray,ray_dinv,bbox) for a faster one. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto bbox = quad_bounds ( p0 , p1 , p2 , p3 ); auto bh = intersect_bbox ( ray , bbox ); // bbox intersection check auto ray_dinv = 1 / ray . d ; // ray direction inverse auto bf = intersect_bbox ( ray , ray_dinv , bbox ); // fast bbox intersection Point-primitive overlaps Yocto/Geometry defines functions for point-primitive distance and overlap. Each function returns wether the primitive was hit and, if so, sets the primitive parameters and the overlap distance as output variables. Each function takes a position and a maximum distance to test within, together with primitive vertices and thickness. Use overlap_point(pt,md,p0,r0,uv,d) for points, overlap_line(pt,md,p0,p1,r0,r1,uv,d) for lines, overlap_triangle(pt,md,p0,p1,p2,r0,r1,r2,uv,d) for triangles, overlap_quad(pt,md,p0,p1,p2,p3,r0,r1,r2,r3,uv,d) for quads. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto r0 = 0.01 , r1 = 0.01 , r2 = 0.01 , r3 = 0.01 ; auto pt = vec3f { 0 , 0 , 0.5 }; auto md = float { 1 }; // point and max dist auto uv = vec2f { 0 , 0 }; auto dist = float { 0 }; // hit distance and uv auto th = overlap_triangle ( pt , md , p0 , p1 , p2 , uv , dist )); // triangle overlap auto qh = overlap_quad ( pt , md , p0 , p1 , p2 , p3 , uv , dist )); // quad overlap auto lh = overlap_line ( pt , md , p0 , p1 , r0 , r1 , uv , dist )); // line overlap auto ph = overlap_point ( pt , md , p0 , r0 , uv , dist )); // point overlap Yocto/Geometry defines a function to test whether a point is contained within a bounding bbox within a certain distance. Just like before, we do not return the ray distance or hit, but just check for overlap, which is useful when defining BVH hierarchies. Use overlap_bbox(pt,md,bbox) to test for overlap between a point and a bounding box and overlap_bbox(bbox1,bbox2) to test whether two bounding boxes overlap. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto bbox = quad_bounds ( p0 , p1 , p2 , p3 ); auto bbox2 = bbox3f {{ 0 , 0 , 0 }, { 1 , 1 , 1 }}; auto pt = vec3f { 0 , 0 , 0.5 }; auto md = float { 1 }; // point and max dist auto bh = overlap_bbox ( pt , md , bbox ); // bbox overlap check auto bh2 = overlap_bbox ( bbox , bbox2 ); // bbox overlap check","title":"Geometry operations"},{"location":"yocto/yocto_geometry/#yoctogeometry-geometry-operations","text":"Yocto/Geometry defines basic geometry operations, including computation of basic geometry quantities, ray-primitive intersection, point-primitive distance, primitive bounds, and several interpolation functions. Yocto/Geometry is implemented in yocto_geometry.h .","title":"Yocto/Geometry: Geometry operations"},{"location":"yocto/yocto_geometry/#primitive-parametrization","text":"Yocto/Geometry supports operations on lines, triangles, quads and beziers. In these functions, triangles are parameterized with barycentric coordinates uv written with respect to the p1-p0 and p2-p0 axes respectively. Quads are internally handled as pairs of triangles p0,p1,p3 and p2,p3,p1 , with the uv coordinates of the second triangle corrected as 1-u and 1-v to produce a quad parametrization where u and v go from 0 to 1. Degenerate quads with p2==p3 represent triangles correctly. This parametrization is equivalent to Intel's Embree.","title":"Primitive parametrization"},{"location":"yocto/yocto_geometry/#geometric-properties","text":"For lines, Yocto/Geometry supports the computation of line lengths, with line_length(p0,p1) , and line tangents, with line_tangent(p0,p1) . For triangles, Yocto/Geometry supports the computation of triangle areas, with triangle_area(p0,p1,p2) , and triangle normals, triangle_normal(p0,p1,p2) . Similarly for quads, use quad_area(p0,p1,p2,p3) , quad_normal(p0,p1,p2,p3) for areas and normals. For triangles and quads, Yocto/Geometry also supports computing tangents and bitangents from texture coordinates. This is helpful for applying normal or bump mapping during rendering. Use triangle_tangents_fromuv(p0,p1,p2,uv0,uv1,uv2) for triangles and quad_tangents_fromuv(p0,p1,p2,p3,uv0,uv1,uv2,uv3,uv) for quads. For triangles, tangents and bitangents are defined with respect to the first vertex as the origin. For quads, we define the vectors on the two triangles and do not compute the average. For this pass an additional texture coordinate since internally we split the triangle into two and we need to known where to do it. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto ta = triangle_area ( p0 , p1 , p2 ); // triangle area auto qa = quad_area ( p0 , p1 , p2 , p3 ); // quad area auto tn = triangle_normal ( p0 , p1 , p2 ); // triangle normal auto qn = quad_normal ( p0 , p1 , p2 , p3 ); // quad normal auto uv0 = vec2f { 0 , 0 }, uv1 = vec2f { 1 , 0 }, uv2 = vec2f { 1 , 1 }, uv3 = vec2f { 0 , 1 }; auto [ tu , tv ] = triangle_tangents_fromuv ( p0 , p1 , p2 , uv0 , uv1 , uv2 ); // tangents","title":"Geometric properties"},{"location":"yocto/yocto_geometry/#interpolation-on-primitives","text":"For all primitives, Yocto/Geometry defines interpolation functions that take values defined at the primitive vertices and compute the interpolate value at the parametrized point. Lines and beziers are parametrized with their natural parameter, while triangles and quads use barycentric interpolation as defined above. Use interpolate_line(p0,p1,u) for lines, interpolate_triangle(p0,p1,p2,uv) for triangles, interpolate_quad(p0,p1,p2,p3,uv) for quads and interpolate_bezier(p0,p1,p2,p3,u) for cubic Bezier segments, whose derivatives can be computed with interpolate_bezier_derivative(p0,p1,p2,p3,u) . auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto tp = interpolate_triangle ( p0 , p1 , p2 ,{ 0.3 , 0.5 }); // triangle point auto qp = interpolate_quad ( p0 , p1 , p2 , p3 ,{ 0.3 , 0.5 }); // quad point auto lp = interpolate_line ( p0 , p1 , 0.3 ); // line point auto bp = interpolate_bezier ( p0 , p1 , p2 , p3 , 0.3 ); // bezier point","title":"Interpolation on primitives"},{"location":"yocto/yocto_geometry/#primitive-bounding-boxes","text":"Yocto/Geometry provides functions to compute bounding boxes for all primitives types. For points and lines, vertices might have a thickness associate with them. Use point_bounds(p0,r0) for points, line_bounds(p0,p1,r0,r1) for lines, triangle_bounds(p0,p1,p2) for triangles, quad_bounds(p0,p1,p2,p3) for quads. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto tb = triangle_bounds ( p0 , p1 , p2 ); // triangle bounding box auto qb = quad_bounds ( p0 , p1 , p2 , p3 ); // quad bounding box auto r0 = 0.01 , r1 = 0.01 ; auto lb = line_bounds ( p0 , p1 , r0 , r1 ); // line bounding box auto pb = point_bounds ( p0 , r0 ); // point bounding box","title":"Primitive bounding boxes"},{"location":"yocto/yocto_geometry/#ray-primitive-intersections","text":"Yocto/Geometry defines functions for ray-primitive intersection. Each function returns wether the primitive was hit and, if so, sets the primitive parameters and the intersection distance as output variables. Triangle intersection are computed using the Moller-Trombone intersection algorithm. Quad intersections are computed by treating quads as two triangles. Point intersections are compute approximately, by treating points as ray-oriented disks. Line intersections are computed approximately, by treating lines as ray-oriented ribbons. Use intersect_point(ray,p0,r0,uv,d) for points, intersect_line(ray,p0,p1,r0,r1,uv,d) for lines, intersect_triangle(ray,p0,p1,p2,uv,d) for triangles, intersect_quad(ray,p0,p1,p2,p3,uv,d) for quads. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto r0 = 0.01 , r1 = 0.01 ; auto ray = ray3f {{ 0 , 0 , 0.5 },{ 0 , 0 , - 1 }}; // ray auto uv = vec2f { 0 , 0 }; auto dist = float { 0 }; // hit distance and uvs auto th = intersect_triangle ( ray , p0 , p1 , p2 , uv , dist )); // triangle intersection auto qh = intersect_quad ( ray , p0 , p1 , p2 , p3 , uv , dist )); // quad intersection auto lh = intersect_line ( ray , p0 , p1 , r0 , r1 , uv , dist )); // line intersection auto ph = intersect_point ( ray , p0 , r0 , uv , dist )); // point intersection Yocto/Geometry defines two functions to test whether a ray hits a bounding box. In this case, we do not return the ray distance or hit, but just check for intersection, which is useful when defining BVH hierarchies. Use intersect_bbox(ray,bbox) as a simple alternative and intersect_bbox(ray,ray_dinv,bbox) for a faster one. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto bbox = quad_bounds ( p0 , p1 , p2 , p3 ); auto bh = intersect_bbox ( ray , bbox ); // bbox intersection check auto ray_dinv = 1 / ray . d ; // ray direction inverse auto bf = intersect_bbox ( ray , ray_dinv , bbox ); // fast bbox intersection","title":"Ray-primitive intersections"},{"location":"yocto/yocto_geometry/#point-primitive-overlaps","text":"Yocto/Geometry defines functions for point-primitive distance and overlap. Each function returns wether the primitive was hit and, if so, sets the primitive parameters and the overlap distance as output variables. Each function takes a position and a maximum distance to test within, together with primitive vertices and thickness. Use overlap_point(pt,md,p0,r0,uv,d) for points, overlap_line(pt,md,p0,p1,r0,r1,uv,d) for lines, overlap_triangle(pt,md,p0,p1,p2,r0,r1,r2,uv,d) for triangles, overlap_quad(pt,md,p0,p1,p2,p3,r0,r1,r2,r3,uv,d) for quads. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto r0 = 0.01 , r1 = 0.01 , r2 = 0.01 , r3 = 0.01 ; auto pt = vec3f { 0 , 0 , 0.5 }; auto md = float { 1 }; // point and max dist auto uv = vec2f { 0 , 0 }; auto dist = float { 0 }; // hit distance and uv auto th = overlap_triangle ( pt , md , p0 , p1 , p2 , uv , dist )); // triangle overlap auto qh = overlap_quad ( pt , md , p0 , p1 , p2 , p3 , uv , dist )); // quad overlap auto lh = overlap_line ( pt , md , p0 , p1 , r0 , r1 , uv , dist )); // line overlap auto ph = overlap_point ( pt , md , p0 , r0 , uv , dist )); // point overlap Yocto/Geometry defines a function to test whether a point is contained within a bounding bbox within a certain distance. Just like before, we do not return the ray distance or hit, but just check for overlap, which is useful when defining BVH hierarchies. Use overlap_bbox(pt,md,bbox) to test for overlap between a point and a bounding box and overlap_bbox(bbox1,bbox2) to test whether two bounding boxes overlap. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto bbox = quad_bounds ( p0 , p1 , p2 , p3 ); auto bbox2 = bbox3f {{ 0 , 0 , 0 }, { 1 , 1 , 1 }}; auto pt = vec3f { 0 , 0 , 0.5 }; auto md = float { 1 }; // point and max dist auto bh = overlap_bbox ( pt , md , bbox ); // bbox overlap check auto bh2 = overlap_bbox ( bbox , bbox2 ); // bbox overlap check","title":"Point-primitive overlaps"},{"location":"yocto/yocto_image/","text":"Yocto/Image: Image utilities Yocto/Image is a collection of image utilities useful when writing rendering algorithms. These include a simple image data structure, color conversion utilities and tone mapping, loading and saving functionality, and image resizing. Yocto/Image is implemented in yocto_image.h and yocto_image.cpp , and depends on stb_image.h , stb_image_write.h , stb_image_resize.h , tinyexr.h for the image serialization. Image representation Images are stored in a generic container named image<T> , where pixels can be of any type. The convention is Yocto/GL is to use vec3f and vec4f for RGB amd RGBA images respectively, or vec3b and vec4b for 8-bit storage. The container has a design that is similar in spirit to std::vector<T> . Images are intended to be used as value types. Im memory, image pixels are stored in 1D array in row-major order. Images are default-initialized to an empty container, or can be initialized with a size and either a constant value or a pointer to image data. Use img.imsize() to get the image width and height as a vec2i , img.count() to get the number of pixels, and img.empty() to check whether the image is empty. Images can be resized with img.resize(size) , re-initialized with img.assign(size, value) and cleared with img.clear() . auto img = image < vec4f > {{ 512 , 512 }, { 1 , 0 , 0 , 1 }}; // creates a 512x512 red image auto size = img . imsize (); // size == {512,512} asset ( ! img . empty ()); // check if empty img . resize ({ 1024 , 512 }); // resize to {1024,512} img . assign ({ 1024 , 512 }, { 0 , 1 , 0 , 1 }); // re-initialize as green Image pixels are accessed via the bracket operator using image coordinates represented as vec2i , i.e. img[{i,j}] . Pixels can also be accessed with a sequential index as img[idx] . Pixels can iterated with a foreach or accessed directly by getting a pointer to the underlying data buffer with img.data() . auto img = image < vec4f > {{ 512 , 512 }, { 1 , 0 , 0 , 1 }}; // creates a 512x512 img [{ 10 , 10 }] = { 0 , 1 , 0 , 1 }; // set pixel at 10,10 for ( auto & p : img ) print ( p ); // iterate over pixels print ( img [ 1000 ]); // sequential access auto pixels = img . data (); // get pixel buffer Image sampling Images are sampled with eval_image(img,uv) . Yocto/Image supports sampling of 3 or 4 channel images with float or byte channels. All results are converted in float values for increased precision. For byte images, sampling can be performed in sRGB or linear color space. By default, images are sampled with bilinear interpolation and tiling, with nearest-neighbor interpolation and edge-clamp behavior available as overrides. auto hdr = image < vec4f > {...}; // creates a float image auto ch0 = eval_image ( hdr , { 0.5 , 0.5 }); // samples the image center auto ch1 = eval_image ( hdr , { 0.5 , 0.5 }, false ); // nearest-neighbor interpolation auto ch2 = eval_image ( hdr , { 0.5 , 0.5 }, false , false ); // clamp to edge auto ldr = image < vec4b > {...}; // creates an 8bit image auto ch0 = eval_image ( ldr , { 0.5 , 0.5 }); // samples in sRGB, returns linear RGB auto ch1 = eval_image ( ldr , { 0.5 , 0.5 }, true ); // treats 8bit values as linear Color conversions For convenience, Yocto/Image define functions that convert images between float and byte channels, and between linear RGB and sRGB representations, for images that have one, three and four channels. Use byte_to_float(img) and float_to_byte(img) for conversion between float and byte images. Use rgb_to_srgb(img) and srgb_to_rgb(img) for conversions between linear and sRGB color spaces. auto img_f = image < vec4f > {...}; // initialize a linear, float image auto img_b = float_to_byte ( img_f ); // convert to 8bit channels auto img_s = rgb_to_srgb ( img ); // convert to sRGB Tone mapping HDR images can be tone mapped using tonemap_image(hdr,e) that applies an exposure correction followed by an optional filmic tone curve. Use tonemap_image_mt(...) to quickly tone map large images using multiple threads. auto hdr = image < vec4f > {...}; // initialize am HDR image auto ldr = tonemap_imahe ( hdr , 0 ); // tone mapping auto flm = tonemap_imahe ( hdr , 0 , true ); // filmic tone mapping Color grading Images can be color graded by applying a set of minimal color grading tools using colorgrade_image(img,linear,params) , in manner similar to Hable 2017 . Color grading corrections can be applied on images that are either linear HDR or non-linear LDR, i.e. sRGB encoded. The results is always an LDR image encoded in sRGB. Use colorgrade_image_mt(...) to quickly tone map large images using multiple threads. Several color corrections are bundled together with their parameters packed in a convenience structure colorgrade_params . Color grading operations are applied in a fixed sequence and consist of the following operations: exposure compensation, color tint, contrast in the log domain, filmic curve, conversion to sRGB, S-shaped contrast, saturation, and shadow/midtone/highlight correction. Color tinting can be used to apply white balance by using compute_white_balance(img) to determine the correct color. auto hdr = image < vec4f > {...}; // initialize am HDR image auto params = colorgrade_params {}; // default color grading params params . exposure = 1 ; // set desired params params . logcontrast = 0.75 ; // set desired params params . tint = compute_white_balance ( hdr ); // apply white balance auto ldr = colorgrade_image ( hdr , true , params ); // color grading Image resizing Images are can resized with resize_image(img,size) . Just like all other functions, images are not resized in placed, but a new image is created. Resizing works for both linear and 8bit images. The size parameter can be used to perform aspect-preserving resizing by leaving one dimension as zero. auto img = image < vec4f > {...}; // initialize an image auto res = resize_image ( img , { 512 , 512 }); // resizing to fixed size auto asp = resize_image ( img , { 512 , 0 }); // aspect-preserving Image diffing Image difference can be computed using image_difference(a,b) . This function performs a simple per-pixel difference and returns the image so that one can use any metric to determine whether images where different within some threshold. Optionally, a difference image is returned that highlights the diff. auto a = image < vec4f > {...}, b = image < vec4f > {...}; // init images auto diff = image_difference ( a , b ); // image difference auto display = image_difference ( a , b , true ); // diff display Image loading and saving Images are loaded with load_image(filename,img,error) and saved with save_image(filename, img, error) . Both loading and saving take a filename, an image buffer and return whether or not the image was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Yocto/Images supports loading and saving to JPG, PNG, TGA, BMP, HDR, EXR. Yocto/Image supports loading and saving of images that have 1-4 channels and have either float or byte channels. The number of channel and type is selected using overloads. When loading images, the desired number of channels is determined by the function overload. If the image content does not contain the same number of channels, these are automatically converted to the desired color format. Float images are returned encoded in linear RGB color space, while 8bit images are returned encoded in sRGB. Since color space information is not present in many images and since it is customary in 3D graphics to misuse color encoding, e.g. normal maps stored in sRGB, during loading 8bit file formats are assume to be encoded sRGB, while float formats are assume to be encoded in linear RGB. When channel type differ between the desired output and the file one, the appropriate linear-to-sRGB conversion is applied. Use is_hdr_filename(filename) to determine whether a supported format contains linear float data. When saving images, float images are expected to be encoded in linear RGB and are saved as is to file formats capable of storing floats, or converted to sRGB for file formats that support only that. Byte images are expected to be encoded is sRGB and saved as is to 8bit file formats or converted to linear RGB for saving to floating point file formats. auto error = string {}; auto img4f = image < vec4f > {}; // define desired image format if ( ! load_image ( filename , img4f , error )) // load image as 4-channel linear print_error ( error ); // check and print error auto img4b = image < vec4b > {}; // define desired image format if ( ! load_image ( filename , img4b , error )) // load image as 4-channel sRGB print_error ( error ); // check and print error auto is_hdr = is_hdr_filename ( filename ); // check if hdr format if ( is_hdr ) ok = load_image ( filename , img4f , error ); // load as linear else ok = load_image ( filename , img4b , error ); // or sRGB if ( ! save_image ( filename , img4f , error )) // save image as 4-channel linear print_error ( error ); // check and print error if ( ! save_image ( filename , img4f , error )) // save image as 4-channel linear print_error ( error ); // check and print error Procedural images Yocto/Image defines several procedural images used for both testing and to quickly create textures for procedural scenes. Testing patterns take as input the desired image size, the pattern scale, and optionally two colors to interpolate between. Use make_grid(...) for a grid image, make_checker(...) for a checker, make_bumps(...) for a bumpy test, make_ramp(...) for a linear ramp, make_gammaramp(...) for a ramp with different gamma settings, make_uvramp(...) and make_uvgrid(...) for test images for texture coordinates as either ramps or grids, make_colormapramp(...) for a ramp to test different color maps, and make_blackbodyramp(...) for a ramp with different blackbody temperatures. Perlin noise patterns can be generated with make_noisemap(...) , make_fbmmap(...) , make_fbmmap(...) and make_fbmmap(...) . The latter three functions take as input the set of params that control fractal variations. See Yocto/Noise for a description. auto size = vec2i { 512 , 512 }; // image size auto scale = float { 1 }; // pattern scale auto c0 = vec4f { 0 , 0 , 0 , 1 }, c1 = vec4f { 0 , 0 , 0 , 1 }; // colors auto i1 = make_grid ( size , scale , c0 , c1 ); // grid image auto i2 = make_checker ( size , scale , c0 , c1 ); // checker image auto i3 = make_bumps ( size , scale , c0 , c1 ); // bumps image auto i4 = make_ramp ( size , scale , c0 , c1 ); // ramp image auto i5 = make_gammaramp ( size , scale , c0 , c1 ); // gamma ramp image auto i6 = make_uvramp ( size , scale ); // uv ramp image auto i7 = make_uvgrid ( size , scale ); // uv grid image auto i8 = make_colormapramp ( size , scale ); // color map image auto t0 = 1000 , t1 = 12000 ; // blackbody temperatures auto b2 = make_blackbodyramp ( size , scale , t0 , t1 ); // blackbody ramp image auto noise = vec4f { 2 , 0.5 , 8 , 1 }; // noise params auto n1 = make_noisemap ( size , scale , noise , c0 , c1 ); // noise image auto n2 = make_fbmmap ( size , scale , noise , c0 , c1 ); // fbm image auto n3 = make_turbulencemap ( size , scale , noise , c0 , c1 ); // turbulence image auto n4 = make_ridgemap ( size , scale , noise , c0 , c1 ); // ridge image Procedurals skies are generated with make_sunsky(img, size, elevation, turbidity, sun) . The function returns a procedural HDR sky. The sun position is controlled by its elevation that is an angle in [0,pi/2\\] . The sky turbidity is controlled by the turbidity parameter that is defined in the range [1.7,10] . The sun flag determines whether the sun disk is present in the image. The function support optional parameters to control sun size and intensity and ground albedo, mostly used for artistic effects. auto sky = make_sunsky ({ 1024 , 512 }, pi / 2 , 3 ); // clear sky auto sun = make_sunsky ({ 1024 , 512 }, pi / 2 , 3 , true ); // clear sky with sun auto tur = make_sunsky ({ 1024 , 512 }, pi / 2 , 10 ); // sky with turbidity Use bump_to_normal(bumps) to convert a bump map to a normal map, with both images stored in a linear color spaces. auto bumps = make_bumps ({ 512 , 512 }); // procedural bump map auto normal = bump_to_normal ( bumps ); // convert bump map to normal map Finally, borders can be added to images using add_border(img,width,color) . auto img = image < vec4f > {...}; // image auto bordered = add_border ( img , 1 , { 0 , 0 , 0 , 1 }); // add a thin black border","title":"Image utilities"},{"location":"yocto/yocto_image/#yoctoimage-image-utilities","text":"Yocto/Image is a collection of image utilities useful when writing rendering algorithms. These include a simple image data structure, color conversion utilities and tone mapping, loading and saving functionality, and image resizing. Yocto/Image is implemented in yocto_image.h and yocto_image.cpp , and depends on stb_image.h , stb_image_write.h , stb_image_resize.h , tinyexr.h for the image serialization.","title":"Yocto/Image: Image utilities"},{"location":"yocto/yocto_image/#image-representation","text":"Images are stored in a generic container named image<T> , where pixels can be of any type. The convention is Yocto/GL is to use vec3f and vec4f for RGB amd RGBA images respectively, or vec3b and vec4b for 8-bit storage. The container has a design that is similar in spirit to std::vector<T> . Images are intended to be used as value types. Im memory, image pixels are stored in 1D array in row-major order. Images are default-initialized to an empty container, or can be initialized with a size and either a constant value or a pointer to image data. Use img.imsize() to get the image width and height as a vec2i , img.count() to get the number of pixels, and img.empty() to check whether the image is empty. Images can be resized with img.resize(size) , re-initialized with img.assign(size, value) and cleared with img.clear() . auto img = image < vec4f > {{ 512 , 512 }, { 1 , 0 , 0 , 1 }}; // creates a 512x512 red image auto size = img . imsize (); // size == {512,512} asset ( ! img . empty ()); // check if empty img . resize ({ 1024 , 512 }); // resize to {1024,512} img . assign ({ 1024 , 512 }, { 0 , 1 , 0 , 1 }); // re-initialize as green Image pixels are accessed via the bracket operator using image coordinates represented as vec2i , i.e. img[{i,j}] . Pixels can also be accessed with a sequential index as img[idx] . Pixels can iterated with a foreach or accessed directly by getting a pointer to the underlying data buffer with img.data() . auto img = image < vec4f > {{ 512 , 512 }, { 1 , 0 , 0 , 1 }}; // creates a 512x512 img [{ 10 , 10 }] = { 0 , 1 , 0 , 1 }; // set pixel at 10,10 for ( auto & p : img ) print ( p ); // iterate over pixels print ( img [ 1000 ]); // sequential access auto pixels = img . data (); // get pixel buffer","title":"Image representation"},{"location":"yocto/yocto_image/#image-sampling","text":"Images are sampled with eval_image(img,uv) . Yocto/Image supports sampling of 3 or 4 channel images with float or byte channels. All results are converted in float values for increased precision. For byte images, sampling can be performed in sRGB or linear color space. By default, images are sampled with bilinear interpolation and tiling, with nearest-neighbor interpolation and edge-clamp behavior available as overrides. auto hdr = image < vec4f > {...}; // creates a float image auto ch0 = eval_image ( hdr , { 0.5 , 0.5 }); // samples the image center auto ch1 = eval_image ( hdr , { 0.5 , 0.5 }, false ); // nearest-neighbor interpolation auto ch2 = eval_image ( hdr , { 0.5 , 0.5 }, false , false ); // clamp to edge auto ldr = image < vec4b > {...}; // creates an 8bit image auto ch0 = eval_image ( ldr , { 0.5 , 0.5 }); // samples in sRGB, returns linear RGB auto ch1 = eval_image ( ldr , { 0.5 , 0.5 }, true ); // treats 8bit values as linear","title":"Image sampling"},{"location":"yocto/yocto_image/#color-conversions","text":"For convenience, Yocto/Image define functions that convert images between float and byte channels, and between linear RGB and sRGB representations, for images that have one, three and four channels. Use byte_to_float(img) and float_to_byte(img) for conversion between float and byte images. Use rgb_to_srgb(img) and srgb_to_rgb(img) for conversions between linear and sRGB color spaces. auto img_f = image < vec4f > {...}; // initialize a linear, float image auto img_b = float_to_byte ( img_f ); // convert to 8bit channels auto img_s = rgb_to_srgb ( img ); // convert to sRGB","title":"Color conversions"},{"location":"yocto/yocto_image/#tone-mapping","text":"HDR images can be tone mapped using tonemap_image(hdr,e) that applies an exposure correction followed by an optional filmic tone curve. Use tonemap_image_mt(...) to quickly tone map large images using multiple threads. auto hdr = image < vec4f > {...}; // initialize am HDR image auto ldr = tonemap_imahe ( hdr , 0 ); // tone mapping auto flm = tonemap_imahe ( hdr , 0 , true ); // filmic tone mapping","title":"Tone mapping"},{"location":"yocto/yocto_image/#color-grading","text":"Images can be color graded by applying a set of minimal color grading tools using colorgrade_image(img,linear,params) , in manner similar to Hable 2017 . Color grading corrections can be applied on images that are either linear HDR or non-linear LDR, i.e. sRGB encoded. The results is always an LDR image encoded in sRGB. Use colorgrade_image_mt(...) to quickly tone map large images using multiple threads. Several color corrections are bundled together with their parameters packed in a convenience structure colorgrade_params . Color grading operations are applied in a fixed sequence and consist of the following operations: exposure compensation, color tint, contrast in the log domain, filmic curve, conversion to sRGB, S-shaped contrast, saturation, and shadow/midtone/highlight correction. Color tinting can be used to apply white balance by using compute_white_balance(img) to determine the correct color. auto hdr = image < vec4f > {...}; // initialize am HDR image auto params = colorgrade_params {}; // default color grading params params . exposure = 1 ; // set desired params params . logcontrast = 0.75 ; // set desired params params . tint = compute_white_balance ( hdr ); // apply white balance auto ldr = colorgrade_image ( hdr , true , params ); // color grading","title":"Color grading"},{"location":"yocto/yocto_image/#image-resizing","text":"Images are can resized with resize_image(img,size) . Just like all other functions, images are not resized in placed, but a new image is created. Resizing works for both linear and 8bit images. The size parameter can be used to perform aspect-preserving resizing by leaving one dimension as zero. auto img = image < vec4f > {...}; // initialize an image auto res = resize_image ( img , { 512 , 512 }); // resizing to fixed size auto asp = resize_image ( img , { 512 , 0 }); // aspect-preserving","title":"Image resizing"},{"location":"yocto/yocto_image/#image-diffing","text":"Image difference can be computed using image_difference(a,b) . This function performs a simple per-pixel difference and returns the image so that one can use any metric to determine whether images where different within some threshold. Optionally, a difference image is returned that highlights the diff. auto a = image < vec4f > {...}, b = image < vec4f > {...}; // init images auto diff = image_difference ( a , b ); // image difference auto display = image_difference ( a , b , true ); // diff display","title":"Image diffing"},{"location":"yocto/yocto_image/#image-loading-and-saving","text":"Images are loaded with load_image(filename,img,error) and saved with save_image(filename, img, error) . Both loading and saving take a filename, an image buffer and return whether or not the image was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Yocto/Images supports loading and saving to JPG, PNG, TGA, BMP, HDR, EXR. Yocto/Image supports loading and saving of images that have 1-4 channels and have either float or byte channels. The number of channel and type is selected using overloads. When loading images, the desired number of channels is determined by the function overload. If the image content does not contain the same number of channels, these are automatically converted to the desired color format. Float images are returned encoded in linear RGB color space, while 8bit images are returned encoded in sRGB. Since color space information is not present in many images and since it is customary in 3D graphics to misuse color encoding, e.g. normal maps stored in sRGB, during loading 8bit file formats are assume to be encoded sRGB, while float formats are assume to be encoded in linear RGB. When channel type differ between the desired output and the file one, the appropriate linear-to-sRGB conversion is applied. Use is_hdr_filename(filename) to determine whether a supported format contains linear float data. When saving images, float images are expected to be encoded in linear RGB and are saved as is to file formats capable of storing floats, or converted to sRGB for file formats that support only that. Byte images are expected to be encoded is sRGB and saved as is to 8bit file formats or converted to linear RGB for saving to floating point file formats. auto error = string {}; auto img4f = image < vec4f > {}; // define desired image format if ( ! load_image ( filename , img4f , error )) // load image as 4-channel linear print_error ( error ); // check and print error auto img4b = image < vec4b > {}; // define desired image format if ( ! load_image ( filename , img4b , error )) // load image as 4-channel sRGB print_error ( error ); // check and print error auto is_hdr = is_hdr_filename ( filename ); // check if hdr format if ( is_hdr ) ok = load_image ( filename , img4f , error ); // load as linear else ok = load_image ( filename , img4b , error ); // or sRGB if ( ! save_image ( filename , img4f , error )) // save image as 4-channel linear print_error ( error ); // check and print error if ( ! save_image ( filename , img4f , error )) // save image as 4-channel linear print_error ( error ); // check and print error","title":"Image loading and saving"},{"location":"yocto/yocto_image/#procedural-images","text":"Yocto/Image defines several procedural images used for both testing and to quickly create textures for procedural scenes. Testing patterns take as input the desired image size, the pattern scale, and optionally two colors to interpolate between. Use make_grid(...) for a grid image, make_checker(...) for a checker, make_bumps(...) for a bumpy test, make_ramp(...) for a linear ramp, make_gammaramp(...) for a ramp with different gamma settings, make_uvramp(...) and make_uvgrid(...) for test images for texture coordinates as either ramps or grids, make_colormapramp(...) for a ramp to test different color maps, and make_blackbodyramp(...) for a ramp with different blackbody temperatures. Perlin noise patterns can be generated with make_noisemap(...) , make_fbmmap(...) , make_fbmmap(...) and make_fbmmap(...) . The latter three functions take as input the set of params that control fractal variations. See Yocto/Noise for a description. auto size = vec2i { 512 , 512 }; // image size auto scale = float { 1 }; // pattern scale auto c0 = vec4f { 0 , 0 , 0 , 1 }, c1 = vec4f { 0 , 0 , 0 , 1 }; // colors auto i1 = make_grid ( size , scale , c0 , c1 ); // grid image auto i2 = make_checker ( size , scale , c0 , c1 ); // checker image auto i3 = make_bumps ( size , scale , c0 , c1 ); // bumps image auto i4 = make_ramp ( size , scale , c0 , c1 ); // ramp image auto i5 = make_gammaramp ( size , scale , c0 , c1 ); // gamma ramp image auto i6 = make_uvramp ( size , scale ); // uv ramp image auto i7 = make_uvgrid ( size , scale ); // uv grid image auto i8 = make_colormapramp ( size , scale ); // color map image auto t0 = 1000 , t1 = 12000 ; // blackbody temperatures auto b2 = make_blackbodyramp ( size , scale , t0 , t1 ); // blackbody ramp image auto noise = vec4f { 2 , 0.5 , 8 , 1 }; // noise params auto n1 = make_noisemap ( size , scale , noise , c0 , c1 ); // noise image auto n2 = make_fbmmap ( size , scale , noise , c0 , c1 ); // fbm image auto n3 = make_turbulencemap ( size , scale , noise , c0 , c1 ); // turbulence image auto n4 = make_ridgemap ( size , scale , noise , c0 , c1 ); // ridge image Procedurals skies are generated with make_sunsky(img, size, elevation, turbidity, sun) . The function returns a procedural HDR sky. The sun position is controlled by its elevation that is an angle in [0,pi/2\\] . The sky turbidity is controlled by the turbidity parameter that is defined in the range [1.7,10] . The sun flag determines whether the sun disk is present in the image. The function support optional parameters to control sun size and intensity and ground albedo, mostly used for artistic effects. auto sky = make_sunsky ({ 1024 , 512 }, pi / 2 , 3 ); // clear sky auto sun = make_sunsky ({ 1024 , 512 }, pi / 2 , 3 , true ); // clear sky with sun auto tur = make_sunsky ({ 1024 , 512 }, pi / 2 , 10 ); // sky with turbidity Use bump_to_normal(bumps) to convert a bump map to a normal map, with both images stored in a linear color spaces. auto bumps = make_bumps ({ 512 , 512 }); // procedural bump map auto normal = bump_to_normal ( bumps ); // convert bump map to normal map Finally, borders can be added to images using add_border(img,width,color) . auto img = image < vec4f > {...}; // image auto bordered = add_border ( img , 1 , { 0 , 0 , 0 , 1 }); // add a thin black border","title":"Procedural images"},{"location":"yocto/yocto_math/","text":"Yocto/Math: Math types Yocto/Math defines the basic math primitives used in graphics, including small-sized vectors, matrices, frames, quaternions, rays, bounding boxes and their transforms. Yocto/Math is implemented in yocto_math.h . Vectors The most basic types defined in Yocto/Math are fixed-length vectors in 1 to 4 dimensions with either float or int coordinates, namely vec1f , vec2f , vec3f , vec4f , vec1i , vec2i , vec3i , vec4i . One-dimensional vectors are defined for completeness. Vectors coordinates are default-initialized to zeros. Vectors are constructed by specifying all their coordinates. For convenience, Yocto/Math defines common constants, i.e. zeroXX , to initialize zero vectors. Vector coordinates are accessed by index, e.g. v[0] , or by name, using v.x , v.y , v.z , v.w . While in graphics it is common to use the latter, we suggest to instead use the former since it better generalizes to different cases. Vectors support component-wise arithmetic, equality and assignment operators. For arithmetic operators, both vector and scalar operands are supported. Yocto/Math also overrides many common math function to work on vectors by component-wise evaluation, including trigonometric and exponentiation functions, and component-wise abs, max, min and clamp. Real vector types additionally support vector products and lengths. For 3D vectors, we also define reflection and refraction vectors following GLSL. Matrices Yocto/Math supports 2-4 dimensional square matrices, namely mat2f , mat3f and mat4f . Matrices are stored on column-major order. Matrices are initialized to the identity matrix and constructed by passing matrix columns. Matrix columns are accessed using indexing, i.e. mat[col] . Yocto/Math defines convenience constants for common matrices, e.g. indentity3x3f , etc. Matrices support linear algebra summation and scaling operations, component-wise equality, matrix-matrix and matrix-vector products. All these operators use standard math notation. Matrices also support the computation of transpose, inverse and adjoint matrices, with transpose(a) , inverse(a) and adjoint(a) . Frames To represent transformations, most of the library facilities prefer the use coordinate frames, aka rigid transforms, represented as frame2f and frame3f . Frames are represented in column-major order, with columns defined as the axis of the coordinate frame followed by the origin. This is equivalent to representing rigid transformations as column-major affine matrices. Use mat_to_frame(mat) and frame_to_mat(frame) to convert between these types. Frames support only multiplication operations with other frames, to chain transforms, the computation of their inverses, with inverse(f) , and the creation of frames aligned with one ot two axis, i.e. frame_fromz(o,z) and frame_fromxz(o,z,x) . For the inverse computation, the default is to assume that the frame is orthonormal to get a fast answer. This can be overridden as shown in the example. auto f1 = frame3f { x , y , z , o }; // construct a frame from axes and origin auto of = inverse ( f1 ); // assume f is orthonormal auto gf = inverse ( f1 , true ); // treat f as a generic affine matrix Quaternions Quaternions are represented as quat4f . Quaternions support is minimal and focuses on representing rotations, i.e. unit quaternions. Quaternions are initialized to a unit quaternion, that can also be set with the convenience constant identityq4f . Quaternions support addition, multiplication and scaling, together with dot(q1,q2) , length(q) and normalize(q) . For unit quaternions, Yocto/Math also defines the quaternion inverse inverse(q) and several interpolation function including linear interpolation, normalized linear interpolation and spherical interpolation, respectively with lerp(a,bt) , nlerp(a,b,t) and slerp(a,b,t) . Rays Yocto/Math defines rays in 2-3 dimensions as ray2f and ray3f . Rays are defined as an origin o , a direction d and minimum and maximum values for the distance along a ray, namely tmin and tmax . To compute a point in a ray, use ray_point(ray,t) . See Yocto/Geometry for ray-primitive intersection. auto ray = ray3f { origin , direction }; auto p = ray_point ( ray , 0.5 ); Bounding boxes Yocto/Math defines axies-aligned bounding boxes in 2 to 3 dimensions as bbox2f and bbox3f . Bounding boxes store the minimum and maximum coordinate values, that can be accessed with b.min and b.max . Bounding boxes are default-initialized to an invalid state that contains no points, or they are constructed by specifying the min and max values directly. To build bounds for complex primitives, bounding boxes are very initialized to empty bounds, that can be done by using the constants like invalidabXf , and then grown to encompass either points or other bounding boxes with merge(b,p) . See Yocto/Geometry for building bounding boxes for geometric primitives. auto bbox = invalidb3f ; for ( auto point : points ) bbox = merge ( bbox , point ); Transforms Yocto/Math uses linear algebra vectors for holding different geometric quantities, such as points, vectors, directions and normals. For this reason, we define different functions to transform these quantities, namely transform_point(f,p) to transform points, transform_vector(f,v) to transform vectors, transform_direction(f,d) to transform directions intended as normalized vectors, and transform_normal(f,n) to transform normals. Yocto/Math provides overrides to transforms for both frames and matrices, but the preferred transform representation in Yocto/GL are frames . When transforming normals by matrices, the inverse transform is computed on the fly for correctness. When transforming normals by frames, frames are assumed to be orthonormal and used as is, unless specifically requested as for inverses. For convenience, Yocto/Math provides several functions to construct transform frames and matrices. Translation, rotation and scaling frames are created with translation_frame(t) , rotation_frame(r) and scaling_frame(s) . Rotation frames can be derived from axis-angle, quaternion and matrix representations. To define camera frames, one can use lookat_frame(from,to,up) . auto f = tranlation_frame ({ 1 , 0 , 0 }) * rotation_frame ({ 0 , 1 , 0 }, pi / 2 ); // transform auto lp = vec3f { 1 , 2 , 3 }, lv = vec3f { 0 , 2 , 3 }; // point and vector in local coords auto wp = transform_point ( f , lp ); // point in world coords auto wv = transform_vector ( f , lv ); // vector in world coords For use in GPU programming, Yocto/Math also defines various projection matrices in the style of GLU/GLM, namely frustum_mat(...) , ortho_mat(...) , ortho2d_mat(...) , and perspective_mat(...) . User-Interface Transforms Yocto/Math provides a few utilities for writing user interfaces for 2D images and 3D environments. For images, we assume that image are scaled and than translated to be place oin screen. User interfaces can directly manipulate the translation and zoom without further helpers. Yocto/Math just provides convenience functions for centering an image and compute a mouse to image coordinate transformation. auto image_size = vec2i { 512 , 512 }, window_size = vec2i { 1024 , 768 }; auto image_center = vec2f { 100 , 100 }; auto image_scale = float { 1 }; // get image coordinates from mouse auto ij = get_image_coords ( mouse_pos , image_center , image_scale , image_size ); // center image by setting image_center and image_scale update_imview ( image_center , image_scale , image_size , window_size , false ); // center image and for to screen by setting image_center and image_scale update_imview ( image_center , image_scale , image_size , window_size , true ); For 3D cameras, Yocto/Math supports a turntable interface, inspired by many 3D editors, with update_turntable(...) , and the camera's rays generation with camera_ray(...) . auto camera_frame = identity3x4f ; auto camera_focus = float { 10 }; // update camera position and focus update_turntable ( camera_frame , camera_focus , rotate , dolly , pan ); // turntable udpates works also for camera with explicit lookat parametrizations update_turntable ( camera_from , camera_to , camera_up , rotate , dolly , pan ); // generation of camera rays auto ray = camera_ray ( camera_frame , lens , aspect , film , image_uv );","title":"Math types"},{"location":"yocto/yocto_math/#yoctomath-math-types","text":"Yocto/Math defines the basic math primitives used in graphics, including small-sized vectors, matrices, frames, quaternions, rays, bounding boxes and their transforms. Yocto/Math is implemented in yocto_math.h .","title":"Yocto/Math: Math types"},{"location":"yocto/yocto_math/#vectors","text":"The most basic types defined in Yocto/Math are fixed-length vectors in 1 to 4 dimensions with either float or int coordinates, namely vec1f , vec2f , vec3f , vec4f , vec1i , vec2i , vec3i , vec4i . One-dimensional vectors are defined for completeness. Vectors coordinates are default-initialized to zeros. Vectors are constructed by specifying all their coordinates. For convenience, Yocto/Math defines common constants, i.e. zeroXX , to initialize zero vectors. Vector coordinates are accessed by index, e.g. v[0] , or by name, using v.x , v.y , v.z , v.w . While in graphics it is common to use the latter, we suggest to instead use the former since it better generalizes to different cases. Vectors support component-wise arithmetic, equality and assignment operators. For arithmetic operators, both vector and scalar operands are supported. Yocto/Math also overrides many common math function to work on vectors by component-wise evaluation, including trigonometric and exponentiation functions, and component-wise abs, max, min and clamp. Real vector types additionally support vector products and lengths. For 3D vectors, we also define reflection and refraction vectors following GLSL.","title":"Vectors"},{"location":"yocto/yocto_math/#matrices","text":"Yocto/Math supports 2-4 dimensional square matrices, namely mat2f , mat3f and mat4f . Matrices are stored on column-major order. Matrices are initialized to the identity matrix and constructed by passing matrix columns. Matrix columns are accessed using indexing, i.e. mat[col] . Yocto/Math defines convenience constants for common matrices, e.g. indentity3x3f , etc. Matrices support linear algebra summation and scaling operations, component-wise equality, matrix-matrix and matrix-vector products. All these operators use standard math notation. Matrices also support the computation of transpose, inverse and adjoint matrices, with transpose(a) , inverse(a) and adjoint(a) .","title":"Matrices"},{"location":"yocto/yocto_math/#frames","text":"To represent transformations, most of the library facilities prefer the use coordinate frames, aka rigid transforms, represented as frame2f and frame3f . Frames are represented in column-major order, with columns defined as the axis of the coordinate frame followed by the origin. This is equivalent to representing rigid transformations as column-major affine matrices. Use mat_to_frame(mat) and frame_to_mat(frame) to convert between these types. Frames support only multiplication operations with other frames, to chain transforms, the computation of their inverses, with inverse(f) , and the creation of frames aligned with one ot two axis, i.e. frame_fromz(o,z) and frame_fromxz(o,z,x) . For the inverse computation, the default is to assume that the frame is orthonormal to get a fast answer. This can be overridden as shown in the example. auto f1 = frame3f { x , y , z , o }; // construct a frame from axes and origin auto of = inverse ( f1 ); // assume f is orthonormal auto gf = inverse ( f1 , true ); // treat f as a generic affine matrix","title":"Frames"},{"location":"yocto/yocto_math/#quaternions","text":"Quaternions are represented as quat4f . Quaternions support is minimal and focuses on representing rotations, i.e. unit quaternions. Quaternions are initialized to a unit quaternion, that can also be set with the convenience constant identityq4f . Quaternions support addition, multiplication and scaling, together with dot(q1,q2) , length(q) and normalize(q) . For unit quaternions, Yocto/Math also defines the quaternion inverse inverse(q) and several interpolation function including linear interpolation, normalized linear interpolation and spherical interpolation, respectively with lerp(a,bt) , nlerp(a,b,t) and slerp(a,b,t) .","title":"Quaternions"},{"location":"yocto/yocto_math/#rays","text":"Yocto/Math defines rays in 2-3 dimensions as ray2f and ray3f . Rays are defined as an origin o , a direction d and minimum and maximum values for the distance along a ray, namely tmin and tmax . To compute a point in a ray, use ray_point(ray,t) . See Yocto/Geometry for ray-primitive intersection. auto ray = ray3f { origin , direction }; auto p = ray_point ( ray , 0.5 );","title":"Rays"},{"location":"yocto/yocto_math/#bounding-boxes","text":"Yocto/Math defines axies-aligned bounding boxes in 2 to 3 dimensions as bbox2f and bbox3f . Bounding boxes store the minimum and maximum coordinate values, that can be accessed with b.min and b.max . Bounding boxes are default-initialized to an invalid state that contains no points, or they are constructed by specifying the min and max values directly. To build bounds for complex primitives, bounding boxes are very initialized to empty bounds, that can be done by using the constants like invalidabXf , and then grown to encompass either points or other bounding boxes with merge(b,p) . See Yocto/Geometry for building bounding boxes for geometric primitives. auto bbox = invalidb3f ; for ( auto point : points ) bbox = merge ( bbox , point );","title":"Bounding boxes"},{"location":"yocto/yocto_math/#transforms","text":"Yocto/Math uses linear algebra vectors for holding different geometric quantities, such as points, vectors, directions and normals. For this reason, we define different functions to transform these quantities, namely transform_point(f,p) to transform points, transform_vector(f,v) to transform vectors, transform_direction(f,d) to transform directions intended as normalized vectors, and transform_normal(f,n) to transform normals. Yocto/Math provides overrides to transforms for both frames and matrices, but the preferred transform representation in Yocto/GL are frames . When transforming normals by matrices, the inverse transform is computed on the fly for correctness. When transforming normals by frames, frames are assumed to be orthonormal and used as is, unless specifically requested as for inverses. For convenience, Yocto/Math provides several functions to construct transform frames and matrices. Translation, rotation and scaling frames are created with translation_frame(t) , rotation_frame(r) and scaling_frame(s) . Rotation frames can be derived from axis-angle, quaternion and matrix representations. To define camera frames, one can use lookat_frame(from,to,up) . auto f = tranlation_frame ({ 1 , 0 , 0 }) * rotation_frame ({ 0 , 1 , 0 }, pi / 2 ); // transform auto lp = vec3f { 1 , 2 , 3 }, lv = vec3f { 0 , 2 , 3 }; // point and vector in local coords auto wp = transform_point ( f , lp ); // point in world coords auto wv = transform_vector ( f , lv ); // vector in world coords For use in GPU programming, Yocto/Math also defines various projection matrices in the style of GLU/GLM, namely frustum_mat(...) , ortho_mat(...) , ortho2d_mat(...) , and perspective_mat(...) .","title":"Transforms"},{"location":"yocto/yocto_math/#user-interface-transforms","text":"Yocto/Math provides a few utilities for writing user interfaces for 2D images and 3D environments. For images, we assume that image are scaled and than translated to be place oin screen. User interfaces can directly manipulate the translation and zoom without further helpers. Yocto/Math just provides convenience functions for centering an image and compute a mouse to image coordinate transformation. auto image_size = vec2i { 512 , 512 }, window_size = vec2i { 1024 , 768 }; auto image_center = vec2f { 100 , 100 }; auto image_scale = float { 1 }; // get image coordinates from mouse auto ij = get_image_coords ( mouse_pos , image_center , image_scale , image_size ); // center image by setting image_center and image_scale update_imview ( image_center , image_scale , image_size , window_size , false ); // center image and for to screen by setting image_center and image_scale update_imview ( image_center , image_scale , image_size , window_size , true ); For 3D cameras, Yocto/Math supports a turntable interface, inspired by many 3D editors, with update_turntable(...) , and the camera's rays generation with camera_ray(...) . auto camera_frame = identity3x4f ; auto camera_focus = float { 10 }; // update camera position and focus update_turntable ( camera_frame , camera_focus , rotate , dolly , pan ); // turntable udpates works also for camera with explicit lookat parametrizations update_turntable ( camera_from , camera_to , camera_up , rotate , dolly , pan ); // generation of camera rays auto ray = camera_ray ( camera_frame , lens , aspect , film , image_uv );","title":"User-Interface Transforms"},{"location":"yocto/yocto_mesh/","text":"Yocto/Mesh: Mesh processing Yocto/Mesh is a collection of computational geometry functions on triangle meshes. Yocto/Mesh is implemented in yocto_mesh.h and yocto_mesh.cpp . This library is experimental and will be documented appropriately when the code reaches stability.","title":"Mesh processing"},{"location":"yocto/yocto_mesh/#yoctomesh-mesh-processing","text":"Yocto/Mesh is a collection of computational geometry functions on triangle meshes. Yocto/Mesh is implemented in yocto_mesh.h and yocto_mesh.cpp . This library is experimental and will be documented appropriately when the code reaches stability.","title":"Yocto/Mesh: Mesh processing"},{"location":"yocto/yocto_modelio/","text":"Yocto/ModelIO: Serialization for Obj, Ply and Pbrt models Yocto/ModelIO is a collection of utilities for loading and saving scenes and meshes in Ply, Obj and Pbrt formats. Yocto/ModelIO is implemented in yocto_modelio.h and yocto_modelio.cpp . Ply models The Ply file format is a generic file format used to serialize meshes and point clouds. To use this library is helpful to understand the basic of the Ply file format for example from the Ply Wikipedia page . Yocto/ModelIO represents Ply data with the ply_model struct. The internal representation matches the structure of a Ply file and can be accessed directly if desired. The Ply model is defined as an array of Ply elements, which in turn are defined as arrays of Ply properties. Ply properties can contain most C data types. All elements and properties are owned by the main ply_model . Yocto/ModelIO provides several functions to read and write Ply data whose use is preferred over direct data access. Use load_ply(filename, ply, error) to load Ply files and save_ply(filename, ply, error) to save them. Both loading and saving take a filename, a pointer to a Ply model, and returns whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto ply = new ply_model {}; // ply model buffer auto error = string {}; // error buffer if ( ! load_ply ( filename , ply , error )) // load ply print_error ( error ); // check and print error if ( ! save_ply ( filename , ply , error )) // save ply print_error ( error ); // check and print error Ply reading Yocto/ModelIO defines several functions to make it easy to extract data from Ply files. Since Ply properties cane be stored with many different C types, the convenience functions convert the various underlying representations to the requested one. Use has_property(ply,element,property) to check whether the model has a property named property in an element named element . Use get_property(ply,element,property) to get that property. Use get_value(ply, element, property, values) to get the property values and stored them in the array values . The function returns whether or not the property was present. Since Ply properties are often stored together, e.g. xyz coordinates, Yocto/ModelIO supports queries that take arrays of properties and returns values packed in vecXf . Use get_values(ply, element, properties, values) to read arrays of properties. For list properties, Yocto/ModelIO supports reading properties as arrays of arrays of dynamic size with get_lists(ply,element,property,lists) . A faster, but harder to use, method is to get lists sizes and values as separate arrays, where list values are packed together to avoid small memory allocations. Use get_list_sizes(ply, element, property, sizes) for sizes and get_list_values(ply, element, property, values) for values. auto ply = new ply_model {}; // ply model buffer auto error = string {}; // error buffer load_ply ( filename , ply , error ); // load ply auto radius = vector < float > {}; // property buffer if ( ! get_value ( ply , \"vertex\" , \"radius\" , radius )) // read property print_error ( \"missing radius\" ); // error if missing auto positions = vector < vec3f > {}; // properties buffer if ( ! get_values ( ply , \"vertex\" , { \"x\" , \"y\" , \"z\" }, positions )) // read properties print_error ( \"missing positions\" ); // error if missing auto faces = vector < vector < int >> {}; // list property buffer if ( ! get_lists ( ply , \"face\" , \"indices\" , faces )) // read lists print_error ( \"missing faces\" ); // error if missing auto faces_sizes = vector < int > {}; // list property sizes auto faces_values = vector < int > {}; // list property values if ( ! get_list_sizes ( ply , \"face\" , \"indices\" , faces_sizes )) // read lists sizes print_error ( \"missing faces\" ); // error if missing if ( ! get_list_values ( ply , \"face\" , \"indices\" , faces_values )) // read lists values print_error ( \"missing faces\" ); // error if missing Yocto/Shape defines convenience functions to read the most used properties of meshes, using standard element and property names. For vertex properties, use get_positions(ply, positions) , get_normals(ply, normals) , get_texcoords(ply, texcoords, flipv) , get_colors(ply, colors) , and get_radius(ply, radius) to read positions, normals, texcoords, colors and radius if present. Texture coordinates can be optionally flipped vertically. For shape elements, use get_points(ply, points) , get_lines(ply, lines) , get_triangles(ply, triangles) , and get_quads(ply, quads) , to read points, lines, triangles and quads. Note that since Ply support arbitrary polygons and polylines, these functions tesselate the Ply polygons into the desired element type, for now using a simple fan-like algorithm that works only for convex elements. Use has_quads(ply) to check whether the Ply data has quads. auto ply = new ply_model {}; // ply model buffer auto error = string {}; // error buffer load_ply ( filename , ply , error ); // load ply auto positions = vector < vec3f > {}; // vertex properties buffers auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto colors = vector < vec3f > {}; auto radius = vector < float > {}; get_positions ( ply , positions ); // read vertex props. get_normals ( ply , normals ); get_texcoords ( ply , texcoords , false ); // last params, flips y is desired get_colors ( ply , colors ); get_radius ( ply , radius ); auto points = vector < vec4i > {}; // shape elements buffers auto lines = vector < vec4i > {}; auto triangles = vector < vec4i > {}; auto quads = vector < vec4i > {}; get_points ( ply , points ); get_lines ( ply , lines ); if ( has_quads ( ply )) get_quads ( ply , quads ); else get_triangles ( ply , triangles ); Ply writing Yocto/ModelIO defines several functions to make it easy to fill Ply data to save to file. Since Ply properties cane be stored with many different C types, the convenience functions maintain the same data type of the data passed in without performing any conversion. Use add_value(ply, element, property, values) to add the property values stored them in the array values . The function returns whether or not the property was successfully added. Since Ply properties are often stored together, e.g. xyz coordinates, Yocto/ModelIO supports adding arrays of properties whose values are packed in vecXf . Use add_values(ply, element, properties, values) to add arrays of properties. For list properties, Yocto/ModelIO supports adding list properties as arrays of arrays of dynamic size with add_lists(ply,element,property,lists) . A faster, but harder to use, method is to add lists sizes and values as separate arrays, where list values are packed together to avoid small memory allocations. Use add_lists(ply, element, property, sizes, values) . Finally, Yocto/ModelIO supports adding lists of fixed lengths, where the parameters are packed into vecXi , with add_lists(ply,element,property,values) . auto ply = new ply_model {}; // ply model buffer auto radius = vector < float > {...}; // property buffer if ( ! add_value ( ply , \"vertex\" , \"radius\" , radius )) // add property print_error ( \"error in radius\" ); // error if missing auto positions = vector < vec3f > {...}; // properties buffer if ( ! add_values ( ply , \"vertex\" , { \"x\" , \"y\" , \"z\" }, positions )) // add properties print_error ( \"missing positions\" ); // error if missing auto faces = vector < vector < int >> {...}; // list property buffer if ( ! add_lists ( ply , \"face\" , \"indices\" , faces )) // add lists print_error ( \"missing faces\" ); // error if missing auto faces_sizes = vector < int > {...}; // list property sizes auto faces_values = vector < int > {...}; // list property values if ( ! add_lists ( ply , \"face\" , \"indices\" , faces_sizes , face_values )) // add lists print_error ( \"missing faces\" ); // error if missing auto triangles = vector < vec3i > {...}; // fixed length list property if ( ! add_lists ( ply , \"face\" , \"indices\" , triangles )) // add lists print_error ( \"missing faces\" ); // error if missing auto error = string {}; // error buffer save_ply ( filename , ply , error ); // save ply Yocto/ModelIO defines convenience functions to add the most used properties of meshes, using standard element and property names. For vertex properties, use add_positions(ply, positions) , add_normals(ply, normals) , add_texcoords(ply, texcoords, flipv) , add_colors(ply, colors) , and add_radius(ply, radius) to read positions, normals, texcoords, colors and radius if present. Texture coordinates can be optionally flipped vertically. For shape elements, use add_points(ply, points) , add_lines(ply, lines) , add_triangles(ply, triangles) , and add_quads(ply, quads) , to add points, lines, triangles and quads. Use add_faces(ply, faces) to add arbitrary polygonal faces. auto ply = new ply_model {}; // ply model buffer auto positions = vector < vec3f > {...}; // vertex properties buffers auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto colors = vector < vec3f > {...}; auto radius = vector < float > {...}; add_positions ( ply , positions ); // add vertex props. add_normals ( ply , normals ); add_texcoords ( ply , texcoords , false ); // last params, flips y is desired add_colors ( ply , colors ); add_radius ( ply , radius ); auto points = vector < vec4i > {...}; // shape elements buffers auto lines = vector < vec4i > {...}; auto triangles = vector < vec4i > {...}; auto quads = vector < vec4i > {...}; add_points ( ply , points ); // add shape elements add_lines ( ply , lines ); add_triangles ( ply , triangles ); add_quads ( ply , quads ); auto error = string {}; // error buffer save_ply ( filename , ply , error ); // save ply Obj models The Obj file format is a file format used to serialize meshes and materials. To use this library is helpful to understand the basic of the Obj file format for example from the Obj Wikipedia page . Obj files come in pairs, .obj for shapes and .mtl for materials. Yocto/ModelIO represents Obj data with the obj_model struct. Obj models are defined as collections of shapes and materials. Obj shapes use a face-varying representation that has vertex positions, normals and texture coordinates, with their their own topology. In a shape, each face is tagged with a material used for that face. Yocto/ModelIO provides direct access to these tagged shapes by inspecting the obj_shape properties. In Yocto/Obj, materials are represented by the obj_material struct. Each material is a collection of values and textures that specify the material lobes, like emission, diffuse, specular, reflection, etc. Each value has a corresponding texture stored by saving its filename and lookup properties in obj_texture_info . The meaning of these parameters often depend on the application since Obj was used in many different contexts by reinterpreting the material values. Yocto/ModelIO defines three extensions to the Obj file format. Materials have additional parameters that specify a PBR parametrization similar to glTF, which is common used in most engines today. Yocto/ModelIO adds another file, namely .objx , that stores cameras and environment maps, respectively as obj_camera and obj_environment . This addition makes the extended Obj format capable of storing full scenes. The Obj model is defined as an array of objects of the types defined above. Obj objects are pointers owned by the main obj_model . Objects properties can be read and written directly from the model data, and are documented in the header file for now. For shapes, Yocto/ModelIO provides several functions to read and write Obj shapes, with a simpler interface than accessing data directly. auto obj = new obj_model {...}; // obj model buffer for ( auto shape : obj -> shapes ) // access shapes print_info ( shape -> name ); // access shape properties for ( auto material : obj -> material ) // access materials print_info ( material -> diffuse ); // access material properties for ( auto material : obj -> material ) // access materials print_info ( material -> diffuse_tex ); // access material textures for ( auto camera : obj -> cameras ) // access cameras [extension] print_info ( camera -> frame ); // access camera properties for ( auto environment : obj -> environments ) // access environments [extension] print_info ( environment -> emission ); // access environment properties Use load_obj(filename, obj, error) to load Obj files and save_obj(filename, obj, error) to save them. Both loading and saving take a filename, a pointer to a Obj model, and returns whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto obj = new obj_model {}; // obj model buffer auto error = string {}; // error buffer if ( ! load_obj ( filename , obj , error )) // load obj print_error ( error ); // check and print error if ( ! save_obj ( filename , obj , error )) // save obj print_error ( error ); // check and print error Obj reading Obj is a face-varying format and that geometry representation is maintained in obj_shape . Yocto/ModelIO provides easier accessed to Obj shape data, both as indexed meshes and as face-varying meshes. To get data as a standard indexed meshes, use get_triangles(obj,triangles,<vertex>,<materials>) , get_quads(obj,quads,<vertex>,<materials>) , get_lines(obj,lines,<vertex>,<materials>) , and get_points(obj,points,<vertex>,<materials>) , to read triangles, quads, lines and points respectively. In these functions, vertex data is comprised of positions, normals and texture coordinated stored as separate arrays. Note that in these functions, vertices may end up being duplicated when going from the face-varying representation to an indexed mesh. Material data is comprised of a list of materials used in the shape and the per-element indices to the material arrays. Since Obj stored faces as polygons, these functions are performing a tesselation when necessary that for now work only for convex shapes. You can check whether a shape contains quads with has_quads(shape) . In some cases, it may be desireable to extract the shape elements corresponding to a single material, for example for use in renderers that support a single shader per shape. Yocto/ModelIO defines convenience functions for this case, that are overrides of the previous get_<element>(...) functions, but differ in that they take a material is as input, instead of returning materials tags. auto obj = new obj_model {}; // obj model buffer auto error = string {}; // error buffer load_obj ( filename , obj , error ); // load obj auto shape = obj -> shapes . front (); // get shape auto triangles = vector < vec3i > {}; // element data auto quads = vector < vec4i > {}; auto positions = vector < vec3f > {}; // vertex properties auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto materials = vector < onj_material *> {}; // materials auto ematerials = vector < int > {}; // per-face material ids if ( has_quads ( shape )) { get_triangles ( shape , triangles , // read as triangles positions , normals , texcoords , materials , ematerials , false ); // flip texcoords if desired else get_quads ( shape , quads , // read as quads positions , normals , texcoords , materials , ematerials , false ); // flip texcoords if desired auto material_id = 0 ; // material kd to extract to if ( has_quads ( shape )) { get_triangles ( shape , material_id , // read as triangles for material id triangles , positions , normals , texcoords , false ); // flip texcoords if desired else get_quads ( shape , material_id , // read as quads for material 0 quads , positions , normals , texcoords , false ); // flip texcoords if desired Yocto/ModelIO supports also reading Obj shapes as face-varying quads with get_fvquads(...) . auto obj = new obj_model {}; // obj model buffer auto error = string {}; // error buffer load_obj ( filename , obj , error ); // load obj auto shape = obj -> shapes . front (); // get shape auto quadspos = vector < vec4i > {}; // face-varying element data auto quadsnorm = vector < vec4i > {}; auto quadsuv = vector < vec4i > {}; auto positions = vector < vec3f > {}; // vertex properties auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto materials = vector < onj_material *> {}; // materials auto ematerials = vector < int > {}; // per-face material ids get_fvquads ( shape , // read as face-varying quads quadspos , quadsnorm , quadsuv , positions , normals , texcoords , materials , ematerials , false ); // flip texcoords if desired Obj writing To save an Obj, create a scene and add objects to it using add_camera(obj) , add_material(obj) , add_environment(obj) and add_shape(obj) for camera, materials, environments and shapes respectively. For all objects, set the objects' properties directly. For shapes, Yocto/ModelIO defines convenience functions that take either indexed mesh or face-varying meshes as input and create the appropriate Obj shape elements. Use set_triangles(shape,triangles,<vertex>,<materials>) , set_quads(shape,quads,<vertex>,<materials>) , set_lines(shape,lines,<vertex>,<materials>) , set_points(shape,points,<vertex>,<materials>) to set shapes as an indexed mesh of triangles, quads, lines or points respectively. In these functions, vertex data is comprised of positions, normals and texture coordinated stored as separate arrays. Material data is only represented as tags and can be left empty if only one material is used. To set material points use set_materials(shape,materials) . auto obj = new obj_model {}; // obj model buffer auto camera = add_camera ( obj ); // add camera camera -> name = \"camera\" ; // set camera name camera -> frame = identity3x4f ; // set camera properties auto environment = add_environment ( obj ); // add environment environment -> name = \"environment\" ; // set environment name environment -> emission = { 1 , 1 , 1 }; // set environment properties auto material = add_material ( obj ); // add material material -> name = \"camera\" ; // set material name material -> diffuse = { 1 , 0 , 0 }; // set material properties auto triangles = vector < vec3i > {...}; // element data auto positions = vector < vec3f > {...}; // vertex properties auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto shape = add_shape ( obj ); // add shape shape -> name = \"shape\" ; // set shape name set_triangles ( shape , triangles , // set shape geometry positions , normals , texcoords ); set_materials ( shape , { material }); // set shape material; auto error = string {}; // error buffer save_obj ( filename , obj , error ); // save obj Yocto/ModelIO supports also writing of face-varying shapes with set_fvquads(...) with an API similar to above. auto obj = new obj_model {}; // obj model buffer auto quadspos = vector < vec4i > {...}; // face-varying element data auto quadsnorm = vector < vec4i > {...}; auto quadsuv = vector < vec4i > {...}; auto positions = vector < vec3f > {...}; // vertex properties auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > ....{}; auto shape = add_shape ( obj ); // add shape shape -> name = \"shape\" ; // set shape name set_fvquads ( shape , quadspos , // set shape geometry quadsnorm , quadstexcoord , positions , normals , texcoords ); set_materials ( shape , { material }); // set shape material; auto error = string {}; // error buffer save_obj ( filename , obj , error ); // save obj Pbrt models The Pbrt file format is a scene representation suitable for realistic rendering and implemented by the Pbrt renderer. To use this library is helpful to understand the basic of the Pbrt file format for example from the Pbrt format documentatioon . The Pbrt file format is an extensible file format for a plugin-based system. Representing the format directly allows for best fidelity but pushed the burden of interpreting standard plugins to the use. Yocto/ModelIO takes a different approach and translates camera, shapes, materials, textures and lights from Pbrt plugins to a common representation that presents users a simpler and more uniform scene representation. Yocto/ModelIO represents Pbrt data with the pbrt_model struct. Pbrt models are defined as collections of cameras, instanced shapes, materials, texture and environments. Pbrt cameras are translate into a thin-len approximations. Pbrt materials are translated to a material representation similar to the Disney BSDF. Pbrt textures are either interpreted ion the fly or defined by a image file. Pbrt area lights are translated to either emissive materials and environments. The Pbrt model is defined as an array of objects of the types defined above. Pbrt objects are pointers owned by the main pbrt_model . Objects properties can be read and written directly from the model data, and are documented in the header file for now. Yocto/ModelIO does not currently provide functions to read and write Pbrt shapes with a simpler interface than accessing data directly. In general, Pbrt support is still experimental even if the library can parse most Pbrt files. The objects properties documentations are for now stored in the header file. auto pbrt = new pbrt_model {...}; // obj model buffer for ( auto shape : pbrt -> shapes ) // access shapes print_info ( shape -> name ); // access shape properties for ( auto material : pbrt -> material ) // access materials print_info ( material -> diffuse ); // access material properties for ( auto material : pbrt -> material ) // access materials print_info ( material -> color_tex ); // access material textures for ( auto camera : pbrt -> cameras ) // access cameras [extension] print_info ( camera -> frame ); // access camera properties for ( auto environment : pbrt -> environments ) // access environments [extension] print_info ( environment -> emission ); // access environment properties Use load_pbrt(filename, pbrt, error) to load Pbrt files and save_pbrt(filename, pbrt, error) to save them. Both loading and saving take a filename, a pointer to a Pbrt model, and returns whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto pbrt = new pbrt_model {}; // obj model buffer auto error = string {}; // error buffer if ( ! load_pbrt ( filename , pbrt , error )) // load obj print_error ( error ); // check and print error if ( ! save_pbrt ( filename , pbrt , error )) // save obj print_error ( error ); // check and print error","title":"Model serialization"},{"location":"yocto/yocto_modelio/#yoctomodelio-serialization-for-obj-ply-and-pbrt-models","text":"Yocto/ModelIO is a collection of utilities for loading and saving scenes and meshes in Ply, Obj and Pbrt formats. Yocto/ModelIO is implemented in yocto_modelio.h and yocto_modelio.cpp .","title":"Yocto/ModelIO: Serialization for Obj, Ply and Pbrt models"},{"location":"yocto/yocto_modelio/#ply-models","text":"The Ply file format is a generic file format used to serialize meshes and point clouds. To use this library is helpful to understand the basic of the Ply file format for example from the Ply Wikipedia page . Yocto/ModelIO represents Ply data with the ply_model struct. The internal representation matches the structure of a Ply file and can be accessed directly if desired. The Ply model is defined as an array of Ply elements, which in turn are defined as arrays of Ply properties. Ply properties can contain most C data types. All elements and properties are owned by the main ply_model . Yocto/ModelIO provides several functions to read and write Ply data whose use is preferred over direct data access. Use load_ply(filename, ply, error) to load Ply files and save_ply(filename, ply, error) to save them. Both loading and saving take a filename, a pointer to a Ply model, and returns whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto ply = new ply_model {}; // ply model buffer auto error = string {}; // error buffer if ( ! load_ply ( filename , ply , error )) // load ply print_error ( error ); // check and print error if ( ! save_ply ( filename , ply , error )) // save ply print_error ( error ); // check and print error","title":"Ply models"},{"location":"yocto/yocto_modelio/#ply-reading","text":"Yocto/ModelIO defines several functions to make it easy to extract data from Ply files. Since Ply properties cane be stored with many different C types, the convenience functions convert the various underlying representations to the requested one. Use has_property(ply,element,property) to check whether the model has a property named property in an element named element . Use get_property(ply,element,property) to get that property. Use get_value(ply, element, property, values) to get the property values and stored them in the array values . The function returns whether or not the property was present. Since Ply properties are often stored together, e.g. xyz coordinates, Yocto/ModelIO supports queries that take arrays of properties and returns values packed in vecXf . Use get_values(ply, element, properties, values) to read arrays of properties. For list properties, Yocto/ModelIO supports reading properties as arrays of arrays of dynamic size with get_lists(ply,element,property,lists) . A faster, but harder to use, method is to get lists sizes and values as separate arrays, where list values are packed together to avoid small memory allocations. Use get_list_sizes(ply, element, property, sizes) for sizes and get_list_values(ply, element, property, values) for values. auto ply = new ply_model {}; // ply model buffer auto error = string {}; // error buffer load_ply ( filename , ply , error ); // load ply auto radius = vector < float > {}; // property buffer if ( ! get_value ( ply , \"vertex\" , \"radius\" , radius )) // read property print_error ( \"missing radius\" ); // error if missing auto positions = vector < vec3f > {}; // properties buffer if ( ! get_values ( ply , \"vertex\" , { \"x\" , \"y\" , \"z\" }, positions )) // read properties print_error ( \"missing positions\" ); // error if missing auto faces = vector < vector < int >> {}; // list property buffer if ( ! get_lists ( ply , \"face\" , \"indices\" , faces )) // read lists print_error ( \"missing faces\" ); // error if missing auto faces_sizes = vector < int > {}; // list property sizes auto faces_values = vector < int > {}; // list property values if ( ! get_list_sizes ( ply , \"face\" , \"indices\" , faces_sizes )) // read lists sizes print_error ( \"missing faces\" ); // error if missing if ( ! get_list_values ( ply , \"face\" , \"indices\" , faces_values )) // read lists values print_error ( \"missing faces\" ); // error if missing Yocto/Shape defines convenience functions to read the most used properties of meshes, using standard element and property names. For vertex properties, use get_positions(ply, positions) , get_normals(ply, normals) , get_texcoords(ply, texcoords, flipv) , get_colors(ply, colors) , and get_radius(ply, radius) to read positions, normals, texcoords, colors and radius if present. Texture coordinates can be optionally flipped vertically. For shape elements, use get_points(ply, points) , get_lines(ply, lines) , get_triangles(ply, triangles) , and get_quads(ply, quads) , to read points, lines, triangles and quads. Note that since Ply support arbitrary polygons and polylines, these functions tesselate the Ply polygons into the desired element type, for now using a simple fan-like algorithm that works only for convex elements. Use has_quads(ply) to check whether the Ply data has quads. auto ply = new ply_model {}; // ply model buffer auto error = string {}; // error buffer load_ply ( filename , ply , error ); // load ply auto positions = vector < vec3f > {}; // vertex properties buffers auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto colors = vector < vec3f > {}; auto radius = vector < float > {}; get_positions ( ply , positions ); // read vertex props. get_normals ( ply , normals ); get_texcoords ( ply , texcoords , false ); // last params, flips y is desired get_colors ( ply , colors ); get_radius ( ply , radius ); auto points = vector < vec4i > {}; // shape elements buffers auto lines = vector < vec4i > {}; auto triangles = vector < vec4i > {}; auto quads = vector < vec4i > {}; get_points ( ply , points ); get_lines ( ply , lines ); if ( has_quads ( ply )) get_quads ( ply , quads ); else get_triangles ( ply , triangles );","title":"Ply reading"},{"location":"yocto/yocto_modelio/#ply-writing","text":"Yocto/ModelIO defines several functions to make it easy to fill Ply data to save to file. Since Ply properties cane be stored with many different C types, the convenience functions maintain the same data type of the data passed in without performing any conversion. Use add_value(ply, element, property, values) to add the property values stored them in the array values . The function returns whether or not the property was successfully added. Since Ply properties are often stored together, e.g. xyz coordinates, Yocto/ModelIO supports adding arrays of properties whose values are packed in vecXf . Use add_values(ply, element, properties, values) to add arrays of properties. For list properties, Yocto/ModelIO supports adding list properties as arrays of arrays of dynamic size with add_lists(ply,element,property,lists) . A faster, but harder to use, method is to add lists sizes and values as separate arrays, where list values are packed together to avoid small memory allocations. Use add_lists(ply, element, property, sizes, values) . Finally, Yocto/ModelIO supports adding lists of fixed lengths, where the parameters are packed into vecXi , with add_lists(ply,element,property,values) . auto ply = new ply_model {}; // ply model buffer auto radius = vector < float > {...}; // property buffer if ( ! add_value ( ply , \"vertex\" , \"radius\" , radius )) // add property print_error ( \"error in radius\" ); // error if missing auto positions = vector < vec3f > {...}; // properties buffer if ( ! add_values ( ply , \"vertex\" , { \"x\" , \"y\" , \"z\" }, positions )) // add properties print_error ( \"missing positions\" ); // error if missing auto faces = vector < vector < int >> {...}; // list property buffer if ( ! add_lists ( ply , \"face\" , \"indices\" , faces )) // add lists print_error ( \"missing faces\" ); // error if missing auto faces_sizes = vector < int > {...}; // list property sizes auto faces_values = vector < int > {...}; // list property values if ( ! add_lists ( ply , \"face\" , \"indices\" , faces_sizes , face_values )) // add lists print_error ( \"missing faces\" ); // error if missing auto triangles = vector < vec3i > {...}; // fixed length list property if ( ! add_lists ( ply , \"face\" , \"indices\" , triangles )) // add lists print_error ( \"missing faces\" ); // error if missing auto error = string {}; // error buffer save_ply ( filename , ply , error ); // save ply Yocto/ModelIO defines convenience functions to add the most used properties of meshes, using standard element and property names. For vertex properties, use add_positions(ply, positions) , add_normals(ply, normals) , add_texcoords(ply, texcoords, flipv) , add_colors(ply, colors) , and add_radius(ply, radius) to read positions, normals, texcoords, colors and radius if present. Texture coordinates can be optionally flipped vertically. For shape elements, use add_points(ply, points) , add_lines(ply, lines) , add_triangles(ply, triangles) , and add_quads(ply, quads) , to add points, lines, triangles and quads. Use add_faces(ply, faces) to add arbitrary polygonal faces. auto ply = new ply_model {}; // ply model buffer auto positions = vector < vec3f > {...}; // vertex properties buffers auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto colors = vector < vec3f > {...}; auto radius = vector < float > {...}; add_positions ( ply , positions ); // add vertex props. add_normals ( ply , normals ); add_texcoords ( ply , texcoords , false ); // last params, flips y is desired add_colors ( ply , colors ); add_radius ( ply , radius ); auto points = vector < vec4i > {...}; // shape elements buffers auto lines = vector < vec4i > {...}; auto triangles = vector < vec4i > {...}; auto quads = vector < vec4i > {...}; add_points ( ply , points ); // add shape elements add_lines ( ply , lines ); add_triangles ( ply , triangles ); add_quads ( ply , quads ); auto error = string {}; // error buffer save_ply ( filename , ply , error ); // save ply","title":"Ply writing"},{"location":"yocto/yocto_modelio/#obj-models","text":"The Obj file format is a file format used to serialize meshes and materials. To use this library is helpful to understand the basic of the Obj file format for example from the Obj Wikipedia page . Obj files come in pairs, .obj for shapes and .mtl for materials. Yocto/ModelIO represents Obj data with the obj_model struct. Obj models are defined as collections of shapes and materials. Obj shapes use a face-varying representation that has vertex positions, normals and texture coordinates, with their their own topology. In a shape, each face is tagged with a material used for that face. Yocto/ModelIO provides direct access to these tagged shapes by inspecting the obj_shape properties. In Yocto/Obj, materials are represented by the obj_material struct. Each material is a collection of values and textures that specify the material lobes, like emission, diffuse, specular, reflection, etc. Each value has a corresponding texture stored by saving its filename and lookup properties in obj_texture_info . The meaning of these parameters often depend on the application since Obj was used in many different contexts by reinterpreting the material values. Yocto/ModelIO defines three extensions to the Obj file format. Materials have additional parameters that specify a PBR parametrization similar to glTF, which is common used in most engines today. Yocto/ModelIO adds another file, namely .objx , that stores cameras and environment maps, respectively as obj_camera and obj_environment . This addition makes the extended Obj format capable of storing full scenes. The Obj model is defined as an array of objects of the types defined above. Obj objects are pointers owned by the main obj_model . Objects properties can be read and written directly from the model data, and are documented in the header file for now. For shapes, Yocto/ModelIO provides several functions to read and write Obj shapes, with a simpler interface than accessing data directly. auto obj = new obj_model {...}; // obj model buffer for ( auto shape : obj -> shapes ) // access shapes print_info ( shape -> name ); // access shape properties for ( auto material : obj -> material ) // access materials print_info ( material -> diffuse ); // access material properties for ( auto material : obj -> material ) // access materials print_info ( material -> diffuse_tex ); // access material textures for ( auto camera : obj -> cameras ) // access cameras [extension] print_info ( camera -> frame ); // access camera properties for ( auto environment : obj -> environments ) // access environments [extension] print_info ( environment -> emission ); // access environment properties Use load_obj(filename, obj, error) to load Obj files and save_obj(filename, obj, error) to save them. Both loading and saving take a filename, a pointer to a Obj model, and returns whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto obj = new obj_model {}; // obj model buffer auto error = string {}; // error buffer if ( ! load_obj ( filename , obj , error )) // load obj print_error ( error ); // check and print error if ( ! save_obj ( filename , obj , error )) // save obj print_error ( error ); // check and print error","title":"Obj models"},{"location":"yocto/yocto_modelio/#obj-reading","text":"Obj is a face-varying format and that geometry representation is maintained in obj_shape . Yocto/ModelIO provides easier accessed to Obj shape data, both as indexed meshes and as face-varying meshes. To get data as a standard indexed meshes, use get_triangles(obj,triangles,<vertex>,<materials>) , get_quads(obj,quads,<vertex>,<materials>) , get_lines(obj,lines,<vertex>,<materials>) , and get_points(obj,points,<vertex>,<materials>) , to read triangles, quads, lines and points respectively. In these functions, vertex data is comprised of positions, normals and texture coordinated stored as separate arrays. Note that in these functions, vertices may end up being duplicated when going from the face-varying representation to an indexed mesh. Material data is comprised of a list of materials used in the shape and the per-element indices to the material arrays. Since Obj stored faces as polygons, these functions are performing a tesselation when necessary that for now work only for convex shapes. You can check whether a shape contains quads with has_quads(shape) . In some cases, it may be desireable to extract the shape elements corresponding to a single material, for example for use in renderers that support a single shader per shape. Yocto/ModelIO defines convenience functions for this case, that are overrides of the previous get_<element>(...) functions, but differ in that they take a material is as input, instead of returning materials tags. auto obj = new obj_model {}; // obj model buffer auto error = string {}; // error buffer load_obj ( filename , obj , error ); // load obj auto shape = obj -> shapes . front (); // get shape auto triangles = vector < vec3i > {}; // element data auto quads = vector < vec4i > {}; auto positions = vector < vec3f > {}; // vertex properties auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto materials = vector < onj_material *> {}; // materials auto ematerials = vector < int > {}; // per-face material ids if ( has_quads ( shape )) { get_triangles ( shape , triangles , // read as triangles positions , normals , texcoords , materials , ematerials , false ); // flip texcoords if desired else get_quads ( shape , quads , // read as quads positions , normals , texcoords , materials , ematerials , false ); // flip texcoords if desired auto material_id = 0 ; // material kd to extract to if ( has_quads ( shape )) { get_triangles ( shape , material_id , // read as triangles for material id triangles , positions , normals , texcoords , false ); // flip texcoords if desired else get_quads ( shape , material_id , // read as quads for material 0 quads , positions , normals , texcoords , false ); // flip texcoords if desired Yocto/ModelIO supports also reading Obj shapes as face-varying quads with get_fvquads(...) . auto obj = new obj_model {}; // obj model buffer auto error = string {}; // error buffer load_obj ( filename , obj , error ); // load obj auto shape = obj -> shapes . front (); // get shape auto quadspos = vector < vec4i > {}; // face-varying element data auto quadsnorm = vector < vec4i > {}; auto quadsuv = vector < vec4i > {}; auto positions = vector < vec3f > {}; // vertex properties auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto materials = vector < onj_material *> {}; // materials auto ematerials = vector < int > {}; // per-face material ids get_fvquads ( shape , // read as face-varying quads quadspos , quadsnorm , quadsuv , positions , normals , texcoords , materials , ematerials , false ); // flip texcoords if desired","title":"Obj reading"},{"location":"yocto/yocto_modelio/#obj-writing","text":"To save an Obj, create a scene and add objects to it using add_camera(obj) , add_material(obj) , add_environment(obj) and add_shape(obj) for camera, materials, environments and shapes respectively. For all objects, set the objects' properties directly. For shapes, Yocto/ModelIO defines convenience functions that take either indexed mesh or face-varying meshes as input and create the appropriate Obj shape elements. Use set_triangles(shape,triangles,<vertex>,<materials>) , set_quads(shape,quads,<vertex>,<materials>) , set_lines(shape,lines,<vertex>,<materials>) , set_points(shape,points,<vertex>,<materials>) to set shapes as an indexed mesh of triangles, quads, lines or points respectively. In these functions, vertex data is comprised of positions, normals and texture coordinated stored as separate arrays. Material data is only represented as tags and can be left empty if only one material is used. To set material points use set_materials(shape,materials) . auto obj = new obj_model {}; // obj model buffer auto camera = add_camera ( obj ); // add camera camera -> name = \"camera\" ; // set camera name camera -> frame = identity3x4f ; // set camera properties auto environment = add_environment ( obj ); // add environment environment -> name = \"environment\" ; // set environment name environment -> emission = { 1 , 1 , 1 }; // set environment properties auto material = add_material ( obj ); // add material material -> name = \"camera\" ; // set material name material -> diffuse = { 1 , 0 , 0 }; // set material properties auto triangles = vector < vec3i > {...}; // element data auto positions = vector < vec3f > {...}; // vertex properties auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto shape = add_shape ( obj ); // add shape shape -> name = \"shape\" ; // set shape name set_triangles ( shape , triangles , // set shape geometry positions , normals , texcoords ); set_materials ( shape , { material }); // set shape material; auto error = string {}; // error buffer save_obj ( filename , obj , error ); // save obj Yocto/ModelIO supports also writing of face-varying shapes with set_fvquads(...) with an API similar to above. auto obj = new obj_model {}; // obj model buffer auto quadspos = vector < vec4i > {...}; // face-varying element data auto quadsnorm = vector < vec4i > {...}; auto quadsuv = vector < vec4i > {...}; auto positions = vector < vec3f > {...}; // vertex properties auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > ....{}; auto shape = add_shape ( obj ); // add shape shape -> name = \"shape\" ; // set shape name set_fvquads ( shape , quadspos , // set shape geometry quadsnorm , quadstexcoord , positions , normals , texcoords ); set_materials ( shape , { material }); // set shape material; auto error = string {}; // error buffer save_obj ( filename , obj , error ); // save obj","title":"Obj writing"},{"location":"yocto/yocto_modelio/#pbrt-models","text":"The Pbrt file format is a scene representation suitable for realistic rendering and implemented by the Pbrt renderer. To use this library is helpful to understand the basic of the Pbrt file format for example from the Pbrt format documentatioon . The Pbrt file format is an extensible file format for a plugin-based system. Representing the format directly allows for best fidelity but pushed the burden of interpreting standard plugins to the use. Yocto/ModelIO takes a different approach and translates camera, shapes, materials, textures and lights from Pbrt plugins to a common representation that presents users a simpler and more uniform scene representation. Yocto/ModelIO represents Pbrt data with the pbrt_model struct. Pbrt models are defined as collections of cameras, instanced shapes, materials, texture and environments. Pbrt cameras are translate into a thin-len approximations. Pbrt materials are translated to a material representation similar to the Disney BSDF. Pbrt textures are either interpreted ion the fly or defined by a image file. Pbrt area lights are translated to either emissive materials and environments. The Pbrt model is defined as an array of objects of the types defined above. Pbrt objects are pointers owned by the main pbrt_model . Objects properties can be read and written directly from the model data, and are documented in the header file for now. Yocto/ModelIO does not currently provide functions to read and write Pbrt shapes with a simpler interface than accessing data directly. In general, Pbrt support is still experimental even if the library can parse most Pbrt files. The objects properties documentations are for now stored in the header file. auto pbrt = new pbrt_model {...}; // obj model buffer for ( auto shape : pbrt -> shapes ) // access shapes print_info ( shape -> name ); // access shape properties for ( auto material : pbrt -> material ) // access materials print_info ( material -> diffuse ); // access material properties for ( auto material : pbrt -> material ) // access materials print_info ( material -> color_tex ); // access material textures for ( auto camera : pbrt -> cameras ) // access cameras [extension] print_info ( camera -> frame ); // access camera properties for ( auto environment : pbrt -> environments ) // access environments [extension] print_info ( environment -> emission ); // access environment properties Use load_pbrt(filename, pbrt, error) to load Pbrt files and save_pbrt(filename, pbrt, error) to save them. Both loading and saving take a filename, a pointer to a Pbrt model, and returns whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto pbrt = new pbrt_model {}; // obj model buffer auto error = string {}; // error buffer if ( ! load_pbrt ( filename , pbrt , error )) // load obj print_error ( error ); // check and print error if ( ! save_pbrt ( filename , pbrt , error )) // save obj print_error ( error ); // check and print error","title":"Pbrt models"},{"location":"yocto/yocto_noise/","text":"Yocto/Noise: Noise functions Yocto/Noise provides a Perlin noise implementation. Yocto/Noise is implemented in yocto_noise.h . Noise functions Use perlin_noise(p, w) to generate Perlin noise with optional wrapping. Returned values are in the range [0, 1] following the Renderman convention and to ensure that all noise functions return values in the same range. For fractal variations, use perlin_ridge(p, l, g, o, f, w) , perlin_fbm(p, l, g, o, w) and perlin_turbulence(p, l, g, o, w) . Each fractal version is defined by its lacunarity l , its gain g , the number of octaves o and possibly an offet. auto p = vec3f { 0 , 0 , 0 }; auto n = perlin_noise ( p ); auto lacunarity = 2.0f , gain = 0.5.0f , , offset = 1.0f ; auto octaves = 6 ; auto n = perlin_ridge ( p , lacunarity , gain , octaves , offset ); auto n = perlin_fbm ( p , lacunarity , gain , octaves ); auto n = perlin_turbulence ( p , lacunarity , gain , octaves );","title":"Noise functions"},{"location":"yocto/yocto_noise/#yoctonoise-noise-functions","text":"Yocto/Noise provides a Perlin noise implementation. Yocto/Noise is implemented in yocto_noise.h .","title":"Yocto/Noise: Noise functions"},{"location":"yocto/yocto_noise/#noise-functions","text":"Use perlin_noise(p, w) to generate Perlin noise with optional wrapping. Returned values are in the range [0, 1] following the Renderman convention and to ensure that all noise functions return values in the same range. For fractal variations, use perlin_ridge(p, l, g, o, f, w) , perlin_fbm(p, l, g, o, w) and perlin_turbulence(p, l, g, o, w) . Each fractal version is defined by its lacunarity l , its gain g , the number of octaves o and possibly an offet. auto p = vec3f { 0 , 0 , 0 }; auto n = perlin_noise ( p ); auto lacunarity = 2.0f , gain = 0.5.0f , , offset = 1.0f ; auto octaves = 6 ; auto n = perlin_ridge ( p , lacunarity , gain , octaves , offset ); auto n = perlin_fbm ( p , lacunarity , gain , octaves ); auto n = perlin_turbulence ( p , lacunarity , gain , octaves );","title":"Noise functions"},{"location":"yocto/yocto_sampling/","text":"Yocto/Sampling: Sampling routines Yocto/Sampling provides many functions to generate points and directions useful in path tracing and procedural generation. We also include a random number generator suitable for ray tracing. Random number generation Yocto/Sampling includes an implementation of the PCG32 random number generator, that is a portable generator well suited for graphics applications. The state of the generator is stored in rng_state and uses only 16 bytes. The generator is default-initialized to be able to provide random numbers as is. You can use make_rng(seed,seq) to initialize a generator with a given seed and byt selecting a specific random sequence. See PCG32 for a discussion. If you do not need to select a sequence, just use the default value. Use rand1f(rng) , rand2f(rng) , rand3f(rng) and rand4f(rng) to generate random 1-4 dimensional float vectors with coordinates in [0,1). Use rand1i(rng,n) to generate a random integer in the [0,n) range. Use shuffle(sequence, rng) to randomly shuffle a sequence. auto rng = make_rng ( 172784 ); // seed the generator auto r1 = rand1f ( rng ); auto r2 = rand2f ( rng ); // 1-2 dim. random numbers auto r3 = rand3f ( rng ); auto r4 = rand4f ( rng ); // 3-4 dim. random numbers auto ri = rand1i ( rng , 10 ); // random int in [0,10) auto vec = std :: vector < float > {...}; shuffle ( vec , rng ); // random shuffle of a vector Generating points and directions Yocto/Sampling defines several functions to generate random points and directions. Each of these functions is a warp that takes random numbers in the [0,1) domain and warps them to the desired distributions. The functions are particularly useful in procedural modeling and path tracing. For each function, Yocto/Sampling provides both the warp as well as its pdf, that can be used in Monte Carlo integration. Yocto/Sampling supports generating directions uniformly over the unit hemisphere and sphere, or cosine distributed over the hemisphere, using respectively sample_hemisphere(ruv) , sample_sphere(ruv) , sample_hemisphere_cos(ruv) sample_hemisphere_cos(ruv) and sample_hemisphere_cos(ruv) . For each of these functions, the corresponding sample_<distribution>_pdf(dir) computes the pdf that the given direction was chosen. auto rng = make_rng ( 172784 ); // seed the generator auto rhu = sample_hemisphere ( rand2f ( rng )); // random hemispherical direction auto phu = sample_hemisphere_pdf ( rand2f ( rng )); // direction pdf auto rhc = sample_hemisphere_cos ( rand2f ( rng )); // cos-distributed direction auto rsu = sample_sphere ( rand2f ( rng )); // random spherical direction auto rhu2 = sample_hemisphere ( normal , rand2f ( rng )); // oriented hemisphere auto rhc2 = sample_hemisphere_cos ( normal , rand2f ( rng )); // oriented hemisphere Yocto/Sampling supports generating points uniformly on geometric primitives. Use sample_disk(uv) to uniformly sample a disk and sample_triangle(uv) to uniformly sample a triangle. For triangles we also support direct sampling of triangle points with sample_triangle(p0,p1,p2,ruv) . by warping random numbers from the unit square to uniformly over the unit hemisphere and sphere, or cosine distributed over the hemisphere, using respectively sample_hemisphere(ruv) , sample_sphere(ruv) , sample_hemisphere_cos(ruv) sample_hemisphere_cos(ruv) and sample_hemisphere_cos(ruv) . For each of these functions, the corresponding sample_<distribution>_pdf(dir) computes the pdf that the given direction was chosen. auto rng = make_rng ( 172784 ); // seed the generator auto sdu = sample_disk ( rand2f ( rng )); // uniform uv on disk auto stu = sample_triangle ( rand2f ( rng )); // uniform uv on triangle auto stp = sample_triangle ( p0 , p1 , p2 , rand2f ( rng )); // uniform triangle point Sampling distributions Yocto/Sampling defines several functions to sample distributions. Each of these functions is a warp that takes a random number in the [0,1) domain and warps it to the desired distribution. For each function, Yocto/Sampling provides both the warp as well as its pdf, that can be used in Monte Carlo integration. Use sample_uniform(n,r) to randomly pick an index in the [0,n) range, sample_uniform(elems,r) to randomly pick an element from a sequence, sample_discrete_cdf(cdf,r) to pick an index from a discrete distribution that has CDF cdf and sample_discrete_weights(w,r) to pick an index from a discrete distribution with probability equal to the weights array. For discrete distribution, sample_discrete_cdf() is significantly faster when computing many samples. auto rng = make_rng ( 172784 ); // seed the generator auto idx = sample_uniform ( num , rand1f ( rng )); // uniform index auto & elem = sample_uniform ( elems , rand1f ( rng )); // uniform element auto prob = std :: vector < float > { 0.3 , 0.3 , 0.4 }; // probability distribution auto pidx = sample_discrete_weights ( prob , rand1f ( rng )); // index with prob auto ppidx = sample_discrete_weights_pdf ( prob , pidx ); // index pdf auto cdf = std :: vector < float > { prob . size ()}; for ( auto i : range ( prob . size ()) // compute cdf cdf [ i ] = prob [ i ] + ( i ? cdf [ i - 1 ] : 0 ); auto cidx = sample_discrete_cdf ( cdf , rand1f ( rng )); // index with cdf auto pcidx = sample_discrete_cdf_pdf ( cdf , cidx ); // index pdf","title":"Sampling routines"},{"location":"yocto/yocto_sampling/#yoctosampling-sampling-routines","text":"Yocto/Sampling provides many functions to generate points and directions useful in path tracing and procedural generation. We also include a random number generator suitable for ray tracing.","title":"Yocto/Sampling: Sampling routines"},{"location":"yocto/yocto_sampling/#random-number-generation","text":"Yocto/Sampling includes an implementation of the PCG32 random number generator, that is a portable generator well suited for graphics applications. The state of the generator is stored in rng_state and uses only 16 bytes. The generator is default-initialized to be able to provide random numbers as is. You can use make_rng(seed,seq) to initialize a generator with a given seed and byt selecting a specific random sequence. See PCG32 for a discussion. If you do not need to select a sequence, just use the default value. Use rand1f(rng) , rand2f(rng) , rand3f(rng) and rand4f(rng) to generate random 1-4 dimensional float vectors with coordinates in [0,1). Use rand1i(rng,n) to generate a random integer in the [0,n) range. Use shuffle(sequence, rng) to randomly shuffle a sequence. auto rng = make_rng ( 172784 ); // seed the generator auto r1 = rand1f ( rng ); auto r2 = rand2f ( rng ); // 1-2 dim. random numbers auto r3 = rand3f ( rng ); auto r4 = rand4f ( rng ); // 3-4 dim. random numbers auto ri = rand1i ( rng , 10 ); // random int in [0,10) auto vec = std :: vector < float > {...}; shuffle ( vec , rng ); // random shuffle of a vector","title":"Random number generation"},{"location":"yocto/yocto_sampling/#generating-points-and-directions","text":"Yocto/Sampling defines several functions to generate random points and directions. Each of these functions is a warp that takes random numbers in the [0,1) domain and warps them to the desired distributions. The functions are particularly useful in procedural modeling and path tracing. For each function, Yocto/Sampling provides both the warp as well as its pdf, that can be used in Monte Carlo integration. Yocto/Sampling supports generating directions uniformly over the unit hemisphere and sphere, or cosine distributed over the hemisphere, using respectively sample_hemisphere(ruv) , sample_sphere(ruv) , sample_hemisphere_cos(ruv) sample_hemisphere_cos(ruv) and sample_hemisphere_cos(ruv) . For each of these functions, the corresponding sample_<distribution>_pdf(dir) computes the pdf that the given direction was chosen. auto rng = make_rng ( 172784 ); // seed the generator auto rhu = sample_hemisphere ( rand2f ( rng )); // random hemispherical direction auto phu = sample_hemisphere_pdf ( rand2f ( rng )); // direction pdf auto rhc = sample_hemisphere_cos ( rand2f ( rng )); // cos-distributed direction auto rsu = sample_sphere ( rand2f ( rng )); // random spherical direction auto rhu2 = sample_hemisphere ( normal , rand2f ( rng )); // oriented hemisphere auto rhc2 = sample_hemisphere_cos ( normal , rand2f ( rng )); // oriented hemisphere Yocto/Sampling supports generating points uniformly on geometric primitives. Use sample_disk(uv) to uniformly sample a disk and sample_triangle(uv) to uniformly sample a triangle. For triangles we also support direct sampling of triangle points with sample_triangle(p0,p1,p2,ruv) . by warping random numbers from the unit square to uniformly over the unit hemisphere and sphere, or cosine distributed over the hemisphere, using respectively sample_hemisphere(ruv) , sample_sphere(ruv) , sample_hemisphere_cos(ruv) sample_hemisphere_cos(ruv) and sample_hemisphere_cos(ruv) . For each of these functions, the corresponding sample_<distribution>_pdf(dir) computes the pdf that the given direction was chosen. auto rng = make_rng ( 172784 ); // seed the generator auto sdu = sample_disk ( rand2f ( rng )); // uniform uv on disk auto stu = sample_triangle ( rand2f ( rng )); // uniform uv on triangle auto stp = sample_triangle ( p0 , p1 , p2 , rand2f ( rng )); // uniform triangle point","title":"Generating points and directions"},{"location":"yocto/yocto_sampling/#sampling-distributions","text":"Yocto/Sampling defines several functions to sample distributions. Each of these functions is a warp that takes a random number in the [0,1) domain and warps it to the desired distribution. For each function, Yocto/Sampling provides both the warp as well as its pdf, that can be used in Monte Carlo integration. Use sample_uniform(n,r) to randomly pick an index in the [0,n) range, sample_uniform(elems,r) to randomly pick an element from a sequence, sample_discrete_cdf(cdf,r) to pick an index from a discrete distribution that has CDF cdf and sample_discrete_weights(w,r) to pick an index from a discrete distribution with probability equal to the weights array. For discrete distribution, sample_discrete_cdf() is significantly faster when computing many samples. auto rng = make_rng ( 172784 ); // seed the generator auto idx = sample_uniform ( num , rand1f ( rng )); // uniform index auto & elem = sample_uniform ( elems , rand1f ( rng )); // uniform element auto prob = std :: vector < float > { 0.3 , 0.3 , 0.4 }; // probability distribution auto pidx = sample_discrete_weights ( prob , rand1f ( rng )); // index with prob auto ppidx = sample_discrete_weights_pdf ( prob , pidx ); // index pdf auto cdf = std :: vector < float > { prob . size ()}; for ( auto i : range ( prob . size ()) // compute cdf cdf [ i ] = prob [ i ] + ( i ? cdf [ i - 1 ] : 0 ); auto cidx = sample_discrete_cdf ( cdf , rand1f ( rng )); // index with cdf auto pcidx = sample_discrete_cdf_pdf ( cdf , cidx ); // index pdf","title":"Sampling distributions"},{"location":"yocto/yocto_scene/","text":"Yocto/Scene: Scene representation Yocto/Scene define a simple scene representation, and related utilities, used to write other libraries in Yocto/GL. Yocto/Scene is implemented in yocto_scene.h and yocto_scene.cpp . Scene representation Scenes are stored in scene_model structs and are comprised of array of objects whose memory is owned by the scene. Scenes are comprised of camera, instances, shapes, materials, textures and environments. Animation is not currently supported. The scene representation is geared toward modeling physically-based environments. In Yocto/Scene, lights are not explicitly defined, but implicitly comprised of instances with emissive materials and environment maps. All scenes and objects properties are accessible directly. Some scene data, like lights and ray-acceleration structures, are computed when necessary and should not be accessed directly. All scenes objects have names that have to be unique and are used for both UI and serialization. Cameras, instances and environments have coordinate frames to define the local to world transformation. Frames are presented as affine 3x4 matrices and are intended to be rigid transforms, although most scene processing support frames with scaling. Cameras , represented by scene_camera , are based on a simple lens model. Cameras coordinate systems are defined by their frame. Cameras projections are described in photographic terms. In particular, we specify film size (35mm by default), film aspect ration, the lens' focal length, the focus distance and the lens aperture. All values are in meters. We support both perspective and orthographic cameras, but prefer the former. Common aspect ratios used in video and still photography are 3:2 on 35 mm (0.036 x 0.024), 16:9 on 35 mm (0.036 x 0.02025 or 0.04267 x 0.024), 2.35:1 on 35 mm (0.036 x 0.01532 or 0.05640 x 0.024), 2.39:1 on 35 mm (0.036 x 0.01506 or 0.05736 x 0.024), 2.40:1 on 35 mm (0.036 x 0.015 or 0.05760 x 0.024). To compute good apertures, one can use the F-stop number from photography and set the aperture to focal length over f-stop. Textures , represented as scene_texture contain either 8-bit LDR or 32-bit float HDR images of either scalar or color (RGB) type. HDR images are encoded in linear color space, while LDR images are encoded in sRGB. Materials are modeled similarly to the Disney Principled BSDF and the Autodesk Standard Surface . Materials are defined using many parameters that control material emission, surface scattering and homogeneous volumetric scattering. Each material parameter has an associated texture, where texture values are multiplied by parameter values. Materials specify a diffuse surface emission emission with HDR values that represent emitted radiance. Surface scattering is modeled by defining the main surface color color , that represent the surface albedo. Specular reflection is modeled by default as a dielectric with index of refraction ior , roughness roughness and is scaled by a specular weight specular . By default, specular reflection is dielectric. Materials can reflect light as metals by setting the metallic parameter. In this case, a metallic specular reflection is defined by the surface color interpreted as metallic reflectivity, and surface roughness defined by the previous parameter. Surfaces are optionally covered by a coating layer defined by a coat parameter. By default surfaces are fully opaque, but can defined a opacity parameter and texture to define the surface coverage. Materials also define volumetric scattering properties by setting a transmission parameter that sets the transmitted surface color. Surfaces are be default considered as thin sheet, but can be modeled as isotropic volumes if the thin parameter is set to false. In that case, the surface transmission controls the volumetric parameters by defining the volume density, while the volume scattering albedo is defined by the scattering property. Shapes are represented as indexed meshes of elements using the scene_shape type. Shapes can contain only one type of element, either points, lines, triangles or quads. Shape elements are parametrized as in Yocto/Geometry . Vertex properties are defined as separate arrays and include positions, normals, texture coords, colors, radius and tangent spaces. Additionally, Yocto/Scenes supports face-varying primitives where each vertex data has its own topology. Shapes supports tesselation and displacement mapping. Shape specify a level of subdivision and can be subdivide elements either linearly or using Catmull-Clark subdivision. Shapes also support displacement by specifying both a displacement texture and a displacement amount. Differently from most systems, in Yocto/Scene displacement is specified in the shape and not the material, that only controls shading. Subdivision and displacement are only specified in shapes, but not taken into account when evaluating shape properties. For this to happen, shapes have to be tessellated, as shown later. Shapes are placed in the scene by defining shape instances that take a coordinate frame, a shape pointer and a material pointer. Instances are represented by the scene_instance type. Instances are represented as scene_instance objects. Thought the use of instancing Yocto/Scene scales well to large environments without introducing more complex mechanisms. Scenes might be lit by background illumination defined by environments , represented by the scene_environment type. Environments have a frame, to rotate illumination, an emission term and an optional emission texture. The emission texture is an HDR environment map stored in a LatLon parametrization. Scene Creation Objects are added to the scene via add_<object>(scene,name) functions, where <object> is the object type name. In these functions, the name is optional and, if left blank, a unique name will be generated automatically. For each object type, properties can be set directly. As a convenience, Yocto/Scene defines several functions to set objects properties. For cameras, use set_frame(camera, frame) to set the local to world frame, set_lens(camera, lens, aspect, film, ortho) to set the camera projection using photographic lens parameters, and set_focus(camera, aperture, focus) to set the camera aperture and focus distance. auto scene = new scene_model {}; // create a scene auto camera = add_camera ( scene , \"cam\" ); // create a camera named cam set_frame ( camera , identity3x4f ); // set frame to identity set_lens ( camera , 0.050 , 1.5 , 0.036 ); // set as 50mm lens 3:2 aspect on 35mm set_aperture ( camera , 0.01 , 10 ); // set 10mm aperture focused at 10m For instances, use set_frame(instance, frame) to set the local to world frame, set_shape(instance, shape) and set_material(instance, material) to set the shape and material pointers. Since adding instances of single shapes is common in simpler scenes, the function add_complete_instance(scene, name) adds an instance with a new shape and material. auto scene = new scene_model {}; // create a scene auto instance = add_instance ( scene , \"ist\" ); // create an instance named ist set_frame ( instance , identity3x4f ); // set frame to identity auto shape = add_shape ( scene , \"shp\" ); set_shape ( instance , shape ); // set shape pointer auto material = add_material ( scene , \"mat\" ); set_material ( instance , material ); // set material pointer auto instance1 = add_complete_instance ( scene , \"obj\" ); // create an instance print_info ( instance1 -> shape ); // with a new shape print_info ( instance1 -> material ); // and a new material For textures, use set_texture(texture, img) to set the texture to the specified image. The function has overloads for images with one or three channels and with float or byte channel types. auto scene = new scene_model {}; // create a scene auto texture = add_texture ( scene , \"tex\" ); // create a texture named tex set_texture ( texture , image < vec3f > {...}); // set as a color HDR texture set_texture ( texture , image < vec3b > {...}); // set as a color LDR texture set_texture ( texture , image < float > {...}); // set as a scalar HDR texture set_texture ( texture , image < byte > {...}); // set as a scalar LDR texture For materials, Yocto/Scene defines functions to set each material property. Each functions take as input the parameter value and an optional texture. Use set_emission(material, emission, tex) to set material emission. Use set_color(material, color, tex) to set the surface color, set_specular(material, specular, tex) , set_metallic(material, metallic, tex) , set_transmission(material, transmission, tex) for specular, metallic and transmission weights, set_ior(material, ior) , set_roughness(material, roughness, tex) , set_opacity(material, opacity, tex) for surface ior, roughness and opacity, set_scattering(material, scattering,tex) for volumetric scattering and set_thin(material, thin) for the thin flag. auto scene = new scene_model {}; // create a scene auto matte = add_texture ( scene , \"matte\" ); // create a matte material set_color ( matte , { 1 , 0.5 , 0.5 }, add_texture ( scene )); // textured albedo auto plastic = add_texture ( scene , \"plastic\" ); // create a plastic material set_color ( plastic , { 0.5 , 1 , 0.5 }); // constant color set_specular ( plastic , 1 ); // constant specular set_roughness ( plastic , 0.1 , add_texture ( scene )); // textured roughness auto metal = add_texture ( scene , \"metal\" ); // create a metal material set_color ( metal , { 0.5 , 0.5 , 1 }); // constant color set_specular ( metal , 1 ); // constant specular set_roughness ( metal , 0.1 ); // constant roughness auto tglass = add_texture ( scene , \"tglass\" ); // create a thin glass material set_color ( tglass , { 1 , 1 , 1 }); // constant color set_specular ( tglass , 1 ); // constant specular set_transmission ( tglass , 1 ); // constant transmission auto glass = add_texture ( scene , \"glass\" ); // create a glass material set_color ( glass , { 1 , 1 , 1 }); // constant color set_specular ( glass , 1 ); // constant specular set_transmission ( glass , 1 ); // constant transmission set_thin ( glass , false ); // volumetric material auto subsurf = add_texture ( scene , \"subsurf\" ); // create a subsurface material set_color ( subsurf , { 1 , 1 , 1 }); // constant color set_specular ( subsurf , 1 ); // constant specular set_transmission ( subsurf , 1 ); // constant transmission set_thin ( subsurf , false ); // volumetric material set_scattering ( subsurf , { 0.5 , 1 , 0.5 }); // volumetric scattering For shapes, Yocto/Scene defines functions to set shape element indices and vertex properties. Use set_points(shape, points) , set_lines(shape, lines) , set_triangles(shape, triangles) , and set_quads(shape, quads) to set indexed meshes indices as points, lines, triangles and quads respectively. Use set_positions(shape, positions) , set_normals(shape, normals) , set_texcoords(shape, texcoords) , set_colors(shape, colors) , set_radius(shape, radius) , and set_tangents(shape, tangents) to set positions, normals, texture coordinates, colors, radius and tangent spaces respectively. auto scene = new scene_model {}; // create a scene auto shape = add_shape ( scene , \"shp\" ); // create a shape named shp set_triangles ( shape , vector < vec3i > {...}); // set triangle indices set_positions ( shape , vector < vec3f > {...}); // set positions set_normals ( shape , vector < vec3f > {...}); // set normals set_texcoords ( shape , vector < vec2f > {...}); // set texture coordinates Use set_fvquads(shape, quadspos, quadsnorm, quadsuv) to set the shapes as a facce-varying quad mesh. Use set_displacement(shape, disp, tex) to set the displacement map and scale and set_subdivision(shape, level, cc) to set the subdivision level and whether to use Catmull-Clark or linear subdivision. auto scene = new scene_model {}; // create a scene auto shape = add_shape ( scene , \"shp\" ); // create a shape named shp set_fvquads ( shape , vector < vec4i > {...}, // set face-varying indices {}, vector < vec4i > {...}); // for positions and textures set_positions ( shape , vector < vec3f > {...}); // set positions set_texcoords ( shape , vector < vec2f > {...}); // set texture coordinates set_subdivision ( shape , 2 , true ); // set Catmull-Clark subdivision set_displacement ( shape , 1 , tex ); // sete displacement map tex For environments, use set_frame(environment, frame) to set the local to world frame, set_emission(instance, emission, emission_tex) to set the environment emission and emission texture. auto scene = new scene_model {}; // create a scene auto environment = add_environment ( scene , \"env\" ); // create an environment set_frame ( environment , identity3x4f ); // set identity transform auto tex = add_scene ( scene , \"sky\" ); // add hdr texture set_emission ( environment , { 1 , 1 , 1 }, tex ); // add emission scale and texture For quickly creating scenes, Yocto/Scene provides convenience functions that add missing elements to construct full scenes. Use add_cameras(scene) to add a default camera, add_materials(scene) to add default materials for instances that miss it, add_radius(scene) to add points and lines thickness for rendering, and add_sky(scene) to add a procedural sky environment map. auto scene = new scene_model {}; // create a scene auto shape = add_shape ( scene ); // add a shape auto instance = add_instance ( scene ); // add a shape instance set_shape ( instance , shape ); add_cameras ( scene ); // add default camera add_materials ( scene ); // add default materials to instances add_sky ( scene ); // add environment and procedural sky Evaluation of scene properties Yocto/Scene defines several function to evaluate scene properties. Use compute_bounds(scene) to compute the scene bounding boxes. Use get_camera(scene, name) to get a camera by name or the default camera is the name is not given. Use eval_camera(camera, image_uv, lens_uv) to get a camera ray from the normalized image coordinates image_uv and lens coordinates lens_uv . auto scene = new scene_model {...}; // create a complete scene auto camera = get_camera ( scene ); // get default camera auto ray = eval_camera ( camera ,{ 0.5 , 0.5 },{ 0 , 0 }); // get ray though image center Use texture_size(texture) to get the texture resolution, and eval_texture(texture, uv) to evaluate the texture at specific uvs. Textures evaluation returns a color in linear color space, regardless of the texture representation. auto scene = new scene_model {...}; // create a complete scene auto texture = scene -> textures . front (); // get first texture auto col = eval_texture ( texture ,{ 0.5 , 0.5 }); // eval texture Use eval_material(material, texcoord) to evaluate material textures and combine them with parameter values. The function returns a scene_material_sample that has the same parameters of a material but no textures defined. auto scene = new scene_model {...}; // create a complete scene auto material = scene -> materials . front (); // get first material auto mat = eval_texture ( material ,{ 0.5 , 0.5 }); // eval material Several functions are defined to evaluate the geometric and material properties of points on instances, indicated by the shape element id and, when needed, the shape element barycentric coordinates. Use eval_position(...) to evaluate the point position, eval_normal(...) to evaluate the interpolate point normal, eval_texcoord(...) to evaluate the point texture coordinates, eval_element_normal(...) to evaluate the point geometric normal, and eval_color(...) to evaluate the interpolate point color. Use eval_material(...) as a convenience function to evaluate material properties of instance points. auto scene = new scene_model {...}; // create a complete scene auto instance = scene -> instances . front (); // get first instance auto eid = 0 ; auto euv = vec3f { 0.5 , 0.5 }; // element id and uvs auto pos = eval_position ( instance , eid , euv ); // eval point position auto norm = eval_normal ( instance , eid , euv ); // eval point normal auto st = eval_texcoord ( instance , eid , euv ); // eval point texture coords auto col = eval_color ( instance , eid , euv ); // eval point color auto gn = eval_element_normal ( instance , eid , euv ); // eval geometric normal auto mat = eval_material ( instance , eid , euv ); // eval point material Use eval_environment(environment, direction) to evaluate an environment map emission along a specific direction direction . Use eval_environment(scene, direction) to accumulate the lighting for all environment maps. auto scene = new scene_model {...}; // create a complete scene auto enva = eval_environment ( scene , dir ); // eval all environments auto environment = scene -> environments . front (); // get first environment auto envi = eval_environment ( environment , dir ); // eval environment Ray-scene intersection Yocto/Scene supports ray-scene intersection queries accelerated by a two-level BVH. We provide both our implementation and an Embree wrapper. To perform ray intersection queries, first initialize the BVH with init_bvh(scene, params, progress). The function takes a scene as input and builds a BVH that is stored internally. The BVH build strategy, and whether or not Embree is used is determined by the params settings. The function takes also an optional progress callback that is called as the BVH is build to report build progress. After initialization, if scene shapes and instances are modified, the BVH can be updated with update_bvh(...) . auto scene = new scene_model {...}; // create a complete scene auto params = scene_bvh_params {}; // default params auto progress = []( const string & message , // progress callback int current , int total ) { print_info ( message , current , total ); }; init_bvh ( scene , params , progress ); // build bvh params . type = scene_bvh_type :: embree_default ; // set build type as Embree init_bvh ( scene , params ); // build Embree bvh with no progress report Use intersect_scene_bvh(scene, ray) to intersect a ray with a scene, and intersect_instance_bvh(instance, ray) to intersect a ray with an instance. Both functions return a scene_intersection that includes a hit flag, the instance id, the shape element id, the shape element uv and intersection distance. auto scene = new scene_model {...}; // create a complete scene init_bvh ( scene , {}); // build default bvh auto ray = ray3f {...}; // ray auto isec = intersect_scene_bvh ( scene , ray ); // ray-scene intersection if ( isec . hit ) print_info ( isec ); auto instance = scene -> instances . first (); // get instance auto iisec = intersect_instance_bvh ( instance , ray ); // ray-instance int, if ( iisec . hit ) print_info ( isec ); Scene tesselation The evaluation functions defined above and the ray intersection functions do not support subdivision surfaces or displaced shapes directly. Instead, shapes should be converted to indexed meshes using tesselate_shape(shape) for a specific shape, or tesselate_shapes(scene, progress) for the whole scene. Note that tesselations are destructive, meaning that the original shape data is lost. This is done to avoid copying whenever possible. auto scene = new scene_model {...}; // create a complete scene void tesselate_shapes ( scene ); // tesselate shapes in the scene Scene stats and validation Yocto/Scene has functions to compute scene stats and provide validation of scene data. Use scene_stats(scene) to get scene stats and scene_validation(scene) to validate scene objects. auto scene = new scene_model {...}; // create a complete scene auto stats = scene_stats ( scene ); // get stats for ( auto stat : stats ) print_info ( stat ); // print stats auto errors = validate_stats ( scene ); // get validation errors for ( auto error : errors ) print_error ( error ); // print error Example scenes Yocto/Scene has a function to create a simple Cornell Box scene for testing. There are plans to increase support for more test scenes in the future. auto scene = new scene_model {...}; // create a complete scene make_cornellbox ( scene ); // make cornell box","title":"Scene representation"},{"location":"yocto/yocto_scene/#yoctoscene-scene-representation","text":"Yocto/Scene define a simple scene representation, and related utilities, used to write other libraries in Yocto/GL. Yocto/Scene is implemented in yocto_scene.h and yocto_scene.cpp .","title":"Yocto/Scene: Scene representation"},{"location":"yocto/yocto_scene/#scene-representation","text":"Scenes are stored in scene_model structs and are comprised of array of objects whose memory is owned by the scene. Scenes are comprised of camera, instances, shapes, materials, textures and environments. Animation is not currently supported. The scene representation is geared toward modeling physically-based environments. In Yocto/Scene, lights are not explicitly defined, but implicitly comprised of instances with emissive materials and environment maps. All scenes and objects properties are accessible directly. Some scene data, like lights and ray-acceleration structures, are computed when necessary and should not be accessed directly. All scenes objects have names that have to be unique and are used for both UI and serialization. Cameras, instances and environments have coordinate frames to define the local to world transformation. Frames are presented as affine 3x4 matrices and are intended to be rigid transforms, although most scene processing support frames with scaling. Cameras , represented by scene_camera , are based on a simple lens model. Cameras coordinate systems are defined by their frame. Cameras projections are described in photographic terms. In particular, we specify film size (35mm by default), film aspect ration, the lens' focal length, the focus distance and the lens aperture. All values are in meters. We support both perspective and orthographic cameras, but prefer the former. Common aspect ratios used in video and still photography are 3:2 on 35 mm (0.036 x 0.024), 16:9 on 35 mm (0.036 x 0.02025 or 0.04267 x 0.024), 2.35:1 on 35 mm (0.036 x 0.01532 or 0.05640 x 0.024), 2.39:1 on 35 mm (0.036 x 0.01506 or 0.05736 x 0.024), 2.40:1 on 35 mm (0.036 x 0.015 or 0.05760 x 0.024). To compute good apertures, one can use the F-stop number from photography and set the aperture to focal length over f-stop. Textures , represented as scene_texture contain either 8-bit LDR or 32-bit float HDR images of either scalar or color (RGB) type. HDR images are encoded in linear color space, while LDR images are encoded in sRGB. Materials are modeled similarly to the Disney Principled BSDF and the Autodesk Standard Surface . Materials are defined using many parameters that control material emission, surface scattering and homogeneous volumetric scattering. Each material parameter has an associated texture, where texture values are multiplied by parameter values. Materials specify a diffuse surface emission emission with HDR values that represent emitted radiance. Surface scattering is modeled by defining the main surface color color , that represent the surface albedo. Specular reflection is modeled by default as a dielectric with index of refraction ior , roughness roughness and is scaled by a specular weight specular . By default, specular reflection is dielectric. Materials can reflect light as metals by setting the metallic parameter. In this case, a metallic specular reflection is defined by the surface color interpreted as metallic reflectivity, and surface roughness defined by the previous parameter. Surfaces are optionally covered by a coating layer defined by a coat parameter. By default surfaces are fully opaque, but can defined a opacity parameter and texture to define the surface coverage. Materials also define volumetric scattering properties by setting a transmission parameter that sets the transmitted surface color. Surfaces are be default considered as thin sheet, but can be modeled as isotropic volumes if the thin parameter is set to false. In that case, the surface transmission controls the volumetric parameters by defining the volume density, while the volume scattering albedo is defined by the scattering property. Shapes are represented as indexed meshes of elements using the scene_shape type. Shapes can contain only one type of element, either points, lines, triangles or quads. Shape elements are parametrized as in Yocto/Geometry . Vertex properties are defined as separate arrays and include positions, normals, texture coords, colors, radius and tangent spaces. Additionally, Yocto/Scenes supports face-varying primitives where each vertex data has its own topology. Shapes supports tesselation and displacement mapping. Shape specify a level of subdivision and can be subdivide elements either linearly or using Catmull-Clark subdivision. Shapes also support displacement by specifying both a displacement texture and a displacement amount. Differently from most systems, in Yocto/Scene displacement is specified in the shape and not the material, that only controls shading. Subdivision and displacement are only specified in shapes, but not taken into account when evaluating shape properties. For this to happen, shapes have to be tessellated, as shown later. Shapes are placed in the scene by defining shape instances that take a coordinate frame, a shape pointer and a material pointer. Instances are represented by the scene_instance type. Instances are represented as scene_instance objects. Thought the use of instancing Yocto/Scene scales well to large environments without introducing more complex mechanisms. Scenes might be lit by background illumination defined by environments , represented by the scene_environment type. Environments have a frame, to rotate illumination, an emission term and an optional emission texture. The emission texture is an HDR environment map stored in a LatLon parametrization.","title":"Scene representation"},{"location":"yocto/yocto_scene/#scene-creation","text":"Objects are added to the scene via add_<object>(scene,name) functions, where <object> is the object type name. In these functions, the name is optional and, if left blank, a unique name will be generated automatically. For each object type, properties can be set directly. As a convenience, Yocto/Scene defines several functions to set objects properties. For cameras, use set_frame(camera, frame) to set the local to world frame, set_lens(camera, lens, aspect, film, ortho) to set the camera projection using photographic lens parameters, and set_focus(camera, aperture, focus) to set the camera aperture and focus distance. auto scene = new scene_model {}; // create a scene auto camera = add_camera ( scene , \"cam\" ); // create a camera named cam set_frame ( camera , identity3x4f ); // set frame to identity set_lens ( camera , 0.050 , 1.5 , 0.036 ); // set as 50mm lens 3:2 aspect on 35mm set_aperture ( camera , 0.01 , 10 ); // set 10mm aperture focused at 10m For instances, use set_frame(instance, frame) to set the local to world frame, set_shape(instance, shape) and set_material(instance, material) to set the shape and material pointers. Since adding instances of single shapes is common in simpler scenes, the function add_complete_instance(scene, name) adds an instance with a new shape and material. auto scene = new scene_model {}; // create a scene auto instance = add_instance ( scene , \"ist\" ); // create an instance named ist set_frame ( instance , identity3x4f ); // set frame to identity auto shape = add_shape ( scene , \"shp\" ); set_shape ( instance , shape ); // set shape pointer auto material = add_material ( scene , \"mat\" ); set_material ( instance , material ); // set material pointer auto instance1 = add_complete_instance ( scene , \"obj\" ); // create an instance print_info ( instance1 -> shape ); // with a new shape print_info ( instance1 -> material ); // and a new material For textures, use set_texture(texture, img) to set the texture to the specified image. The function has overloads for images with one or three channels and with float or byte channel types. auto scene = new scene_model {}; // create a scene auto texture = add_texture ( scene , \"tex\" ); // create a texture named tex set_texture ( texture , image < vec3f > {...}); // set as a color HDR texture set_texture ( texture , image < vec3b > {...}); // set as a color LDR texture set_texture ( texture , image < float > {...}); // set as a scalar HDR texture set_texture ( texture , image < byte > {...}); // set as a scalar LDR texture For materials, Yocto/Scene defines functions to set each material property. Each functions take as input the parameter value and an optional texture. Use set_emission(material, emission, tex) to set material emission. Use set_color(material, color, tex) to set the surface color, set_specular(material, specular, tex) , set_metallic(material, metallic, tex) , set_transmission(material, transmission, tex) for specular, metallic and transmission weights, set_ior(material, ior) , set_roughness(material, roughness, tex) , set_opacity(material, opacity, tex) for surface ior, roughness and opacity, set_scattering(material, scattering,tex) for volumetric scattering and set_thin(material, thin) for the thin flag. auto scene = new scene_model {}; // create a scene auto matte = add_texture ( scene , \"matte\" ); // create a matte material set_color ( matte , { 1 , 0.5 , 0.5 }, add_texture ( scene )); // textured albedo auto plastic = add_texture ( scene , \"plastic\" ); // create a plastic material set_color ( plastic , { 0.5 , 1 , 0.5 }); // constant color set_specular ( plastic , 1 ); // constant specular set_roughness ( plastic , 0.1 , add_texture ( scene )); // textured roughness auto metal = add_texture ( scene , \"metal\" ); // create a metal material set_color ( metal , { 0.5 , 0.5 , 1 }); // constant color set_specular ( metal , 1 ); // constant specular set_roughness ( metal , 0.1 ); // constant roughness auto tglass = add_texture ( scene , \"tglass\" ); // create a thin glass material set_color ( tglass , { 1 , 1 , 1 }); // constant color set_specular ( tglass , 1 ); // constant specular set_transmission ( tglass , 1 ); // constant transmission auto glass = add_texture ( scene , \"glass\" ); // create a glass material set_color ( glass , { 1 , 1 , 1 }); // constant color set_specular ( glass , 1 ); // constant specular set_transmission ( glass , 1 ); // constant transmission set_thin ( glass , false ); // volumetric material auto subsurf = add_texture ( scene , \"subsurf\" ); // create a subsurface material set_color ( subsurf , { 1 , 1 , 1 }); // constant color set_specular ( subsurf , 1 ); // constant specular set_transmission ( subsurf , 1 ); // constant transmission set_thin ( subsurf , false ); // volumetric material set_scattering ( subsurf , { 0.5 , 1 , 0.5 }); // volumetric scattering For shapes, Yocto/Scene defines functions to set shape element indices and vertex properties. Use set_points(shape, points) , set_lines(shape, lines) , set_triangles(shape, triangles) , and set_quads(shape, quads) to set indexed meshes indices as points, lines, triangles and quads respectively. Use set_positions(shape, positions) , set_normals(shape, normals) , set_texcoords(shape, texcoords) , set_colors(shape, colors) , set_radius(shape, radius) , and set_tangents(shape, tangents) to set positions, normals, texture coordinates, colors, radius and tangent spaces respectively. auto scene = new scene_model {}; // create a scene auto shape = add_shape ( scene , \"shp\" ); // create a shape named shp set_triangles ( shape , vector < vec3i > {...}); // set triangle indices set_positions ( shape , vector < vec3f > {...}); // set positions set_normals ( shape , vector < vec3f > {...}); // set normals set_texcoords ( shape , vector < vec2f > {...}); // set texture coordinates Use set_fvquads(shape, quadspos, quadsnorm, quadsuv) to set the shapes as a facce-varying quad mesh. Use set_displacement(shape, disp, tex) to set the displacement map and scale and set_subdivision(shape, level, cc) to set the subdivision level and whether to use Catmull-Clark or linear subdivision. auto scene = new scene_model {}; // create a scene auto shape = add_shape ( scene , \"shp\" ); // create a shape named shp set_fvquads ( shape , vector < vec4i > {...}, // set face-varying indices {}, vector < vec4i > {...}); // for positions and textures set_positions ( shape , vector < vec3f > {...}); // set positions set_texcoords ( shape , vector < vec2f > {...}); // set texture coordinates set_subdivision ( shape , 2 , true ); // set Catmull-Clark subdivision set_displacement ( shape , 1 , tex ); // sete displacement map tex For environments, use set_frame(environment, frame) to set the local to world frame, set_emission(instance, emission, emission_tex) to set the environment emission and emission texture. auto scene = new scene_model {}; // create a scene auto environment = add_environment ( scene , \"env\" ); // create an environment set_frame ( environment , identity3x4f ); // set identity transform auto tex = add_scene ( scene , \"sky\" ); // add hdr texture set_emission ( environment , { 1 , 1 , 1 }, tex ); // add emission scale and texture For quickly creating scenes, Yocto/Scene provides convenience functions that add missing elements to construct full scenes. Use add_cameras(scene) to add a default camera, add_materials(scene) to add default materials for instances that miss it, add_radius(scene) to add points and lines thickness for rendering, and add_sky(scene) to add a procedural sky environment map. auto scene = new scene_model {}; // create a scene auto shape = add_shape ( scene ); // add a shape auto instance = add_instance ( scene ); // add a shape instance set_shape ( instance , shape ); add_cameras ( scene ); // add default camera add_materials ( scene ); // add default materials to instances add_sky ( scene ); // add environment and procedural sky","title":"Scene Creation"},{"location":"yocto/yocto_scene/#evaluation-of-scene-properties","text":"Yocto/Scene defines several function to evaluate scene properties. Use compute_bounds(scene) to compute the scene bounding boxes. Use get_camera(scene, name) to get a camera by name or the default camera is the name is not given. Use eval_camera(camera, image_uv, lens_uv) to get a camera ray from the normalized image coordinates image_uv and lens coordinates lens_uv . auto scene = new scene_model {...}; // create a complete scene auto camera = get_camera ( scene ); // get default camera auto ray = eval_camera ( camera ,{ 0.5 , 0.5 },{ 0 , 0 }); // get ray though image center Use texture_size(texture) to get the texture resolution, and eval_texture(texture, uv) to evaluate the texture at specific uvs. Textures evaluation returns a color in linear color space, regardless of the texture representation. auto scene = new scene_model {...}; // create a complete scene auto texture = scene -> textures . front (); // get first texture auto col = eval_texture ( texture ,{ 0.5 , 0.5 }); // eval texture Use eval_material(material, texcoord) to evaluate material textures and combine them with parameter values. The function returns a scene_material_sample that has the same parameters of a material but no textures defined. auto scene = new scene_model {...}; // create a complete scene auto material = scene -> materials . front (); // get first material auto mat = eval_texture ( material ,{ 0.5 , 0.5 }); // eval material Several functions are defined to evaluate the geometric and material properties of points on instances, indicated by the shape element id and, when needed, the shape element barycentric coordinates. Use eval_position(...) to evaluate the point position, eval_normal(...) to evaluate the interpolate point normal, eval_texcoord(...) to evaluate the point texture coordinates, eval_element_normal(...) to evaluate the point geometric normal, and eval_color(...) to evaluate the interpolate point color. Use eval_material(...) as a convenience function to evaluate material properties of instance points. auto scene = new scene_model {...}; // create a complete scene auto instance = scene -> instances . front (); // get first instance auto eid = 0 ; auto euv = vec3f { 0.5 , 0.5 }; // element id and uvs auto pos = eval_position ( instance , eid , euv ); // eval point position auto norm = eval_normal ( instance , eid , euv ); // eval point normal auto st = eval_texcoord ( instance , eid , euv ); // eval point texture coords auto col = eval_color ( instance , eid , euv ); // eval point color auto gn = eval_element_normal ( instance , eid , euv ); // eval geometric normal auto mat = eval_material ( instance , eid , euv ); // eval point material Use eval_environment(environment, direction) to evaluate an environment map emission along a specific direction direction . Use eval_environment(scene, direction) to accumulate the lighting for all environment maps. auto scene = new scene_model {...}; // create a complete scene auto enva = eval_environment ( scene , dir ); // eval all environments auto environment = scene -> environments . front (); // get first environment auto envi = eval_environment ( environment , dir ); // eval environment","title":"Evaluation of scene properties"},{"location":"yocto/yocto_scene/#ray-scene-intersection","text":"Yocto/Scene supports ray-scene intersection queries accelerated by a two-level BVH. We provide both our implementation and an Embree wrapper. To perform ray intersection queries, first initialize the BVH with init_bvh(scene, params, progress). The function takes a scene as input and builds a BVH that is stored internally. The BVH build strategy, and whether or not Embree is used is determined by the params settings. The function takes also an optional progress callback that is called as the BVH is build to report build progress. After initialization, if scene shapes and instances are modified, the BVH can be updated with update_bvh(...) . auto scene = new scene_model {...}; // create a complete scene auto params = scene_bvh_params {}; // default params auto progress = []( const string & message , // progress callback int current , int total ) { print_info ( message , current , total ); }; init_bvh ( scene , params , progress ); // build bvh params . type = scene_bvh_type :: embree_default ; // set build type as Embree init_bvh ( scene , params ); // build Embree bvh with no progress report Use intersect_scene_bvh(scene, ray) to intersect a ray with a scene, and intersect_instance_bvh(instance, ray) to intersect a ray with an instance. Both functions return a scene_intersection that includes a hit flag, the instance id, the shape element id, the shape element uv and intersection distance. auto scene = new scene_model {...}; // create a complete scene init_bvh ( scene , {}); // build default bvh auto ray = ray3f {...}; // ray auto isec = intersect_scene_bvh ( scene , ray ); // ray-scene intersection if ( isec . hit ) print_info ( isec ); auto instance = scene -> instances . first (); // get instance auto iisec = intersect_instance_bvh ( instance , ray ); // ray-instance int, if ( iisec . hit ) print_info ( isec );","title":"Ray-scene intersection"},{"location":"yocto/yocto_scene/#scene-tesselation","text":"The evaluation functions defined above and the ray intersection functions do not support subdivision surfaces or displaced shapes directly. Instead, shapes should be converted to indexed meshes using tesselate_shape(shape) for a specific shape, or tesselate_shapes(scene, progress) for the whole scene. Note that tesselations are destructive, meaning that the original shape data is lost. This is done to avoid copying whenever possible. auto scene = new scene_model {...}; // create a complete scene void tesselate_shapes ( scene ); // tesselate shapes in the scene","title":"Scene tesselation"},{"location":"yocto/yocto_scene/#scene-stats-and-validation","text":"Yocto/Scene has functions to compute scene stats and provide validation of scene data. Use scene_stats(scene) to get scene stats and scene_validation(scene) to validate scene objects. auto scene = new scene_model {...}; // create a complete scene auto stats = scene_stats ( scene ); // get stats for ( auto stat : stats ) print_info ( stat ); // print stats auto errors = validate_stats ( scene ); // get validation errors for ( auto error : errors ) print_error ( error ); // print error","title":"Scene stats and validation"},{"location":"yocto/yocto_scene/#example-scenes","text":"Yocto/Scene has a function to create a simple Cornell Box scene for testing. There are plans to increase support for more test scenes in the future. auto scene = new scene_model {...}; // create a complete scene make_cornellbox ( scene ); // make cornell box","title":"Example scenes"},{"location":"yocto/yocto_sceneio/","text":"Yocto/SceneIO: Scene serialization Yocto/SceneIO supports loading and saving scenes Yocto/Scene models from Ply, Obj, Pbrt, glTF and a custom Json format. Yocto/SceneIO is implemented in yocto_sceneio.h and yocto_sceneio.cpp , and depends on cgltf.h . Serialization formats Yocto/SceneIO supports loading and saving to Ply, Obj, Pbrt, glTF, and a custom Json format. For the standard formats, loading is best effort, since scene data is transformed from the formats' scene models to the Yocto/Scene model. The custom Json format is a serialization of the internal properties for most scene objects, with a few conventions taken for extensibility. Scene's object arrays are represented as dictionaries in Json with the objects' names used as keys. This ensure proper reference semantic and allows for more extensibility in the future, but it also means that object order is not preserved during serialization. Cameras, materials, instances and environments are represented directly in the Json scene, while textures and shapes are serialized using standard image and geometry formats. By convention, scenes are stored as a single Json format for the scene structure. Textures are stored in the textures directory with the name of the texture as filename, while the extension is determined by checking th available files. Shapes are stored in the shapes directory with name of the shape as filename, while the extension is determined by checking th available files. Loading and saving scenes Scenes are loaded with load_scene(filename, scene, error, progress) and saved with save_scene(filename, scene, error, progress) . Both loading and saving take a filename, a scene pointer and return whether or not the scene was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. The functions take a progress callback as an optional parameter, that is called as scene loading progresses. auto scene = new scene_model {}; // scene auto progress = []( const string & message , // progress callback int current , int total ) { print_info ( message , current , total ); }; auto error = string {}; // error buffer if ( ! load_scene ( filename , scene , error , progress )) // load scene print_error ( error ); if ( ! save_scene ( filename , scene , error , progress )) // save scene print_error ( error );","title":"Scene serialization"},{"location":"yocto/yocto_sceneio/#yoctosceneio-scene-serialization","text":"Yocto/SceneIO supports loading and saving scenes Yocto/Scene models from Ply, Obj, Pbrt, glTF and a custom Json format. Yocto/SceneIO is implemented in yocto_sceneio.h and yocto_sceneio.cpp , and depends on cgltf.h .","title":"Yocto/SceneIO: Scene serialization"},{"location":"yocto/yocto_sceneio/#serialization-formats","text":"Yocto/SceneIO supports loading and saving to Ply, Obj, Pbrt, glTF, and a custom Json format. For the standard formats, loading is best effort, since scene data is transformed from the formats' scene models to the Yocto/Scene model. The custom Json format is a serialization of the internal properties for most scene objects, with a few conventions taken for extensibility. Scene's object arrays are represented as dictionaries in Json with the objects' names used as keys. This ensure proper reference semantic and allows for more extensibility in the future, but it also means that object order is not preserved during serialization. Cameras, materials, instances and environments are represented directly in the Json scene, while textures and shapes are serialized using standard image and geometry formats. By convention, scenes are stored as a single Json format for the scene structure. Textures are stored in the textures directory with the name of the texture as filename, while the extension is determined by checking th available files. Shapes are stored in the shapes directory with name of the shape as filename, while the extension is determined by checking th available files.","title":"Serialization formats"},{"location":"yocto/yocto_sceneio/#loading-and-saving-scenes","text":"Scenes are loaded with load_scene(filename, scene, error, progress) and saved with save_scene(filename, scene, error, progress) . Both loading and saving take a filename, a scene pointer and return whether or not the scene was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. The functions take a progress callback as an optional parameter, that is called as scene loading progresses. auto scene = new scene_model {}; // scene auto progress = []( const string & message , // progress callback int current , int total ) { print_info ( message , current , total ); }; auto error = string {}; // error buffer if ( ! load_scene ( filename , scene , error , progress )) // load scene print_error ( error ); if ( ! save_scene ( filename , scene , error , progress )) // save scene print_error ( error );","title":"Loading and saving scenes"},{"location":"yocto/yocto_shading/","text":"Yocto/Shading: Shading routines Yocto/Shading defines shading and sampling functions useful to write path tracing algorithms. Yocto/Shading is implemented in yocto_shading.h . Shading utilities Yocto/Shading defines many functions to handle Fresnel effects, both approximate and correct ones. Use fresnel_dielectric(eta, normal, outgoing) or fresnel_conductor(eta, etak, normal,outgoiong) to evaluate the fresnel term for dielectrics and conductors, or use fresnel_schlick(reflectivity, normal, outgoiong) for the Schlick fresnel approximation. The Schlick approximation uses reflectivity while the other functions use the index of refraction. All these functions that the normal and outgoing, or incoming, direction as input. Use eta_to_reflectivity(eta) and reflectivity_to_eta(reflectivity) to convert the dielectric index of refraction to reflectivity and vice-versa. Use eta_to_edgetint(eta, etak) and edgetint_to_eta(reflectivity, edgetint) to convert between the conductor index of refraction and its artist-friendly parametrization. Use conductor_eta(name) to get tabulated index of refractions for conductors. // approximate Fresnel for dielectric and conductors auto reflectivity1 = vec3f { 0.04 , 0.04 , 0.04 }; // dielectric reflectivity auto reflectivity2 = vec3f { 0.80 , 0.70 , 0.90 }; // conductor reflectivity auto fs1 = fresnel_schlick ( reflectivity_d , normal , outgoing ); auto fs1 = fresnel_schlick ( reflectivity_c , normal , outgoing ); // accurate Fresnel for dielectrics auto ior1 = vec3f { 1.5 , 1.5 , 1.5 }; // dielectric ior auto fd1 = fresnel_dielectric ( ior_d , normal , outgoing ); auto ior2 = reflectivity_to_eta ( reflectivity1 ); // reflectivity to ior // accurate Fresnel for conductors { \"Au\" , {{ 0.1431189557f , 0.3749570432f , 1.4424785571f }, { 3.9831604247f , 2.3857207478f , 1.6032152899f }}}, auto eta1 = vec3f { 0.143 , 0.375 , 1.442 }; // conductor complex ior auto etak1 = vec3f { 3.983 , 2.386 , 1.603 }; // conductor complex ior auto fc1 = fresnel_conductor ( eta1 , etak1 , normal , outgoing ); auto [ eta2 , etak2 ] = edgetint_to_eta ( reflectivity2 , vec3f {...}); // refl. to ior auto [ eta3 , etak3 ] = conductor_eta ( \"Au\" ); // get gold eta Most shaders today use some version of microfacet lobes for reflections and transmissions. Yocto/Shading has several functions to simplify writing those shaders. Use microfacet_distribution(roughness, normal, halfway, ggx) to evaluate the microfacet distribution and microfacet_shadowing(roughness, normal, halfway, ggx) to evaluate the shadow-masking term. Both functions take the surface roughness, the shading normal, the halfway vector and whether or not to use the GGX or Beckman distribution. Yocto/Shading also supports generating directions according to the microfacet distribution, both for GGX and Beckman. Use sample_microfacet(roughness, normal, rn, ggx) to generate halfway vector with distribution proportional to the microfacet distribution function and sample_microfacet(roughness, normal, outgoing, rn, ggx) to generate dictions using the distribution of visible normals. Use sample_microfacet_pdf(roughness, normal, halfway, ggx) or sample_microfacet_pdf(roughness, normal, halfway, outgoing, ggx) to compute the PDF for each sampling routine. auto normal = vec3f {...}; // shading normal auto incoming = vec3f {...} // incoming direction auto outgoing = vec3f {...}; // outgoing direction auto halfway = normalize ( incoming , outgoing ); // halfway vector reflection auto D = microfacet_distribution ( roughness , normal , halfway ); // distribution auto G = microfacet_shadowing ( roughness , normal , halfway ); // shadowing auto halfway1 = sample_microfacet ( roughness , normal , rand2f ( rng )); // sample auto pdf = sample_microfacet_pdf ( roughness , normal , halfway1 ); // sample pdf Bsdf lobes Most path tracing shaders are defined as sum of single BSDF lobes. Yocto/Shading provides and implementation for several common BSDF lobes. Three functions are implemented for each lobe. Use eval_<lobe>(<params>, normal, outgoing, incoming) to evaluates the lobe BSDF multiplied by the cosine, sample_<lobe>(<params>, normal, outgoing, rn) to sample an incoming direction, and sample_<lobe>_pdf(<params>, normal, outgoing, incoming) to compute the sampled direction pdf. Yocto/Shading supports the following lobes: diffuse_reflection : diffuse brdf diffuse_transmission : translucency brdf, as a flipped diffuse microfacet_reflection : specular brdf for dielectrics and metals microfacet_transmission : transmission brdf for thin dielectrics microfacet_refraction : refraction brdf for dielectrics, includes reflection and refraction delta_reflection : delta specular for dielectrics and metals delta_transmission : delta transmission for thin dielectrics delta_refraction : delta refraction for dielectrics auto normal = vec3f {...}; // shading normal auto incoming = vec3f {...} // incoming direction auto outgoing = vec3f {...}; // outgoing direction auto rs = float { 0.1 }; // roughness auto ior = float { 1.5 }; // dielectric ior auto [ eta , etak ] = conductor_eta ( \"Au\" ); // conductor complex ior // evaluate smooth lobes auto b1 = eval_diffuse_reflection ( normal , outgoing , incoming ); auto b2 = eval_diffuse_transmission ( normal , outgoing , incoming ); auto b3 = eval_microfacet_reflection ( ior , rs , normal , outgoing , incoming ); auto b4 = eval_microfacet_reflection ( eta , etak , rs , normal , outgoing , incoming ); auto b5 = eval_microfacet_transmission ( ior , rs , normal , outgoing , incoming ); auto b6 = eval_microfacet_refraction ( ior , rs , normal , outgoing , incoming ); // sample smooth lobes auto incoming1 = sample_diffuse_reflection ( normal , outgoing , rand2f ( rng )); auto pdf1 = sample_diffuse_reflection_pdf ( normal , outgoing , incoming ) // eval and sample delta lobes auto incoming2 = sample_delta_reflection ( ior , normal , outgoing ); auto b7 = eval_delta_reflection ( ior , normal , outgoing , incoming ); Volumetric lobes Yocto/Shading defines functions to simplify the implementation of volumetric effects. Use eval_transmittance(density, distance) to evaluate the transmittance of a homogeneous volume, sample_transmittance(density, max_distance, rn) to sample a distance inside an homogeneous medium, sample_transmittance_pdf(density, distance, max_distance) to compute the pdf of the sampled distance. The sampling function may return a distance equal to max distance, in which case the ray has exited the medium. Use mfp_to_transmission(mfp, depth) to convert mean-free-path to transmission at a specific depth. auto density = vec3f { 0.99 , 0.99 , 0.99 }; // medium density auto max_distance = float { 1 }; // maximum distance inside the medium auto distance = sample_transmittance ( density , max_distance , // sample distance rand1f ( rng ), rand1f ( rng )); auto pdf = sample_transmittance_pdf ( density , distance , max_distance ) // pdf auto transmittance = eval_transmittance ( density , distance ); Use eval_phasefunction(anisotropy, outgoing, incoming) to evaluate the HG phase function, sample_phasefunction(anisotropy, outgoing, rn) to sample a direction according to the phse function, sample_phasefunction_pdf(anisotropy, outgoing, incoming) to compute the pdf of the sampled direction. auto outgoing = vec3f {...}; // outgoing direction auto anisotropy = float { 0 }; // isotropic phase function auto incoming = sample_phasefunction ( anisotropy , outgoing , rand2f ( rng )); auto phasefunc = eval_phasefunction ( anisotropy , outgoing , incoming ); auto pdf = sample_phasefunction_pdf ( anisotropy , outgoing , incoming );","title":"Shading routines"},{"location":"yocto/yocto_shading/#yoctoshading-shading-routines","text":"Yocto/Shading defines shading and sampling functions useful to write path tracing algorithms. Yocto/Shading is implemented in yocto_shading.h .","title":"Yocto/Shading: Shading routines"},{"location":"yocto/yocto_shading/#shading-utilities","text":"Yocto/Shading defines many functions to handle Fresnel effects, both approximate and correct ones. Use fresnel_dielectric(eta, normal, outgoing) or fresnel_conductor(eta, etak, normal,outgoiong) to evaluate the fresnel term for dielectrics and conductors, or use fresnel_schlick(reflectivity, normal, outgoiong) for the Schlick fresnel approximation. The Schlick approximation uses reflectivity while the other functions use the index of refraction. All these functions that the normal and outgoing, or incoming, direction as input. Use eta_to_reflectivity(eta) and reflectivity_to_eta(reflectivity) to convert the dielectric index of refraction to reflectivity and vice-versa. Use eta_to_edgetint(eta, etak) and edgetint_to_eta(reflectivity, edgetint) to convert between the conductor index of refraction and its artist-friendly parametrization. Use conductor_eta(name) to get tabulated index of refractions for conductors. // approximate Fresnel for dielectric and conductors auto reflectivity1 = vec3f { 0.04 , 0.04 , 0.04 }; // dielectric reflectivity auto reflectivity2 = vec3f { 0.80 , 0.70 , 0.90 }; // conductor reflectivity auto fs1 = fresnel_schlick ( reflectivity_d , normal , outgoing ); auto fs1 = fresnel_schlick ( reflectivity_c , normal , outgoing ); // accurate Fresnel for dielectrics auto ior1 = vec3f { 1.5 , 1.5 , 1.5 }; // dielectric ior auto fd1 = fresnel_dielectric ( ior_d , normal , outgoing ); auto ior2 = reflectivity_to_eta ( reflectivity1 ); // reflectivity to ior // accurate Fresnel for conductors { \"Au\" , {{ 0.1431189557f , 0.3749570432f , 1.4424785571f }, { 3.9831604247f , 2.3857207478f , 1.6032152899f }}}, auto eta1 = vec3f { 0.143 , 0.375 , 1.442 }; // conductor complex ior auto etak1 = vec3f { 3.983 , 2.386 , 1.603 }; // conductor complex ior auto fc1 = fresnel_conductor ( eta1 , etak1 , normal , outgoing ); auto [ eta2 , etak2 ] = edgetint_to_eta ( reflectivity2 , vec3f {...}); // refl. to ior auto [ eta3 , etak3 ] = conductor_eta ( \"Au\" ); // get gold eta Most shaders today use some version of microfacet lobes for reflections and transmissions. Yocto/Shading has several functions to simplify writing those shaders. Use microfacet_distribution(roughness, normal, halfway, ggx) to evaluate the microfacet distribution and microfacet_shadowing(roughness, normal, halfway, ggx) to evaluate the shadow-masking term. Both functions take the surface roughness, the shading normal, the halfway vector and whether or not to use the GGX or Beckman distribution. Yocto/Shading also supports generating directions according to the microfacet distribution, both for GGX and Beckman. Use sample_microfacet(roughness, normal, rn, ggx) to generate halfway vector with distribution proportional to the microfacet distribution function and sample_microfacet(roughness, normal, outgoing, rn, ggx) to generate dictions using the distribution of visible normals. Use sample_microfacet_pdf(roughness, normal, halfway, ggx) or sample_microfacet_pdf(roughness, normal, halfway, outgoing, ggx) to compute the PDF for each sampling routine. auto normal = vec3f {...}; // shading normal auto incoming = vec3f {...} // incoming direction auto outgoing = vec3f {...}; // outgoing direction auto halfway = normalize ( incoming , outgoing ); // halfway vector reflection auto D = microfacet_distribution ( roughness , normal , halfway ); // distribution auto G = microfacet_shadowing ( roughness , normal , halfway ); // shadowing auto halfway1 = sample_microfacet ( roughness , normal , rand2f ( rng )); // sample auto pdf = sample_microfacet_pdf ( roughness , normal , halfway1 ); // sample pdf","title":"Shading utilities"},{"location":"yocto/yocto_shading/#bsdf-lobes","text":"Most path tracing shaders are defined as sum of single BSDF lobes. Yocto/Shading provides and implementation for several common BSDF lobes. Three functions are implemented for each lobe. Use eval_<lobe>(<params>, normal, outgoing, incoming) to evaluates the lobe BSDF multiplied by the cosine, sample_<lobe>(<params>, normal, outgoing, rn) to sample an incoming direction, and sample_<lobe>_pdf(<params>, normal, outgoing, incoming) to compute the sampled direction pdf. Yocto/Shading supports the following lobes: diffuse_reflection : diffuse brdf diffuse_transmission : translucency brdf, as a flipped diffuse microfacet_reflection : specular brdf for dielectrics and metals microfacet_transmission : transmission brdf for thin dielectrics microfacet_refraction : refraction brdf for dielectrics, includes reflection and refraction delta_reflection : delta specular for dielectrics and metals delta_transmission : delta transmission for thin dielectrics delta_refraction : delta refraction for dielectrics auto normal = vec3f {...}; // shading normal auto incoming = vec3f {...} // incoming direction auto outgoing = vec3f {...}; // outgoing direction auto rs = float { 0.1 }; // roughness auto ior = float { 1.5 }; // dielectric ior auto [ eta , etak ] = conductor_eta ( \"Au\" ); // conductor complex ior // evaluate smooth lobes auto b1 = eval_diffuse_reflection ( normal , outgoing , incoming ); auto b2 = eval_diffuse_transmission ( normal , outgoing , incoming ); auto b3 = eval_microfacet_reflection ( ior , rs , normal , outgoing , incoming ); auto b4 = eval_microfacet_reflection ( eta , etak , rs , normal , outgoing , incoming ); auto b5 = eval_microfacet_transmission ( ior , rs , normal , outgoing , incoming ); auto b6 = eval_microfacet_refraction ( ior , rs , normal , outgoing , incoming ); // sample smooth lobes auto incoming1 = sample_diffuse_reflection ( normal , outgoing , rand2f ( rng )); auto pdf1 = sample_diffuse_reflection_pdf ( normal , outgoing , incoming ) // eval and sample delta lobes auto incoming2 = sample_delta_reflection ( ior , normal , outgoing ); auto b7 = eval_delta_reflection ( ior , normal , outgoing , incoming );","title":"Bsdf lobes"},{"location":"yocto/yocto_shading/#volumetric-lobes","text":"Yocto/Shading defines functions to simplify the implementation of volumetric effects. Use eval_transmittance(density, distance) to evaluate the transmittance of a homogeneous volume, sample_transmittance(density, max_distance, rn) to sample a distance inside an homogeneous medium, sample_transmittance_pdf(density, distance, max_distance) to compute the pdf of the sampled distance. The sampling function may return a distance equal to max distance, in which case the ray has exited the medium. Use mfp_to_transmission(mfp, depth) to convert mean-free-path to transmission at a specific depth. auto density = vec3f { 0.99 , 0.99 , 0.99 }; // medium density auto max_distance = float { 1 }; // maximum distance inside the medium auto distance = sample_transmittance ( density , max_distance , // sample distance rand1f ( rng ), rand1f ( rng )); auto pdf = sample_transmittance_pdf ( density , distance , max_distance ) // pdf auto transmittance = eval_transmittance ( density , distance ); Use eval_phasefunction(anisotropy, outgoing, incoming) to evaluate the HG phase function, sample_phasefunction(anisotropy, outgoing, rn) to sample a direction according to the phse function, sample_phasefunction_pdf(anisotropy, outgoing, incoming) to compute the pdf of the sampled direction. auto outgoing = vec3f {...}; // outgoing direction auto anisotropy = float { 0 }; // isotropic phase function auto incoming = sample_phasefunction ( anisotropy , outgoing , rand2f ( rng )); auto phasefunc = eval_phasefunction ( anisotropy , outgoing , incoming ); auto pdf = sample_phasefunction_pdf ( anisotropy , outgoing , incoming );","title":"Volumetric lobes"},{"location":"yocto/yocto_shape/","text":"Yocto/Shape: Shape utilities Yocto/Shape is a collection of utilities for manipulating shapes in 3D graphics, with a focus on triangle and quad meshes. Yocto/Shape is implemented in yocto_shape.h and yocto_shape.cpp . Shape representation Yocto/Shape supports shapes defined as collection of either points, lines, triangles and quads. Most functions have overrides for all element types when appropriate. Shapes are represented as indexed meshes, with arbitrary properties for each vertex. Each vertex property is stored as a separate array, and shape elements are stored as arrays of indices to faces. For element parametrization, we follow Yocto/Geometry . Vertex data is stored as vector<vecXf> , while element indices are stored as vector<vec3i> , vector<vec4i> , vector<vec2i> , vector<int> for triangle meshes, quad meshes, line sets and point sets respectively. auto triangles = vector < vec3i > {...}; // triangle indices auto positions = vector < vec3f > {...}; // vertex positions auto texcoords = vector < vec2f > {...}; // vertex uvs Face-varying shapes are also supported by specifying separate element indices for each vertex property, with arrays of vertex properties possibly of different length. This makes sure that any topology can be represented. For now, only face-varying quads are supported. auto quadspos = vector < vec4i > {...}; // quads indices for positions auto positions = vector < vec3f > {...}; // vertex positions auto quadstexcoords = vector < vec4i > {...}; // quads indices for uvs auto texcoords = vector < vec2f > {...}; // vertex uvs Throughout the library, functions may either take index and vertex arrays directly as input and output, or may pack these array in structs if deemed appropriate. This design tries to balance readability and generality, without forcing a single convention that would not be appropriate everywhere. Vertex properties Yocto/Shape provides many facilities to compute vertex properties for indexed elements. Use compute_normals(...) to compute vertex normals for triangle and quad meshes, and compute_tangents(...) for line tangents. Use compute_skinning(...) to apply linear-blend skinning. Use compute_tangents_spaces(...) to compute tangents spaces for each ech meshes. auto triangles = vector < vec3i > {...}; // triangle indices auto positions = vector < vec3f > {...}; // vertex positions auto texcoords = vector < vec2f > {...}; // vertex uvs auto normals = compute_normals ( triangles , positions ); // vertex normals auto tangsp = compute_tangent_spaces ( triangles , positions , normals , texcoords ); auto weights = vector < vec4f > {...}; // skinning weights for 4 bones per vertex auto joints = vector < vec4i > {...}; // bine indices for 4 bones per vertex auto frames = vector < frame3f > {...}; // bone frames auto [ skinned_pos , skinned_norm ] = compute_skinning ( positions , normals , weights , joints , frames ); // skinned positions ans normals Flipping and aligning Yocto/Shape provides functions to correct shapes that have inconsistent orientations or normals. Use flip_normals(normals) to flip all mesh normals. Use flip_triangles(triangles) and flip_quads(quads) to change face orientations. Use align_vertices(positions,alignment) to align vertex positions to the main axes. auto triangles = vector < vec3i > {...}; // triangle indices auto positions = vector < vec3f > {...}; // vertex positions auto normals = vector < vec3f > {...}; // vertex normals triangles = flip_triangles ( triangles ); // flip faces normals = flip_normals ( normals ); // flip normals // align positions to the origin along the y axis only positions = align_vertices ( positions , { 0 , 1 , 0 }); Edges and adjacencies Use get_edges(triangles) amd get_edges(quads) to get a list of unique edges for a triangle or quads mesh. auto triangles = vector < vec3i > {...}; // triangle indices auto edges = get_edges ( triangles ); // edge indices Internally, these functions use an edge_map , that is a dictionary that has pairs of vertex ids as keys and an edge index as value. Two opposing half-edges have the same representation in an edge_map , making it useful in tesselation algorithms to avoid cracks. In Yocto/Shape, edge maps also stores the number of incident faces per edge, so that we can determine which edges belong to the boundary. auto triangles = vector < vec3i > {...}; // triangle indices auto emap = make_edge_map ( triangles ); // edge map auto edges = get_edges ( emap ); // edge indices for ( auto & edge : edges ) // iterate over edges print ( edge_index ( emap , edge )); // get edge indices auto boundary = get_boundary ( emap ); // get unsorted boundary edges Ray-intersection and point-overlap Yocto/Shape provides ray-scene intersection for points, lines, triangles and quads accelerated by a BVH data structure. Our BVH is written for minimal code and not maximum speed, but still gives fast-enough results. See Yocto/Geometry for intersection parametrization. The BVH tree is stored in a bvh_tree struct. The tree stored an array of nodes and an array of element indices. Each node in the tree has references to either other nodes or elements. References are represented as indices in the nodes or elements arrays. Nodes indices refer to the nodes array, for internal nodes, or the element arrays, for leaf nodes. The BVH does not store shape data, which is instead passed explicitly to all calls. BVH nodes contain their bounds, indices to the BVH arrays of either primitives or internal nodes, node element type, and the split axis. Leaf and internal nodes are identical, except that indices refer to primitives for leaf nodes or other nodes for internal nodes. The BVH is initialized with make_triangles_bvh(bvh,triangles,positions) for triangles, make_quads_bvh(bvh,quads,positions) for quads, make_lines_bvh(bvh,lines,positions,radius) for lines, and make_points_bvh(bvh,points,positions,radius) for points. auto triangles = vector < vec3i > {...}; // mesh data auto positions = vector < vec3f > {...}; auto bvh = make_triangles_bvh ( triangles , positions ); // BVH construction Intersect and overlap functions return a bvh_intersection that bundles the intersection distance, the intersected element index and uvs, and a hit flag that signals whether an element was hit. intersect_<element>_bvh(...) computed intersections between rays and shapes. Use intersect_triangles_bvh(bvh,triangles,positions, ray) for triangles, intersect_quads_bvh(bvh,quads,positions) for quads, intersect_lines_bvh(bvh,lines,positions,radius,ray) for lines, and intersect_points_bvh(bvh,points,positions,radius,ray) for points. auto ray = ray3f {...}; // computes ray-triangles intersection auto isec = intersect_triangles_bvh ( bvh , triangles , positions , ray ); if ( isec . hit ) print_info ( isec . element , isec . uv , isec . distance ); else print_info ( \"no hit\" ); overlap_<element>_bvh(...) checks whether a shape overlaps a point within a given maximum distance and returns the distance, element and uv of the closest element. Use overlap_triangles_bvh(bvh, triangles, positions, ray) for triangles, overlap_quads_bvh(bvh, quads, positions) for quads, overlap_lines_bvh(bvh, lines, positions, radius, ray) for lines, and overlap_points_bvh(bvh, points, positions, radius, ray) for points. auto pt = vec3f {...}; auto max_dist = float {...}; // comnpute point-triangles overlap auto ovr = overlap_triangles_bvh ( bvh , triangles , positions , pt , mat_dist ); if ( ovr . hit ) print_info ( ovrl . element , ovrl . uv , ovrl . distance ); else print_info ( \"no overlap\" ); If vertices have moved little, BVHs can be updated instead of fully rebuild. Use update_triangles_bvh(bvh, triangles, positions) for triangles, update_quads_bvh(bvh, quads, positions) for quads, update_lines_bvh(bvh, lines, positions, radius) for lines, and update_points_bvh(bvh, points, positions, radius) for points. positions [...] = {...}; // update positions update_triangles_bvh ( bvh , triangles , positions ); // update BVH Nearest neighbors Nearest neighbors queries are computed by building a sparse hash grid defined as hash_grid . The grid is created by specifying a cell size for the underlying volumetric grid. Each cell stores the list of point indices that are present in that cell. To save memory, the grid is represented sparsely, using a dictionary, so that only cells with at least one vertex are defined. Initialize a hash grid with make_hash_grid(positions, size) . Use find_neighbors(grid, neighbors, position, max_radius) to find nearest neighbors. auto positions = vector < vec3f > {...}; // point positions auto grid = make_hash_grid ( positions , cell_size ); // create hash grid auto pt = vec3f {...}; auto max_dist = float {...}; // query point and dist auto neighbors = vector < int > {}; // neighbor buffer find_neighbors ( grid , neighbors , pt , max_dist ); // find neighbors by pos find_neighbors ( grid , neighbors , id , max_dist ); // find neighbors by id Element conversions and grouping Yocto/Shape support conversion between shape elements. Use quads_to_triangles(quads) to convert quads to triangles and triangles_to_quads(triangles) to convert triangles to degenerate quads. Use bezier_to_lines(lines) to convert B\u00e9zier segments to lines using three lines for each B\u00e9zier segment. auto quads = vector < vec4i > {...}; auto triangles = quads_to_triangles ( quads ); // convert quads to triangles Face-varying meshes are stored by having different face indices for each vertex propeerty. This way, every vertex property has its own topology. Use split_facevarying(...) to convert to an indexed mesh. During conversion vertices may be duplicated since the same topology is used for all vertex properties. auto fvquadspos = vector < vec4i > {...}; // face-varying indices auto fvquadsnorm = vector < vec4i > {...}; // arrays have some length auto fvquadstexcoord = vector < vec4i > {...}; auto fvpositions = vector < vec3f > {...}; // face-varying vertices auto fvnormals = vector < vec3f > {...}; // arrays may have different lengths auto fvtexcoords = vector < vec2f > {...}; auto [ quads , positions , normals , texcoords ] = // convert to indexed mesh split_facevarying ( fvquadspos , fvquadsnorm , fvquadstexcoord , fvpositions , fvnormals , fvtexcoords ); Yocto/Shape supports eliminating duplicate vertices in triangle and quad meshes. All vertices within a threshold are merged in a greedy fashion, which works well when duplicated vertices are near other while other vertices are further away. Use weld_triangles(triangles, positions, threshold) to eliminate duplicated triangle vertices and weld_quads(quads, positions, threshold) to eliminate duplicated quad vertices. For lower-level algorithms, use weld_vertices(positions, threshold) to group vertices together. auto triangles = vector < vec3i > {...}; // mesh data auto positions = vector < vec3f > {...}; auto tolerance = 0.1f ; auto [ mtriangles , mpositions ] = // remove duplicates weld_triangles ( triangles , positions , tolerance ); Yocto/Shape supports splitting shapes that are tagged by ids. This is helpful for example when drawing meshes that have per-face materials using renders that do support one material per shape only. Use ungroup_lines(lines,ids) , ungroud_triangles(triangles,ids) and ungroup_quads(quads,ids) for lines, triangles and quads respectively. auto triangles = vector < vec3i > {...}; // tagged mesh with one id per face auto ids = vector < int > {...}; auto split = ungroup_triangles ( triangles , ids ); // returns list of meshes Yocto/Shape supports merging shape elements. This is useful, for example, when building up shapes from parts. The merged shapes are just concatenation of the individual shape without vertex merging. Use merge_lines(...) for lines, merge_triangles(...) for triangles and merge_quads(...) for quads. auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto mtriangles = vector < vec3i > {...}; // shape to be merged auto mpositions = vector < vec3f > {...}; auto mnormals = vector < vec3f > {...}; auto mtexcoords = vector < vec2f > {...}; // merge mtriangles into triangles in-placee merge_triangles ( triangles , positions , normals , texcoords , mtriangles , mpositions , mnormals , mtexcoords ); You can also merge triangles and quads together in other to have one primitive only. Use merge_triangles_and_quads(triangles, quads, force_triangles) to merge elements in-place. The algorithms will output quads if present or triangles if not unless force_triangles is used. Shape subdivision Yocto/Shape defines functions to subdivide shape elements linearly, in order to obtain higher shape resolution, for example before applying displacement mapping. All functions will split all shape elements, regardless of their size. This ensures that meshes have no cracks. Use subdivide_lines(lines, vert, level) for lines, subdivide_triangles(triangles, vert, level) for triangles, subdivide_quads(quads, vert, level) for quads, and subdivide_bezier(beziers, vert, level) for Bezier segments. In this subdivision, each line is split in two lines, each triangle in three triangles, each quad in four quads, and each Bezier segment in two segments. The functions apply the subdivision rules level number of times and act on a single vertex property at a time for maximum flexibility. auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; // subdivide the triangle mesh recursively two times auto [ striangles , spositions ] = subdivide_triangles ( triangles , positions , 2 ); Yocto/Shape also supports Catmull-Clark subdivision surfaces with subdivide_catmullclark(quads, vert, level, creased) . In this case, Catmull-Clark subdivision rules are used to smooth the mesh after linear subdivision. The boundary can be treated as creases with creased , which is necessary when subdividing texture coordinates. auto quads = vector < vec4i > {...}; // initial shape auto positions = vector < vec3f > {...}; // subdivide the quad mesh recursively two times auto [ squads , spositions ] = subdivide_catmullclark ( quads , positions , 2 , false ); auto tquads = vector < vec4i > {...}; // face-varying shape with texture coords auto texcoords = vector < vec2f > {...}; // subdivide the triangle mesh recursively two times auto [ stquads , stexcoords ] = subdivide_catmullclark ( tquads , texcoords , 2 , true ); Shape sampling Yocto/Shape supports sampling meshes uniformly. All sampling require to first compute the shape CDF and then use it to sample the shape. For each shape type, the sampling functions return the shape element id and the element barycentric coordinates. Use sample_lines(cdf, re, rn) to sample lines, sample_triangles(cdf, re, rn) to sample triangles, sample_quads(cdf, re, rn) to sample quads. The shape CDFs are computed using sample_lines_dcf(lines, positions) , sample_triangles_dcf(triangles, positions) , and sample_quads_dcf(quads, positions) . auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; auto cdf = sample_triangles_cdf ( triangles , positions ); // shape cdf for ( auto sample : range ( samples )) { // sample the shape returning element id and uvs auto [ triangle_id , uv ] = sample_triangles ( cdf , rand1f ( rng ), rand2f ( rng )); } For triangles and quads, Yocto/Shape defines convenience functions that generate a set of points on the shape surface. Use sample_triangles(...) and sample_quads(...) for triangles and quads respectively. auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto sampled_positions = vector < vec3f > {...}; // sampled points auto sampled_normals = vector < vec3f > {...}; auto sampled_texcoords = vector < vec2f > {...}; // sample a set of npoints on the mesh auto npoints = 100 ; sample_triangles ( sampled_positions , sampled_normals , sampled_texcoords , triangles , positions , normals , texcoords , npoints ); Shape loading and saving Shapes are loaded with load_shape(filename, <shape data>, error, facevarying, flipv) and saved with save_shape(filename, <shape data>, error, facevarying, flipv) . Both loading and saving take a filename, and buffers for shape elements and vertex data, and return whether or not the shape was loaded or saved successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Yocto/Shape supports loading and saving to OBJ and PLY. The library has overrides for using separate arrays for each property or using a generic_shape struct that collects shape data for convenience. Yocto/Shape supports loading and saving shapes that are composed of either points, lines, triangles, quads or face-varying quads. For indexed meshes, the type of elements is determined during loading, while face-varying representations are requested by setting the facevarying flag in load and save functions. By default, texture coordinates are flipped vertically to match the convention of OpenGL texturing; this can be disabled by setting the flipv flag. Use shape_stats(<shape data>) to get statistics on the shape. auto error = string {}; auto shape = generic_shape {}; // shape data // interface using shape buffers if ( ! load_shape ( filename , shape , error )) // load shape print_error ( error ); // check and print error auto stats = shape_stats ( shape ); // shape stats for ( auto & stat : stats ) print_info ( stat ); // print stats if ( ! save_shape ( filename , shape , error )) // save shape print_error ( error ); // check and print error // interface using explicit buffers auto & [ points , lines , triangles , quads , quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , colors , radius ] = shape ; if ( ! load_shape ( filename , points , lines , triangles , quads , quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , colors , radius , error )) // load shape print_error ( error ); // check and print error auto stats = shape_stats ( points , lines , triangles , quads , quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , colors , radius ); // stats for ( auto & stat : stats ) print_info ( stat ); // print stats if ( ! save_shape ( filename , points , lines , triangles , quads , quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , colors , radius , error )) // save shape print_error ( error ); // check and print error // load using different conventions auto facevarying = true ; if ( ! load_shape ( filename , shape , error , facevarying )) // load face-varying shape print_error ( error ); // check and print error auto flipv = false ; if ( ! load_shape ( filename , shape , error , false , flipv )) // load flipping uvs print_error ( error ); // check and print error Procedural shapes Yocto/Shape defines several procedural shapes used for both testing and to quickly create shapes for procedural scenes. Procedural shapes as input the desired shape resolution, the shape scale, the uv scale, and additional parameters specific to that procedural shape. Most procedural shapes are defined in terms of quads and return quads indices and vertex positions, normals and texture coordinates packed in a quads_shape struct. Use make_rect(...) for a rectangle in the XY plane, make_bulged_rect(...) for a bulged rectangle, make_recty(...) for a rectangle in the XZ plane, make_bulged_recty(...) for a bulged rectangle in the XZ plane, make_box(...) for a box, make_rounded_box(...) for a rounded box, make_floor(...) for a floor in the XZ plane, make_bent_floor(...) for a bent floor, make_sphere(...) for a sphere obtained from a cube, make_uvsphere(...) for a sphere tessellated along its uvs, make_capped_uvsphere(...) for a sphere with flipped caps, make_disk(...) for a disk obtained from a quad, make_bulged_disk(...) for a bulged disk, make_uvdisk(...) for a disk tessellated along its uvs, make_uvcylinder(...) for a cylinder tessellated along its uvs, make_rounded_uvcylinder(...) for a rounded cylinder. // most procedural shapes return quads, positions, normals, and texcoords auto [ quads , positions , normals , texcoords ] = make_rect ({ 32 , 32 }, { 1 , 1 }); // make shapes with 32 steps in resolution and scale of 1 auto shape_01 = make_rect ({ 32 , 32 }, { 1 , 1 }); auto shape_02 = make_bilged_rect ({ 32 , 32 }, { 1 , 1 }); auto shape_03 = make_recty ({ 32 , 32 }, { 1 , 1 }); auto shape_04 = make_box ({ 32 , 32 , 32 }, { 1 , 1 , 1 }); auto shape_05 = make_rounded_box ({ 32 , 32 , 32 }, { 1 , 1 , 1 }); auto shape_06 = make_floor ({ 32 , 32 }, { 10 , 10 }); auto shape_07 = make_bent_floor ({ 32 , 32 }, { 10 , 10 }); auto shape_08 = make_sphere ( 32 , 1 ); auto shape_09 = make_uvsphere ({ 32 , 32 }, 1 ); auto shape_10 = make_capped_uvsphere ({ 32 , 32 }, 1 ); auto shape_11 = make_disk ( 32 , 1 ); auto shape_12 = make_bulged_disk ( 32 , 1 ); auto shape_13 = ake_uvdiskm ({ 32 , 32 }, 1 ); auto shape_14 = make_uvcylinder ({ 32 , 32 , 32 }, { 1 , 1 }); auto shape_15 = make_rounded_uvcylinder ({ 32 , 32 , 32 }, { 1 , 1 }); Yocto/Shape defines a few procedural face-varying shapes with similar interfaces to the above functions. In this case, the functions return face indices and vertex data for positions, normals and texture coordinates packed in a quads_fvshape struct. Use make_fvrect(...) for a rectangle in the XY plane, make_fvbox(...) for a box, make_fvsphere(...) for a sphere obtained from a cube. // procedural face-varying shapes return positions, normals, and texcoords auto [ quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords ] = make_fvrect ({ 32 , 32 }, { 1 , 1 }); // make face-varying shapes with 32 steps in resolution and scale of 1 auto fvshape_01 = make_fvrect ({ 32 , 32 }, { 1 , 1 }); auto fvshape_02 = make_fvbox ({ 32 , 32 , 32 }, { 1 , 1 , 1 }); auto fvshape_03 = make_fvsphere ( 32 , 1 ); Yocto/Shape provides functions to create predefined shapes helpful in testing. These functions take only a scale and often provide only the positions as vertex data. These functions return either triangles, quads, or face-varying quads. Use make_monkey(...) for the Blender monkey as quads and positions only, make_quad(...) for a simple quad, make_quady(...) for a simple quad in the XZ plane, make_cube(...) for a simple cube as quads and positions only, make_fvcube(...) for a simple face-varying unit cube, make_geosphere(...) for a geodesic sphere as triangles and positions only. auto monkey = make_monkey ( 1 ); auto quad = make_quad ( 1 ); auto quady = make_quady ( 1 ); auto cube = make_cube ( 1 ); auto geosph = make_geosphere ( 1 ); auto fvcube = make_fvcube ( 1 ); Yocto/Shape supports the generation of points and lines sets. Use make_lines(...) to create a line set in the XY plane, make_points(...) for a collection of points at the origin, adn make_random_points(...) for a point set randomly placed in a box. These functions return shapes that are defined in terms of lines or points and return lines or points indices, and vertex positions, normals, texture coordinates and radia, packed in a lines_shape or points_shape struct. // procedural lines return lines, positions, normals, texcoords, radia auto [ lines , positions , normals , texcoords , radius ] = make_lines ({ 4 , 65536 }); auto lines_01 = make_lines ({ 4 , 65536 }, // line steps and number of lines { 1 , 1 }, { 1 , 1 }, // line set scale and uvscale { 0.001 , 0.001 }); // radius at the bottom and top // procedural points return points, positions, normals, texcoords, radia auto [ points , positions , normals , texcoords , radius ] = make_points ( 65536 ); auto points_01 = make_points ( 65536 , // number of points 1 , // uvscale 0.001 ); // point radius auto points_02 = make_random_points ( 65536 , // number of points { 1 , 1 , 1 }, 1 , // line set scale and uvscale 0.001 ); // point radius Yocto/Shape also defines a simple function to generate randomized hairs on a triangle or quad mesh. Use make_hair(...) to create a hair shape from a triangle and quad mesh, and return a line set. // Make a hair ball around a shape auto [ lines , positions , normals , texcoords , radius ] = make_hair ( make_sphere (), // sampled surface { 8 , 65536 }, // steps: line steps and number of lines { 0.1 , 0.1 }, // length: minimum and maximum length { 0.001 , 0.001 }, // radius: minimum and maximum radius from base to tip { 0 , 10 }, // noise: noise added to hair (strength/scale) { 0 , 128 }, // clump: clump added to hair (strength/number) { 0 , 0 }); // rotation: rotation added to hair (angle/strength) Finally, Yocto/Shape defines a function to create a quad mesh from a heighfield. Use make_heightfield(...) to create a heightfield meshes. auto quads = vector < vec4i > {}; // shape element buffer auto positions = vector < vec3f > {}; // vertex data buffers auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto size = vec2i { 512 , 512 }; // heightfield size auto heightfield = vctor < float > {...}; // heightfield data make_heightfield ( quads , positions , normals , texcoords , size , heightfield ); // make heightfield mesh","title":"Shape utilities"},{"location":"yocto/yocto_shape/#yoctoshape-shape-utilities","text":"Yocto/Shape is a collection of utilities for manipulating shapes in 3D graphics, with a focus on triangle and quad meshes. Yocto/Shape is implemented in yocto_shape.h and yocto_shape.cpp .","title":"Yocto/Shape: Shape utilities"},{"location":"yocto/yocto_shape/#shape-representation","text":"Yocto/Shape supports shapes defined as collection of either points, lines, triangles and quads. Most functions have overrides for all element types when appropriate. Shapes are represented as indexed meshes, with arbitrary properties for each vertex. Each vertex property is stored as a separate array, and shape elements are stored as arrays of indices to faces. For element parametrization, we follow Yocto/Geometry . Vertex data is stored as vector<vecXf> , while element indices are stored as vector<vec3i> , vector<vec4i> , vector<vec2i> , vector<int> for triangle meshes, quad meshes, line sets and point sets respectively. auto triangles = vector < vec3i > {...}; // triangle indices auto positions = vector < vec3f > {...}; // vertex positions auto texcoords = vector < vec2f > {...}; // vertex uvs Face-varying shapes are also supported by specifying separate element indices for each vertex property, with arrays of vertex properties possibly of different length. This makes sure that any topology can be represented. For now, only face-varying quads are supported. auto quadspos = vector < vec4i > {...}; // quads indices for positions auto positions = vector < vec3f > {...}; // vertex positions auto quadstexcoords = vector < vec4i > {...}; // quads indices for uvs auto texcoords = vector < vec2f > {...}; // vertex uvs Throughout the library, functions may either take index and vertex arrays directly as input and output, or may pack these array in structs if deemed appropriate. This design tries to balance readability and generality, without forcing a single convention that would not be appropriate everywhere.","title":"Shape representation"},{"location":"yocto/yocto_shape/#vertex-properties","text":"Yocto/Shape provides many facilities to compute vertex properties for indexed elements. Use compute_normals(...) to compute vertex normals for triangle and quad meshes, and compute_tangents(...) for line tangents. Use compute_skinning(...) to apply linear-blend skinning. Use compute_tangents_spaces(...) to compute tangents spaces for each ech meshes. auto triangles = vector < vec3i > {...}; // triangle indices auto positions = vector < vec3f > {...}; // vertex positions auto texcoords = vector < vec2f > {...}; // vertex uvs auto normals = compute_normals ( triangles , positions ); // vertex normals auto tangsp = compute_tangent_spaces ( triangles , positions , normals , texcoords ); auto weights = vector < vec4f > {...}; // skinning weights for 4 bones per vertex auto joints = vector < vec4i > {...}; // bine indices for 4 bones per vertex auto frames = vector < frame3f > {...}; // bone frames auto [ skinned_pos , skinned_norm ] = compute_skinning ( positions , normals , weights , joints , frames ); // skinned positions ans normals","title":"Vertex properties"},{"location":"yocto/yocto_shape/#flipping-and-aligning","text":"Yocto/Shape provides functions to correct shapes that have inconsistent orientations or normals. Use flip_normals(normals) to flip all mesh normals. Use flip_triangles(triangles) and flip_quads(quads) to change face orientations. Use align_vertices(positions,alignment) to align vertex positions to the main axes. auto triangles = vector < vec3i > {...}; // triangle indices auto positions = vector < vec3f > {...}; // vertex positions auto normals = vector < vec3f > {...}; // vertex normals triangles = flip_triangles ( triangles ); // flip faces normals = flip_normals ( normals ); // flip normals // align positions to the origin along the y axis only positions = align_vertices ( positions , { 0 , 1 , 0 });","title":"Flipping and aligning"},{"location":"yocto/yocto_shape/#edges-and-adjacencies","text":"Use get_edges(triangles) amd get_edges(quads) to get a list of unique edges for a triangle or quads mesh. auto triangles = vector < vec3i > {...}; // triangle indices auto edges = get_edges ( triangles ); // edge indices Internally, these functions use an edge_map , that is a dictionary that has pairs of vertex ids as keys and an edge index as value. Two opposing half-edges have the same representation in an edge_map , making it useful in tesselation algorithms to avoid cracks. In Yocto/Shape, edge maps also stores the number of incident faces per edge, so that we can determine which edges belong to the boundary. auto triangles = vector < vec3i > {...}; // triangle indices auto emap = make_edge_map ( triangles ); // edge map auto edges = get_edges ( emap ); // edge indices for ( auto & edge : edges ) // iterate over edges print ( edge_index ( emap , edge )); // get edge indices auto boundary = get_boundary ( emap ); // get unsorted boundary edges","title":"Edges and adjacencies"},{"location":"yocto/yocto_shape/#ray-intersection-and-point-overlap","text":"Yocto/Shape provides ray-scene intersection for points, lines, triangles and quads accelerated by a BVH data structure. Our BVH is written for minimal code and not maximum speed, but still gives fast-enough results. See Yocto/Geometry for intersection parametrization. The BVH tree is stored in a bvh_tree struct. The tree stored an array of nodes and an array of element indices. Each node in the tree has references to either other nodes or elements. References are represented as indices in the nodes or elements arrays. Nodes indices refer to the nodes array, for internal nodes, or the element arrays, for leaf nodes. The BVH does not store shape data, which is instead passed explicitly to all calls. BVH nodes contain their bounds, indices to the BVH arrays of either primitives or internal nodes, node element type, and the split axis. Leaf and internal nodes are identical, except that indices refer to primitives for leaf nodes or other nodes for internal nodes. The BVH is initialized with make_triangles_bvh(bvh,triangles,positions) for triangles, make_quads_bvh(bvh,quads,positions) for quads, make_lines_bvh(bvh,lines,positions,radius) for lines, and make_points_bvh(bvh,points,positions,radius) for points. auto triangles = vector < vec3i > {...}; // mesh data auto positions = vector < vec3f > {...}; auto bvh = make_triangles_bvh ( triangles , positions ); // BVH construction Intersect and overlap functions return a bvh_intersection that bundles the intersection distance, the intersected element index and uvs, and a hit flag that signals whether an element was hit. intersect_<element>_bvh(...) computed intersections between rays and shapes. Use intersect_triangles_bvh(bvh,triangles,positions, ray) for triangles, intersect_quads_bvh(bvh,quads,positions) for quads, intersect_lines_bvh(bvh,lines,positions,radius,ray) for lines, and intersect_points_bvh(bvh,points,positions,radius,ray) for points. auto ray = ray3f {...}; // computes ray-triangles intersection auto isec = intersect_triangles_bvh ( bvh , triangles , positions , ray ); if ( isec . hit ) print_info ( isec . element , isec . uv , isec . distance ); else print_info ( \"no hit\" ); overlap_<element>_bvh(...) checks whether a shape overlaps a point within a given maximum distance and returns the distance, element and uv of the closest element. Use overlap_triangles_bvh(bvh, triangles, positions, ray) for triangles, overlap_quads_bvh(bvh, quads, positions) for quads, overlap_lines_bvh(bvh, lines, positions, radius, ray) for lines, and overlap_points_bvh(bvh, points, positions, radius, ray) for points. auto pt = vec3f {...}; auto max_dist = float {...}; // comnpute point-triangles overlap auto ovr = overlap_triangles_bvh ( bvh , triangles , positions , pt , mat_dist ); if ( ovr . hit ) print_info ( ovrl . element , ovrl . uv , ovrl . distance ); else print_info ( \"no overlap\" ); If vertices have moved little, BVHs can be updated instead of fully rebuild. Use update_triangles_bvh(bvh, triangles, positions) for triangles, update_quads_bvh(bvh, quads, positions) for quads, update_lines_bvh(bvh, lines, positions, radius) for lines, and update_points_bvh(bvh, points, positions, radius) for points. positions [...] = {...}; // update positions update_triangles_bvh ( bvh , triangles , positions ); // update BVH","title":"Ray-intersection and point-overlap"},{"location":"yocto/yocto_shape/#nearest-neighbors","text":"Nearest neighbors queries are computed by building a sparse hash grid defined as hash_grid . The grid is created by specifying a cell size for the underlying volumetric grid. Each cell stores the list of point indices that are present in that cell. To save memory, the grid is represented sparsely, using a dictionary, so that only cells with at least one vertex are defined. Initialize a hash grid with make_hash_grid(positions, size) . Use find_neighbors(grid, neighbors, position, max_radius) to find nearest neighbors. auto positions = vector < vec3f > {...}; // point positions auto grid = make_hash_grid ( positions , cell_size ); // create hash grid auto pt = vec3f {...}; auto max_dist = float {...}; // query point and dist auto neighbors = vector < int > {}; // neighbor buffer find_neighbors ( grid , neighbors , pt , max_dist ); // find neighbors by pos find_neighbors ( grid , neighbors , id , max_dist ); // find neighbors by id","title":"Nearest neighbors"},{"location":"yocto/yocto_shape/#element-conversions-and-grouping","text":"Yocto/Shape support conversion between shape elements. Use quads_to_triangles(quads) to convert quads to triangles and triangles_to_quads(triangles) to convert triangles to degenerate quads. Use bezier_to_lines(lines) to convert B\u00e9zier segments to lines using three lines for each B\u00e9zier segment. auto quads = vector < vec4i > {...}; auto triangles = quads_to_triangles ( quads ); // convert quads to triangles Face-varying meshes are stored by having different face indices for each vertex propeerty. This way, every vertex property has its own topology. Use split_facevarying(...) to convert to an indexed mesh. During conversion vertices may be duplicated since the same topology is used for all vertex properties. auto fvquadspos = vector < vec4i > {...}; // face-varying indices auto fvquadsnorm = vector < vec4i > {...}; // arrays have some length auto fvquadstexcoord = vector < vec4i > {...}; auto fvpositions = vector < vec3f > {...}; // face-varying vertices auto fvnormals = vector < vec3f > {...}; // arrays may have different lengths auto fvtexcoords = vector < vec2f > {...}; auto [ quads , positions , normals , texcoords ] = // convert to indexed mesh split_facevarying ( fvquadspos , fvquadsnorm , fvquadstexcoord , fvpositions , fvnormals , fvtexcoords ); Yocto/Shape supports eliminating duplicate vertices in triangle and quad meshes. All vertices within a threshold are merged in a greedy fashion, which works well when duplicated vertices are near other while other vertices are further away. Use weld_triangles(triangles, positions, threshold) to eliminate duplicated triangle vertices and weld_quads(quads, positions, threshold) to eliminate duplicated quad vertices. For lower-level algorithms, use weld_vertices(positions, threshold) to group vertices together. auto triangles = vector < vec3i > {...}; // mesh data auto positions = vector < vec3f > {...}; auto tolerance = 0.1f ; auto [ mtriangles , mpositions ] = // remove duplicates weld_triangles ( triangles , positions , tolerance ); Yocto/Shape supports splitting shapes that are tagged by ids. This is helpful for example when drawing meshes that have per-face materials using renders that do support one material per shape only. Use ungroup_lines(lines,ids) , ungroud_triangles(triangles,ids) and ungroup_quads(quads,ids) for lines, triangles and quads respectively. auto triangles = vector < vec3i > {...}; // tagged mesh with one id per face auto ids = vector < int > {...}; auto split = ungroup_triangles ( triangles , ids ); // returns list of meshes Yocto/Shape supports merging shape elements. This is useful, for example, when building up shapes from parts. The merged shapes are just concatenation of the individual shape without vertex merging. Use merge_lines(...) for lines, merge_triangles(...) for triangles and merge_quads(...) for quads. auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto mtriangles = vector < vec3i > {...}; // shape to be merged auto mpositions = vector < vec3f > {...}; auto mnormals = vector < vec3f > {...}; auto mtexcoords = vector < vec2f > {...}; // merge mtriangles into triangles in-placee merge_triangles ( triangles , positions , normals , texcoords , mtriangles , mpositions , mnormals , mtexcoords ); You can also merge triangles and quads together in other to have one primitive only. Use merge_triangles_and_quads(triangles, quads, force_triangles) to merge elements in-place. The algorithms will output quads if present or triangles if not unless force_triangles is used.","title":"Element conversions and grouping"},{"location":"yocto/yocto_shape/#shape-subdivision","text":"Yocto/Shape defines functions to subdivide shape elements linearly, in order to obtain higher shape resolution, for example before applying displacement mapping. All functions will split all shape elements, regardless of their size. This ensures that meshes have no cracks. Use subdivide_lines(lines, vert, level) for lines, subdivide_triangles(triangles, vert, level) for triangles, subdivide_quads(quads, vert, level) for quads, and subdivide_bezier(beziers, vert, level) for Bezier segments. In this subdivision, each line is split in two lines, each triangle in three triangles, each quad in four quads, and each Bezier segment in two segments. The functions apply the subdivision rules level number of times and act on a single vertex property at a time for maximum flexibility. auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; // subdivide the triangle mesh recursively two times auto [ striangles , spositions ] = subdivide_triangles ( triangles , positions , 2 ); Yocto/Shape also supports Catmull-Clark subdivision surfaces with subdivide_catmullclark(quads, vert, level, creased) . In this case, Catmull-Clark subdivision rules are used to smooth the mesh after linear subdivision. The boundary can be treated as creases with creased , which is necessary when subdividing texture coordinates. auto quads = vector < vec4i > {...}; // initial shape auto positions = vector < vec3f > {...}; // subdivide the quad mesh recursively two times auto [ squads , spositions ] = subdivide_catmullclark ( quads , positions , 2 , false ); auto tquads = vector < vec4i > {...}; // face-varying shape with texture coords auto texcoords = vector < vec2f > {...}; // subdivide the triangle mesh recursively two times auto [ stquads , stexcoords ] = subdivide_catmullclark ( tquads , texcoords , 2 , true );","title":"Shape subdivision"},{"location":"yocto/yocto_shape/#shape-sampling","text":"Yocto/Shape supports sampling meshes uniformly. All sampling require to first compute the shape CDF and then use it to sample the shape. For each shape type, the sampling functions return the shape element id and the element barycentric coordinates. Use sample_lines(cdf, re, rn) to sample lines, sample_triangles(cdf, re, rn) to sample triangles, sample_quads(cdf, re, rn) to sample quads. The shape CDFs are computed using sample_lines_dcf(lines, positions) , sample_triangles_dcf(triangles, positions) , and sample_quads_dcf(quads, positions) . auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; auto cdf = sample_triangles_cdf ( triangles , positions ); // shape cdf for ( auto sample : range ( samples )) { // sample the shape returning element id and uvs auto [ triangle_id , uv ] = sample_triangles ( cdf , rand1f ( rng ), rand2f ( rng )); } For triangles and quads, Yocto/Shape defines convenience functions that generate a set of points on the shape surface. Use sample_triangles(...) and sample_quads(...) for triangles and quads respectively. auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto sampled_positions = vector < vec3f > {...}; // sampled points auto sampled_normals = vector < vec3f > {...}; auto sampled_texcoords = vector < vec2f > {...}; // sample a set of npoints on the mesh auto npoints = 100 ; sample_triangles ( sampled_positions , sampled_normals , sampled_texcoords , triangles , positions , normals , texcoords , npoints );","title":"Shape sampling"},{"location":"yocto/yocto_shape/#shape-loading-and-saving","text":"Shapes are loaded with load_shape(filename, <shape data>, error, facevarying, flipv) and saved with save_shape(filename, <shape data>, error, facevarying, flipv) . Both loading and saving take a filename, and buffers for shape elements and vertex data, and return whether or not the shape was loaded or saved successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Yocto/Shape supports loading and saving to OBJ and PLY. The library has overrides for using separate arrays for each property or using a generic_shape struct that collects shape data for convenience. Yocto/Shape supports loading and saving shapes that are composed of either points, lines, triangles, quads or face-varying quads. For indexed meshes, the type of elements is determined during loading, while face-varying representations are requested by setting the facevarying flag in load and save functions. By default, texture coordinates are flipped vertically to match the convention of OpenGL texturing; this can be disabled by setting the flipv flag. Use shape_stats(<shape data>) to get statistics on the shape. auto error = string {}; auto shape = generic_shape {}; // shape data // interface using shape buffers if ( ! load_shape ( filename , shape , error )) // load shape print_error ( error ); // check and print error auto stats = shape_stats ( shape ); // shape stats for ( auto & stat : stats ) print_info ( stat ); // print stats if ( ! save_shape ( filename , shape , error )) // save shape print_error ( error ); // check and print error // interface using explicit buffers auto & [ points , lines , triangles , quads , quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , colors , radius ] = shape ; if ( ! load_shape ( filename , points , lines , triangles , quads , quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , colors , radius , error )) // load shape print_error ( error ); // check and print error auto stats = shape_stats ( points , lines , triangles , quads , quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , colors , radius ); // stats for ( auto & stat : stats ) print_info ( stat ); // print stats if ( ! save_shape ( filename , points , lines , triangles , quads , quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , colors , radius , error )) // save shape print_error ( error ); // check and print error // load using different conventions auto facevarying = true ; if ( ! load_shape ( filename , shape , error , facevarying )) // load face-varying shape print_error ( error ); // check and print error auto flipv = false ; if ( ! load_shape ( filename , shape , error , false , flipv )) // load flipping uvs print_error ( error ); // check and print error","title":"Shape loading and saving"},{"location":"yocto/yocto_shape/#procedural-shapes","text":"Yocto/Shape defines several procedural shapes used for both testing and to quickly create shapes for procedural scenes. Procedural shapes as input the desired shape resolution, the shape scale, the uv scale, and additional parameters specific to that procedural shape. Most procedural shapes are defined in terms of quads and return quads indices and vertex positions, normals and texture coordinates packed in a quads_shape struct. Use make_rect(...) for a rectangle in the XY plane, make_bulged_rect(...) for a bulged rectangle, make_recty(...) for a rectangle in the XZ plane, make_bulged_recty(...) for a bulged rectangle in the XZ plane, make_box(...) for a box, make_rounded_box(...) for a rounded box, make_floor(...) for a floor in the XZ plane, make_bent_floor(...) for a bent floor, make_sphere(...) for a sphere obtained from a cube, make_uvsphere(...) for a sphere tessellated along its uvs, make_capped_uvsphere(...) for a sphere with flipped caps, make_disk(...) for a disk obtained from a quad, make_bulged_disk(...) for a bulged disk, make_uvdisk(...) for a disk tessellated along its uvs, make_uvcylinder(...) for a cylinder tessellated along its uvs, make_rounded_uvcylinder(...) for a rounded cylinder. // most procedural shapes return quads, positions, normals, and texcoords auto [ quads , positions , normals , texcoords ] = make_rect ({ 32 , 32 }, { 1 , 1 }); // make shapes with 32 steps in resolution and scale of 1 auto shape_01 = make_rect ({ 32 , 32 }, { 1 , 1 }); auto shape_02 = make_bilged_rect ({ 32 , 32 }, { 1 , 1 }); auto shape_03 = make_recty ({ 32 , 32 }, { 1 , 1 }); auto shape_04 = make_box ({ 32 , 32 , 32 }, { 1 , 1 , 1 }); auto shape_05 = make_rounded_box ({ 32 , 32 , 32 }, { 1 , 1 , 1 }); auto shape_06 = make_floor ({ 32 , 32 }, { 10 , 10 }); auto shape_07 = make_bent_floor ({ 32 , 32 }, { 10 , 10 }); auto shape_08 = make_sphere ( 32 , 1 ); auto shape_09 = make_uvsphere ({ 32 , 32 }, 1 ); auto shape_10 = make_capped_uvsphere ({ 32 , 32 }, 1 ); auto shape_11 = make_disk ( 32 , 1 ); auto shape_12 = make_bulged_disk ( 32 , 1 ); auto shape_13 = ake_uvdiskm ({ 32 , 32 }, 1 ); auto shape_14 = make_uvcylinder ({ 32 , 32 , 32 }, { 1 , 1 }); auto shape_15 = make_rounded_uvcylinder ({ 32 , 32 , 32 }, { 1 , 1 }); Yocto/Shape defines a few procedural face-varying shapes with similar interfaces to the above functions. In this case, the functions return face indices and vertex data for positions, normals and texture coordinates packed in a quads_fvshape struct. Use make_fvrect(...) for a rectangle in the XY plane, make_fvbox(...) for a box, make_fvsphere(...) for a sphere obtained from a cube. // procedural face-varying shapes return positions, normals, and texcoords auto [ quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords ] = make_fvrect ({ 32 , 32 }, { 1 , 1 }); // make face-varying shapes with 32 steps in resolution and scale of 1 auto fvshape_01 = make_fvrect ({ 32 , 32 }, { 1 , 1 }); auto fvshape_02 = make_fvbox ({ 32 , 32 , 32 }, { 1 , 1 , 1 }); auto fvshape_03 = make_fvsphere ( 32 , 1 ); Yocto/Shape provides functions to create predefined shapes helpful in testing. These functions take only a scale and often provide only the positions as vertex data. These functions return either triangles, quads, or face-varying quads. Use make_monkey(...) for the Blender monkey as quads and positions only, make_quad(...) for a simple quad, make_quady(...) for a simple quad in the XZ plane, make_cube(...) for a simple cube as quads and positions only, make_fvcube(...) for a simple face-varying unit cube, make_geosphere(...) for a geodesic sphere as triangles and positions only. auto monkey = make_monkey ( 1 ); auto quad = make_quad ( 1 ); auto quady = make_quady ( 1 ); auto cube = make_cube ( 1 ); auto geosph = make_geosphere ( 1 ); auto fvcube = make_fvcube ( 1 ); Yocto/Shape supports the generation of points and lines sets. Use make_lines(...) to create a line set in the XY plane, make_points(...) for a collection of points at the origin, adn make_random_points(...) for a point set randomly placed in a box. These functions return shapes that are defined in terms of lines or points and return lines or points indices, and vertex positions, normals, texture coordinates and radia, packed in a lines_shape or points_shape struct. // procedural lines return lines, positions, normals, texcoords, radia auto [ lines , positions , normals , texcoords , radius ] = make_lines ({ 4 , 65536 }); auto lines_01 = make_lines ({ 4 , 65536 }, // line steps and number of lines { 1 , 1 }, { 1 , 1 }, // line set scale and uvscale { 0.001 , 0.001 }); // radius at the bottom and top // procedural points return points, positions, normals, texcoords, radia auto [ points , positions , normals , texcoords , radius ] = make_points ( 65536 ); auto points_01 = make_points ( 65536 , // number of points 1 , // uvscale 0.001 ); // point radius auto points_02 = make_random_points ( 65536 , // number of points { 1 , 1 , 1 }, 1 , // line set scale and uvscale 0.001 ); // point radius Yocto/Shape also defines a simple function to generate randomized hairs on a triangle or quad mesh. Use make_hair(...) to create a hair shape from a triangle and quad mesh, and return a line set. // Make a hair ball around a shape auto [ lines , positions , normals , texcoords , radius ] = make_hair ( make_sphere (), // sampled surface { 8 , 65536 }, // steps: line steps and number of lines { 0.1 , 0.1 }, // length: minimum and maximum length { 0.001 , 0.001 }, // radius: minimum and maximum radius from base to tip { 0 , 10 }, // noise: noise added to hair (strength/scale) { 0 , 128 }, // clump: clump added to hair (strength/number) { 0 , 0 }); // rotation: rotation added to hair (angle/strength) Finally, Yocto/Shape defines a function to create a quad mesh from a heighfield. Use make_heightfield(...) to create a heightfield meshes. auto quads = vector < vec4i > {}; // shape element buffer auto positions = vector < vec3f > {}; // vertex data buffers auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto size = vec2i { 512 , 512 }; // heightfield size auto heightfield = vctor < float > {...}; // heightfield data make_heightfield ( quads , positions , normals , texcoords , size , heightfield ); // make heightfield mesh","title":"Procedural shapes"},{"location":"yocto/yocto_trace/","text":"Yocto/Trace: Path tracing Yocto/Trace is a simple path tracer written on the Yocto/Scene model. Yocto/Trace is implemented in yocto_trace.h and yocto_trace.cpp . Rendering features Yocto/Trace uses the Yocto/Scene model to represent scene data. Consult the scene documentation for a detailed description of the scene data model. Yocto/Trace supports rendering of shapes represented as indexed meshes of points, lines, triangles and quads. The renderer use instancing throughout to gain scalability with large environment, while still remaining easy to use. Materials are modeled similarly to the Disney's BSDF with integrated subsurface scattering. Lights are not specified explicitly but derived by the renderer from emissive surface and environment maps in the scene. Yocto/Trace implements a fast but simple path tracer. The algorithm uses relatively advanced sampling features to reduce the numbers of rays used to render an image. At the same time, we focus on general solutions that work well in all cases, instead of tuning the algorithm to work well in some specific cases. Yocto/Trace is a progressively path tracer that computes images a few samples at a time. This is true for both offline and online rendering. This design allows for partial images to be used to give feedback before the render is finished. In the future, this might allow for more rendering features like adaptive rendering or stop-and-resume renders. Rendering a scene To render a scene, first initialize the scene bvh and lights, with init_bvh(scene, params, progress) and init_lights(scene, params, progress) and then call trace_image(scene, camera, params, progress, image_progress) . In these functions, params are thee rendering options used to render the scene, progress is a callback function used to report rendering progress and image_progress is a callback function used to report partial images during rendering. Both callback functions are optional. auto scene = new scene_model {...}; // initialize scene auto params = trace_params {}; // default params auto progress = []( const string & message , // progress callback int current , int total ) { print_info ( message , current , total ); }; init_bvh ( scene , params , progress ); // init bvh init_lights ( scene , params , progress ); // init lights trace_image ( scene , params , progress ); // render image auto improgress = []( const image < vec4f >& render , // image progress int sample , int samples ) { if ( sample % 16 == 0 ) // every 16 samples save_image ( filename , render ); // save image }; trace_image ( scene , params , progress , improgress ); // render image Rendering options The rendering process is configured with the trace_params settings. sampler determines the algorithm used for rendering: path is the default algorithm and probably the one you want to use, naive is a simpler path tracing that may be used for testing, eyelight produces quick previews of the screen geometry, falsecolor is a debug feature to view scenes according to the falsecolor setting, and albedo and normal are used to produce denoising buffers. THe image resolution is set by resolution and measures the resolution of the longest axis. samples is the number of per-pixel samples used while rendering and is the only parameter used to control the tradeoff between noise and speed. bounces is the maximum number of bounces and should be high for scenes with glass and volumes, but otherwise a low number would suffice. The remaining parameters are approximation used to reduce noise, at the expenses of bias. clamp remove high-energy fireflies. nocaustics removes certain path that cause caustics. tentfilter apply a linear filter to the image pixels. envhidden removes the environment map from the camera rays. Finally, the bvh parameter controls the heuristic used to build the Bvh and whether the Bvh uses Embree. Please see the description in Yocto/Scene. trace_sampler_names , trace_falsecolor_names and trace_bvh_names define string names for various enum values that can used for UIs or CLIs. // high quality rendering auto hq_params = trace_params {}; // default params hq_params . sampler = trace_sampler_type :: path ; // path tracing hq_params . resolution = 1280 ; // high-res render hq_params . samples = 1024 ; // high-sample count hq_params . bounce = 64 ; // high max bounces // geometry previewing auto pp_params = trace_params {}; // default params pp_params . sampler = trace_sampler_type :: eyelight ; // geometry preview pp_params . resolution = 720 ; // medium-res render pp_params . samples = 16 ; // low-sample count // scene debug viewing auto db_params = trace_params {}; // default params db_params . sampler = trace_sampler_type :: falsecolor ; // debug false colors db_params . falsecolor = trace_falsecolor_type :: normal ; // normal viewing db_params . resolution = 720 ; // medium-res render db_params . samples = 16 ; // low-sample count Experimental async rendering The render can run in asynchronous mode where the rendering process is lunched and runs until completion. This mode is useful when for interactive viewing or in modeling-while-rendering applications. The API is very minimal and only controls the rendering process. Use trace_start(...) to start the async renderer and trace_stop(...) to stop it. The renderer starts by rendering a low resolution preview and then proceeds progressively. The async renderer takes a trace_state struct that tracks the rendering process and contains all data needed by the async renderer. Rendering progress ifs given by three callbacks. The first two are the rendering callbacks defined for offline rendeirng, that return progress report and an image buffer for each sample. In async mode, a further callback is called after each pixel is rendered. During rendering, no scenes changes are allowed, and changes to bvh and lights are not tracked. This is on purpose since it allows for a simple API while retaining maximum speed. To changes the scene, first stop the render, than apply scene changes, than update lights and bvh if needed, and finally restart the renderer. To update the BVH, use update_bvh(scene, instances, shapes, params) where instances and shapes are the list of modified ids. auto scene = new scene_model {...}; // initialize scene auto params = trace_params {}; // default params init_bvh ( scene , params , progress ); // init bvh init_lights ( scene , params , progress ); // init lights auto imgprogress = []( const image < vec4f >& render , // image progress int sample , int samples ) { display_image ( render ); // display image }; auto pxlprogress = []( const image < vec4f >& render , // pixel progress int sample , int samples , const vec2i & ij ) { display_pixel ( render , ij ); // display pixel }; auto state = new trace_state {}; // allocate state trace_start ( state , scene , params , {}, // start async renderer imgprogress , pxlprogress ); // function returns immediately run_app (...); // application runs normally here trace_stop ( state ); // stop async renderer modify_scene (...); // make scene changes trace_start ( state , scene , params , {}, // re-start async renderer imgprogress , pxlprogress ); // function returns immediately","title":"Path tracing"},{"location":"yocto/yocto_trace/#yoctotrace-path-tracing","text":"Yocto/Trace is a simple path tracer written on the Yocto/Scene model. Yocto/Trace is implemented in yocto_trace.h and yocto_trace.cpp .","title":"Yocto/Trace: Path tracing"},{"location":"yocto/yocto_trace/#rendering-features","text":"Yocto/Trace uses the Yocto/Scene model to represent scene data. Consult the scene documentation for a detailed description of the scene data model. Yocto/Trace supports rendering of shapes represented as indexed meshes of points, lines, triangles and quads. The renderer use instancing throughout to gain scalability with large environment, while still remaining easy to use. Materials are modeled similarly to the Disney's BSDF with integrated subsurface scattering. Lights are not specified explicitly but derived by the renderer from emissive surface and environment maps in the scene. Yocto/Trace implements a fast but simple path tracer. The algorithm uses relatively advanced sampling features to reduce the numbers of rays used to render an image. At the same time, we focus on general solutions that work well in all cases, instead of tuning the algorithm to work well in some specific cases. Yocto/Trace is a progressively path tracer that computes images a few samples at a time. This is true for both offline and online rendering. This design allows for partial images to be used to give feedback before the render is finished. In the future, this might allow for more rendering features like adaptive rendering or stop-and-resume renders.","title":"Rendering features"},{"location":"yocto/yocto_trace/#rendering-a-scene","text":"To render a scene, first initialize the scene bvh and lights, with init_bvh(scene, params, progress) and init_lights(scene, params, progress) and then call trace_image(scene, camera, params, progress, image_progress) . In these functions, params are thee rendering options used to render the scene, progress is a callback function used to report rendering progress and image_progress is a callback function used to report partial images during rendering. Both callback functions are optional. auto scene = new scene_model {...}; // initialize scene auto params = trace_params {}; // default params auto progress = []( const string & message , // progress callback int current , int total ) { print_info ( message , current , total ); }; init_bvh ( scene , params , progress ); // init bvh init_lights ( scene , params , progress ); // init lights trace_image ( scene , params , progress ); // render image auto improgress = []( const image < vec4f >& render , // image progress int sample , int samples ) { if ( sample % 16 == 0 ) // every 16 samples save_image ( filename , render ); // save image }; trace_image ( scene , params , progress , improgress ); // render image","title":"Rendering a scene"},{"location":"yocto/yocto_trace/#rendering-options","text":"The rendering process is configured with the trace_params settings. sampler determines the algorithm used for rendering: path is the default algorithm and probably the one you want to use, naive is a simpler path tracing that may be used for testing, eyelight produces quick previews of the screen geometry, falsecolor is a debug feature to view scenes according to the falsecolor setting, and albedo and normal are used to produce denoising buffers. THe image resolution is set by resolution and measures the resolution of the longest axis. samples is the number of per-pixel samples used while rendering and is the only parameter used to control the tradeoff between noise and speed. bounces is the maximum number of bounces and should be high for scenes with glass and volumes, but otherwise a low number would suffice. The remaining parameters are approximation used to reduce noise, at the expenses of bias. clamp remove high-energy fireflies. nocaustics removes certain path that cause caustics. tentfilter apply a linear filter to the image pixels. envhidden removes the environment map from the camera rays. Finally, the bvh parameter controls the heuristic used to build the Bvh and whether the Bvh uses Embree. Please see the description in Yocto/Scene. trace_sampler_names , trace_falsecolor_names and trace_bvh_names define string names for various enum values that can used for UIs or CLIs. // high quality rendering auto hq_params = trace_params {}; // default params hq_params . sampler = trace_sampler_type :: path ; // path tracing hq_params . resolution = 1280 ; // high-res render hq_params . samples = 1024 ; // high-sample count hq_params . bounce = 64 ; // high max bounces // geometry previewing auto pp_params = trace_params {}; // default params pp_params . sampler = trace_sampler_type :: eyelight ; // geometry preview pp_params . resolution = 720 ; // medium-res render pp_params . samples = 16 ; // low-sample count // scene debug viewing auto db_params = trace_params {}; // default params db_params . sampler = trace_sampler_type :: falsecolor ; // debug false colors db_params . falsecolor = trace_falsecolor_type :: normal ; // normal viewing db_params . resolution = 720 ; // medium-res render db_params . samples = 16 ; // low-sample count","title":"Rendering options"},{"location":"yocto/yocto_trace/#experimental-async-rendering","text":"The render can run in asynchronous mode where the rendering process is lunched and runs until completion. This mode is useful when for interactive viewing or in modeling-while-rendering applications. The API is very minimal and only controls the rendering process. Use trace_start(...) to start the async renderer and trace_stop(...) to stop it. The renderer starts by rendering a low resolution preview and then proceeds progressively. The async renderer takes a trace_state struct that tracks the rendering process and contains all data needed by the async renderer. Rendering progress ifs given by three callbacks. The first two are the rendering callbacks defined for offline rendeirng, that return progress report and an image buffer for each sample. In async mode, a further callback is called after each pixel is rendered. During rendering, no scenes changes are allowed, and changes to bvh and lights are not tracked. This is on purpose since it allows for a simple API while retaining maximum speed. To changes the scene, first stop the render, than apply scene changes, than update lights and bvh if needed, and finally restart the renderer. To update the BVH, use update_bvh(scene, instances, shapes, params) where instances and shapes are the list of modified ids. auto scene = new scene_model {...}; // initialize scene auto params = trace_params {}; // default params init_bvh ( scene , params , progress ); // init bvh init_lights ( scene , params , progress ); // init lights auto imgprogress = []( const image < vec4f >& render , // image progress int sample , int samples ) { display_image ( render ); // display image }; auto pxlprogress = []( const image < vec4f >& render , // pixel progress int sample , int samples , const vec2i & ij ) { display_pixel ( render , ij ); // display pixel }; auto state = new trace_state {}; // allocate state trace_start ( state , scene , params , {}, // start async renderer imgprogress , pxlprogress ); // function returns immediately run_app (...); // application runs normally here trace_stop ( state ); // stop async renderer modify_scene (...); // make scene changes trace_start ( state , scene , params , {}, // re-start async renderer imgprogress , pxlprogress ); // function returns immediately","title":"Experimental async rendering"}]}