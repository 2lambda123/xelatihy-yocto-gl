{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yocto/GL: Tiny C++ Libraries for Data-Oriented Physically-based Graphics Yocto/GL is a collection of small C++17 libraries for building physically-based graphics algorithms released under the MIT license. Yocto/GL is written in a deliberately data-oriented style for ease of development and use. Libraries Yocto/GL is split into small libraries to make code navigation easier. See each header file for documentation. Yocto/Math : fixed-size vectors, matrices, rigid frames, transforms Yocto/Color : color conversion, color adjustment, tone mapping functions, color grading, color maps, color spaces Yocto/Geometry : rays, bounding boxes, geometry functions, ray-primitive intersection, point-primitive overlap Yocto/Noise : Perlin noise Yocto/Sampling : random number generation, generation of points and directions, Monte Carlo utilities Yocto/Shading : evaluation and sampling of fresnel functions, bsdf lobes, transmittance lobes, phase functions Yocto/Image : simple image data type, image resizing, tonemapping, color correction, procedural images, procedural sun-sky Yocto/Shape : utilities for manipulating triangle meshes, quads meshes and line sets, computation of normals and tangents, linear and Catmull-Clark subdivision, procedural shapes generation, ray intersection and closest point queries Yocto/Mesh : computational geometry utilities for triangle meshes, mesh geodesic, mesh cutting Yocto/Bvh : ray intersection and closest point queries of triangle meshes, quads meshes, line sets and instances scenes using a two-level bounding volume hierarchy Yocto/Scen : scene representation and properties evaluation Yocto/SceneIO : image serialization, shape serialization, scene serialization, text and binary serialization, path helpers Yocto/Trace : path tracing of surfaces and hairs supporting area and environment illumination, microfacet GGX and subsurface scattering, multiple importance sampling Yocto/ModelIO : parsing and writing for Ply, Obj, Stl, Pbrt formats Yocto/Cli : printing utilities and command line parsing Yocto/Parallel : concurrency utilities Example Applications You can see Yocto/GL in action in the following applications written to test the library: apps/yscene.cpp : command-line scene manipulation and rendering, and interactive viewing apps/yshape.cpp : command-line shape manipulation and rendering, and interactive viewing apps/yimage.cpp : command-line image manipulation, and interactive viewing Here are some test images rendered with the path tracer. More images are included in the project site . Design Considerations Yocto/GL follows a \"data-oriented programming model\" that makes data explicit. Data is stored in simple structs and accessed with free functions or directly. All data is public, so we make no attempt at encapsulation. Most objects is Yocto/GL have value semantic, while large data structures use reference semantic with strict ownership. This means that everything can be trivially serialized and there is no need for memory management. We do this since this makes Yocto/GL easier to extend and quicker to learn, with a more explicit data flow that is easier when writing parallel code. Since Yocto/GL is mainly used for research and teaching, explicit data is both more hackable and easier to understand. In terms of code style we prefer a functional approach rather than an object oriented one, favoring free functions to class methods. All functions and data are defined in sibling namespaces contained in the yocto namespace so libraries can call all others, but have to do so explicitly. The use of templates in Yocto was the reason for many refactoring, going from no template to heavy template use. At this point, Yocto uses some templates for readability. In the future, we will increase the use of templates in math code, while keeping many APIs explicitly typed. We do not use exception for error reporting, but only to report \"programmers\" errors. For example, IO operations use boolean flags and error strings for human readable errors, while exceptions are used when preconditions or post conditions are violated in functions. After several refactoring, we settled on a value-based approach, since the use of pointers and reference semantics was hard for many of our users. While this has the drawback of potentially introducing spurious copies, it does have th benefit of ensuring that no memory corruption can occur, which turned out was a major issue for novice C++ users, even in a very small library like this one. Credits Main contributors: Fabio Pellacini (lead developer): web , github Edoardo Carra: github Giacomo Nazzaro: github This library includes code from the PCG random number generator , boost hash_combine , and public domain code from github.com/sgorsten/linalg , gist.github.com/badboy/6267743 . Other external libraries are included with their own license. Compilation This library requires a C++17 compiler and is know to compiled on OsX (Xcode >= 11), Windows (MSVC 2019) and Linux (gcc >= 9, clang >= 9). You can build the example applications using CMake with mkdir build; cd build; cmake ..; cmake --build Yocto/GL depends on stb_image.h , stb_image_write.h , stb_image_resize.h and tinyexr.h for image loading, saving and resizing, cgltf.h and json.hpp for glTF and JSON support, and filesystem.hpp to support C++17 filesystem API when missing. All dependencies are included in the distribution. Yocto/GL optionally supports building OpenGL demos, which are handled by including glad, GLFW, ImGui as dependencies in apps. OpenGL support might eventually become part of the Yocto/GL libraries. OpenGL support is enabled by defining the cmake option YOCTO_OPENGL and contained in the yocto_gui library. Yocto/GL optionally supports the use of Intel's Embree for ray casting. See the main CMake file for how to link to it. Embree support is enabled by defining the cmake option YOCTO_EMBREE . Yocto/GL optionally supports the use of Intel's Open Image Denoise for denoising. See the main CMake file for how to link to it. Open Image Denoise support is enabled by defining the cmake option YOCTO_DENOISE .","title":"About"},{"location":"#yoctogl-tiny-c-libraries-for-data-oriented-physically-based-graphics","text":"Yocto/GL is a collection of small C++17 libraries for building physically-based graphics algorithms released under the MIT license. Yocto/GL is written in a deliberately data-oriented style for ease of development and use.","title":"Yocto/GL: Tiny C++ Libraries for Data-Oriented Physically-based Graphics"},{"location":"#libraries","text":"Yocto/GL is split into small libraries to make code navigation easier. See each header file for documentation. Yocto/Math : fixed-size vectors, matrices, rigid frames, transforms Yocto/Color : color conversion, color adjustment, tone mapping functions, color grading, color maps, color spaces Yocto/Geometry : rays, bounding boxes, geometry functions, ray-primitive intersection, point-primitive overlap Yocto/Noise : Perlin noise Yocto/Sampling : random number generation, generation of points and directions, Monte Carlo utilities Yocto/Shading : evaluation and sampling of fresnel functions, bsdf lobes, transmittance lobes, phase functions Yocto/Image : simple image data type, image resizing, tonemapping, color correction, procedural images, procedural sun-sky Yocto/Shape : utilities for manipulating triangle meshes, quads meshes and line sets, computation of normals and tangents, linear and Catmull-Clark subdivision, procedural shapes generation, ray intersection and closest point queries Yocto/Mesh : computational geometry utilities for triangle meshes, mesh geodesic, mesh cutting Yocto/Bvh : ray intersection and closest point queries of triangle meshes, quads meshes, line sets and instances scenes using a two-level bounding volume hierarchy Yocto/Scen : scene representation and properties evaluation Yocto/SceneIO : image serialization, shape serialization, scene serialization, text and binary serialization, path helpers Yocto/Trace : path tracing of surfaces and hairs supporting area and environment illumination, microfacet GGX and subsurface scattering, multiple importance sampling Yocto/ModelIO : parsing and writing for Ply, Obj, Stl, Pbrt formats Yocto/Cli : printing utilities and command line parsing Yocto/Parallel : concurrency utilities","title":"Libraries"},{"location":"#example-applications","text":"You can see Yocto/GL in action in the following applications written to test the library: apps/yscene.cpp : command-line scene manipulation and rendering, and interactive viewing apps/yshape.cpp : command-line shape manipulation and rendering, and interactive viewing apps/yimage.cpp : command-line image manipulation, and interactive viewing Here are some test images rendered with the path tracer. More images are included in the project site .","title":"Example Applications"},{"location":"#design-considerations","text":"Yocto/GL follows a \"data-oriented programming model\" that makes data explicit. Data is stored in simple structs and accessed with free functions or directly. All data is public, so we make no attempt at encapsulation. Most objects is Yocto/GL have value semantic, while large data structures use reference semantic with strict ownership. This means that everything can be trivially serialized and there is no need for memory management. We do this since this makes Yocto/GL easier to extend and quicker to learn, with a more explicit data flow that is easier when writing parallel code. Since Yocto/GL is mainly used for research and teaching, explicit data is both more hackable and easier to understand. In terms of code style we prefer a functional approach rather than an object oriented one, favoring free functions to class methods. All functions and data are defined in sibling namespaces contained in the yocto namespace so libraries can call all others, but have to do so explicitly. The use of templates in Yocto was the reason for many refactoring, going from no template to heavy template use. At this point, Yocto uses some templates for readability. In the future, we will increase the use of templates in math code, while keeping many APIs explicitly typed. We do not use exception for error reporting, but only to report \"programmers\" errors. For example, IO operations use boolean flags and error strings for human readable errors, while exceptions are used when preconditions or post conditions are violated in functions. After several refactoring, we settled on a value-based approach, since the use of pointers and reference semantics was hard for many of our users. While this has the drawback of potentially introducing spurious copies, it does have th benefit of ensuring that no memory corruption can occur, which turned out was a major issue for novice C++ users, even in a very small library like this one.","title":"Design Considerations"},{"location":"#credits","text":"Main contributors: Fabio Pellacini (lead developer): web , github Edoardo Carra: github Giacomo Nazzaro: github This library includes code from the PCG random number generator , boost hash_combine , and public domain code from github.com/sgorsten/linalg , gist.github.com/badboy/6267743 . Other external libraries are included with their own license.","title":"Credits"},{"location":"#compilation","text":"This library requires a C++17 compiler and is know to compiled on OsX (Xcode >= 11), Windows (MSVC 2019) and Linux (gcc >= 9, clang >= 9). You can build the example applications using CMake with mkdir build; cd build; cmake ..; cmake --build Yocto/GL depends on stb_image.h , stb_image_write.h , stb_image_resize.h and tinyexr.h for image loading, saving and resizing, cgltf.h and json.hpp for glTF and JSON support, and filesystem.hpp to support C++17 filesystem API when missing. All dependencies are included in the distribution. Yocto/GL optionally supports building OpenGL demos, which are handled by including glad, GLFW, ImGui as dependencies in apps. OpenGL support might eventually become part of the Yocto/GL libraries. OpenGL support is enabled by defining the cmake option YOCTO_OPENGL and contained in the yocto_gui library. Yocto/GL optionally supports the use of Intel's Embree for ray casting. See the main CMake file for how to link to it. Embree support is enabled by defining the cmake option YOCTO_EMBREE . Yocto/GL optionally supports the use of Intel's Open Image Denoise for denoising. See the main CMake file for how to link to it. Open Image Denoise support is enabled by defining the cmake option YOCTO_DENOISE .","title":"Compilation"},{"location":"gallery/","text":"Gallery This page contains a collection of images rendered with the Yocto/GL path tracer. Environments Interiors Humans Animation Objects Vehicles Minecraft","title":"Gallery"},{"location":"gallery/#gallery","text":"This page contains a collection of images rendered with the Yocto/GL path tracer.","title":"Gallery"},{"location":"gallery/#environments","text":"","title":"Environments"},{"location":"gallery/#interiors","text":"","title":"Interiors"},{"location":"gallery/#humans","text":"","title":"Humans"},{"location":"gallery/#animation","text":"","title":"Animation"},{"location":"gallery/#objects","text":"","title":"Objects"},{"location":"gallery/#vehicles","text":"","title":"Vehicles"},{"location":"gallery/#minecraft","text":"","title":"Minecraft"},{"location":"yocto/yocto_bvh/","text":"Yocto/Bvh: Accelerated ray-intersection and point-overlap Yocto/Bvh provides ray-intersection and point-overlap queries accelerated using a two-level BVH or wrapping Intel's Embree. Yocto/Bvh is implemented in yocto_bvh.h and yocto_bvh.cpp . BVH representation Yocto/Bvh provides ray-scene intersection for points, lines, triangles and quads accelerated by a BVH data structure. Our BVH is written for minimal code and not maximum speed, but still gives fast-enough results. The BVH tree is stored in a bvh_tree struct. The tree stores an array of nodes and an array of element indices. Each node in the tree has references to either other nodes or elements. References are represented as indices in the nodes or elements arrays. Nodes indices refer to the nodes array, for internal nodes, or the element arrays, for leaf nodes. The BVH does not store shape data, which is instead passed explicitly to all calls. BVH nodes contain their bounds, indices to the BVH arrays of either primitives or internal nodes, node element type, and the split axis. Leaf and internal nodes are identical, except that indices refer to primitives for leaf nodes or other nodes for internal nodes. Two wrappers, bvh_scene and bvh_shape are used to store the BVH for Yocto/Scene scenes and shapes. For shapes, we store a single BVH, while for scene we store the scene BVH and all shapes BVHs. These wrappers does not store copies to shape or scene data, so that data is passed in for all subsequent calls. These wrappers can alternatively store references to Intel's Embree BVH, for faster ray-scene intersection. To use Embree, the library should be compiled with Embree support by setting the YOCTO_EMBREE compile flag and linking to Embree's libraries. Building BVH Use make_bvh(scene,highquality,embree) or make_bvh(shape,highquaity,embree) to build a bvh for a scene or shape BVH respectively. These functions takes as input scenes and shapes from Yocto/Scene . By default, the BVH is build with a fast heuristic, that can be improved slightly by setting highquality to true. By default, Yocto/BVH uses the internal BVH. Intel's Embree can be used by setting the embree flag to true. auto scene = scene_model {...}; // make a complete scene auto bvh = build_bvh ( scene ); // build a BVH auto embree = build_bvh ( scene , true , true ); // use Embree Use update_bvh(bvh,shape) to update a shape BVH, and update_bvh(bvh,scene,updated_instances,updated_shapes) to update a scene BVH, where we indicate the indices of the instances and shapes that have beed modified. Updating works ony for change to instance frames and shapes positions. For changes like adding or removing elements, the BVH has to be built again. auto scene = scene_model {...}; // make a complete scene auto bvh = build_bvh ( scene ); // build a BVH auto shapes = update_shapes ( scene ); // updates some shapes auto instances = update_instances ( scene ); // updates some instances update_bvh ( bvh , scene , shapes , instances ); // update bvh Ray intersection Use intersect_bvh(bvh,scene,ray) and intersect_bvh(bvh,shape,ray) to compute the ray-scene and ray-shape intersection respectively, and intersect_bvh(bvh,scene,instance,ray) to intersect a single scene instance. These functions return a bvh_intersection that includes a hit flag, the instance index, the shape element index and shape element uv s and the intersection distance . Results values are set only if hit is true. By default Yocto/Bvh computes the closet intersection, but this can be relaxed to accept any intersection, for shadow rays, by passing an optional flag. auto isec = intersect_bvh ( bvh , scene , ray ); // ray-scene intersection if ( isec . hit ) { // check intersection handle_intersection ( isec . instance , // work on intersection data isec . element , isec . uv , isec . distance ); } auto isecv = intersect_bvh ( bvh , scene , ray , true ); // check any intersection if ( ! isecv . hit ) { // check for not intersection handle_unoccluded (...); // handle unoccluded case } Point overlap Use overlap_bvh(bvh,scene,position,max_distance) and overlap_bvh(bvh,shape,position,max_distance) to compute the scene or shape element closest to a given point and within a maximum distance. Use overlap_bvh(bvh,scene,instance,position,max_distance) to test a single scene instance. These functions return a bvh_intersection as the intersection ones. By default Yocto/Bvh computes the closet element, but this can be relaxed to accept any element, by passing an optional flag. auto isec = overlap_bvh ( bvh , scene , point , dist ); // closest element if ( isec . hit ) { // check intersection handle_intersection ( isec . instance , // work on intersection data isec . element , isec . uv , isec . distance ); }","title":"Ray-scene intersection"},{"location":"yocto/yocto_bvh/#yoctobvh-accelerated-ray-intersection-and-point-overlap","text":"Yocto/Bvh provides ray-intersection and point-overlap queries accelerated using a two-level BVH or wrapping Intel's Embree. Yocto/Bvh is implemented in yocto_bvh.h and yocto_bvh.cpp .","title":"Yocto/Bvh: Accelerated ray-intersection and point-overlap"},{"location":"yocto/yocto_bvh/#bvh-representation","text":"Yocto/Bvh provides ray-scene intersection for points, lines, triangles and quads accelerated by a BVH data structure. Our BVH is written for minimal code and not maximum speed, but still gives fast-enough results. The BVH tree is stored in a bvh_tree struct. The tree stores an array of nodes and an array of element indices. Each node in the tree has references to either other nodes or elements. References are represented as indices in the nodes or elements arrays. Nodes indices refer to the nodes array, for internal nodes, or the element arrays, for leaf nodes. The BVH does not store shape data, which is instead passed explicitly to all calls. BVH nodes contain their bounds, indices to the BVH arrays of either primitives or internal nodes, node element type, and the split axis. Leaf and internal nodes are identical, except that indices refer to primitives for leaf nodes or other nodes for internal nodes. Two wrappers, bvh_scene and bvh_shape are used to store the BVH for Yocto/Scene scenes and shapes. For shapes, we store a single BVH, while for scene we store the scene BVH and all shapes BVHs. These wrappers does not store copies to shape or scene data, so that data is passed in for all subsequent calls. These wrappers can alternatively store references to Intel's Embree BVH, for faster ray-scene intersection. To use Embree, the library should be compiled with Embree support by setting the YOCTO_EMBREE compile flag and linking to Embree's libraries.","title":"BVH representation"},{"location":"yocto/yocto_bvh/#building-bvh","text":"Use make_bvh(scene,highquality,embree) or make_bvh(shape,highquaity,embree) to build a bvh for a scene or shape BVH respectively. These functions takes as input scenes and shapes from Yocto/Scene . By default, the BVH is build with a fast heuristic, that can be improved slightly by setting highquality to true. By default, Yocto/BVH uses the internal BVH. Intel's Embree can be used by setting the embree flag to true. auto scene = scene_model {...}; // make a complete scene auto bvh = build_bvh ( scene ); // build a BVH auto embree = build_bvh ( scene , true , true ); // use Embree Use update_bvh(bvh,shape) to update a shape BVH, and update_bvh(bvh,scene,updated_instances,updated_shapes) to update a scene BVH, where we indicate the indices of the instances and shapes that have beed modified. Updating works ony for change to instance frames and shapes positions. For changes like adding or removing elements, the BVH has to be built again. auto scene = scene_model {...}; // make a complete scene auto bvh = build_bvh ( scene ); // build a BVH auto shapes = update_shapes ( scene ); // updates some shapes auto instances = update_instances ( scene ); // updates some instances update_bvh ( bvh , scene , shapes , instances ); // update bvh","title":"Building BVH"},{"location":"yocto/yocto_bvh/#ray-intersection","text":"Use intersect_bvh(bvh,scene,ray) and intersect_bvh(bvh,shape,ray) to compute the ray-scene and ray-shape intersection respectively, and intersect_bvh(bvh,scene,instance,ray) to intersect a single scene instance. These functions return a bvh_intersection that includes a hit flag, the instance index, the shape element index and shape element uv s and the intersection distance . Results values are set only if hit is true. By default Yocto/Bvh computes the closet intersection, but this can be relaxed to accept any intersection, for shadow rays, by passing an optional flag. auto isec = intersect_bvh ( bvh , scene , ray ); // ray-scene intersection if ( isec . hit ) { // check intersection handle_intersection ( isec . instance , // work on intersection data isec . element , isec . uv , isec . distance ); } auto isecv = intersect_bvh ( bvh , scene , ray , true ); // check any intersection if ( ! isecv . hit ) { // check for not intersection handle_unoccluded (...); // handle unoccluded case }","title":"Ray intersection"},{"location":"yocto/yocto_bvh/#point-overlap","text":"Use overlap_bvh(bvh,scene,position,max_distance) and overlap_bvh(bvh,shape,position,max_distance) to compute the scene or shape element closest to a given point and within a maximum distance. Use overlap_bvh(bvh,scene,instance,position,max_distance) to test a single scene instance. These functions return a bvh_intersection as the intersection ones. By default Yocto/Bvh computes the closet element, but this can be relaxed to accept any element, by passing an optional flag. auto isec = overlap_bvh ( bvh , scene , point , dist ); // closest element if ( isec . hit ) { // check intersection handle_intersection ( isec . instance , // work on intersection data isec . element , isec . uv , isec . distance ); }","title":"Point overlap"},{"location":"yocto/yocto_cli/","text":"Yocto/Cli: Utilities for writing command-line apps Yocto/Cli is a collection of utilities used in writing command-line applications, including parsing command line arguments, printing values, timers and progress bars. Yocto/Cli is implemented in yocto_cli.h . Printing values Use print_info(message) to print a message, and print_fatal(message) to print and exit. To time a block of code use print_timed(message) to use an RIIA timer or call print_elapsed(timer) to print the elapsed time as needed. Use print_progress(message, current, total) to print a progress bar with a message for a given current and total number of tasks, or print_progress_start(message, total) , print_progress_next() and print_progress_end() to use a progress bar without managing manually the progress counter. print_info ( \"Message\" ); // print message print_fatal ( \"Error and exit\" ); // print error and exit { auto timer = print_timed ( \"Timer\" ); ... } // time a block of code auto timer = print_timed ( \"Timer\" ); // start timer print_elapsed ( timer ); // Print elapsed time for ( auto task : range ( 10 )) // iterate over tasks print_progress ( \"Progress bar\" , task , 10 ); // print progress bar print_progress_start ( \"Progress bar\" , 10 ); // start progress bar for ( auto task : range ( 10 )) // iterate over tasks print_progress_next (); // print progress bar Command-Line Parsing Yocto/Cli includes a simple command-line parser that supports optional and positional arguments, automatic help generation, and error checking. The command-line parser is initialized with make_cli(name, help) that takes a program name and a help string. Then add command-line options with add_option(cli, name, value, help, check, alt, req) for optional arguments and add_argument(cli, name, value, help, check, req) for positional arguments. In these commands, name is the option name, value is a reference to the variable that we want to set, help is a usage message, alt is the short option flag, and req determines whether the option is required, and check is either a range of valid values er a list of valid choices. After adding all arguments, use parse_cli(cli) to parse the command-line. If an error occurs, the parser exists. A help flag is also handled in this function. For positional arguments, the argument name is only used for printing help. For optional arguments, the command line is parsed for options named -- followed by the option name or - followed by the alt short name. The type of each option is determined by the passed reference. The parser supports integers, floating point numbers, strings, boolean flags, enums and arrays of strings. An help command is added automatically and checked for printing help and exiting without errors. auto samples = 10 ; auto flag = false ; // state auto out = \"\" s , scene = \"\" s ; auto scenes = vector < string > {}; auto cli = make_cli ( \"app\" , \"testing cli\" ); // initialize cli add_option ( cli , \"out\" , out , \"out\" ); // optional argument add_option ( cli , \"samples\" , samples , \"samples\" ); // optional argument add_option ( cli , \"flag\" , flag , \"flag\" ); // optional flag add_argument ( cli , \"scene\" , scene , \"scene\" ); // positional argument add_option ( cli , \"scenes\" , scenes , \"scenes\" ); // positional arguments parse_cli ( cli ); The command line parser also support commands, that are created by add_command(cli, name, help) , where name is the command name and help is the command usage message. You can add options to commands using the functions above. Commands can have any optional arguments, but support either sub-commands or positional arguments. auto samples = 10 ; // state auto scene = \"\" s ; auto cli = make_cli ( \"app\" , \"testing cli\" ); // initialize cli auto & render = add_command ( cli , \"render\" , \"render\" ); // command add_option ( render , \"samples\" , samples , \"samples\" ); // optional argument add_argument ( render , \"scene\" , scene , \"scene\" ); // positional argument auto & convert = add_command ( cli , \"convert\" , \"convert\" ); // command add_argument ( convert , \"scene\" , scene , \"scene\" ); // positional argument parse_cli ( cli );","title":"Command-line utilities"},{"location":"yocto/yocto_cli/#yoctocli-utilities-for-writing-command-line-apps","text":"Yocto/Cli is a collection of utilities used in writing command-line applications, including parsing command line arguments, printing values, timers and progress bars. Yocto/Cli is implemented in yocto_cli.h .","title":"Yocto/Cli: Utilities for writing command-line apps"},{"location":"yocto/yocto_cli/#printing-values","text":"Use print_info(message) to print a message, and print_fatal(message) to print and exit. To time a block of code use print_timed(message) to use an RIIA timer or call print_elapsed(timer) to print the elapsed time as needed. Use print_progress(message, current, total) to print a progress bar with a message for a given current and total number of tasks, or print_progress_start(message, total) , print_progress_next() and print_progress_end() to use a progress bar without managing manually the progress counter. print_info ( \"Message\" ); // print message print_fatal ( \"Error and exit\" ); // print error and exit { auto timer = print_timed ( \"Timer\" ); ... } // time a block of code auto timer = print_timed ( \"Timer\" ); // start timer print_elapsed ( timer ); // Print elapsed time for ( auto task : range ( 10 )) // iterate over tasks print_progress ( \"Progress bar\" , task , 10 ); // print progress bar print_progress_start ( \"Progress bar\" , 10 ); // start progress bar for ( auto task : range ( 10 )) // iterate over tasks print_progress_next (); // print progress bar","title":"Printing values"},{"location":"yocto/yocto_cli/#command-line-parsing","text":"Yocto/Cli includes a simple command-line parser that supports optional and positional arguments, automatic help generation, and error checking. The command-line parser is initialized with make_cli(name, help) that takes a program name and a help string. Then add command-line options with add_option(cli, name, value, help, check, alt, req) for optional arguments and add_argument(cli, name, value, help, check, req) for positional arguments. In these commands, name is the option name, value is a reference to the variable that we want to set, help is a usage message, alt is the short option flag, and req determines whether the option is required, and check is either a range of valid values er a list of valid choices. After adding all arguments, use parse_cli(cli) to parse the command-line. If an error occurs, the parser exists. A help flag is also handled in this function. For positional arguments, the argument name is only used for printing help. For optional arguments, the command line is parsed for options named -- followed by the option name or - followed by the alt short name. The type of each option is determined by the passed reference. The parser supports integers, floating point numbers, strings, boolean flags, enums and arrays of strings. An help command is added automatically and checked for printing help and exiting without errors. auto samples = 10 ; auto flag = false ; // state auto out = \"\" s , scene = \"\" s ; auto scenes = vector < string > {}; auto cli = make_cli ( \"app\" , \"testing cli\" ); // initialize cli add_option ( cli , \"out\" , out , \"out\" ); // optional argument add_option ( cli , \"samples\" , samples , \"samples\" ); // optional argument add_option ( cli , \"flag\" , flag , \"flag\" ); // optional flag add_argument ( cli , \"scene\" , scene , \"scene\" ); // positional argument add_option ( cli , \"scenes\" , scenes , \"scenes\" ); // positional arguments parse_cli ( cli ); The command line parser also support commands, that are created by add_command(cli, name, help) , where name is the command name and help is the command usage message. You can add options to commands using the functions above. Commands can have any optional arguments, but support either sub-commands or positional arguments. auto samples = 10 ; // state auto scene = \"\" s ; auto cli = make_cli ( \"app\" , \"testing cli\" ); // initialize cli auto & render = add_command ( cli , \"render\" , \"render\" ); // command add_option ( render , \"samples\" , samples , \"samples\" ); // optional argument add_argument ( render , \"scene\" , scene , \"scene\" ); // positional argument auto & convert = add_command ( cli , \"convert\" , \"convert\" ); // command add_argument ( convert , \"scene\" , scene , \"scene\" ); // positional argument parse_cli ( cli );","title":"Command-Line Parsing"},{"location":"yocto/yocto_color/","text":"Yocto/Color: Color operations Yocto/Color provides basic color utilities for writing graphics applications. In particular, we support color conversion to/from linear rgb, srgb, hsv, xyz, byte to float color conversions, colormaps, and a few color manipulations like contrast and saturation. Yocto/Color is implemented in yocto_color.h . Color Representation Yocto/Color follows the conventions of using generic vector types to represent color quantities rather than defining specific types, and performing color computation in floats for increased precision. Colors are represented as vec3f for three channels and vec4f for four channel types. This way, colors support all arithmetic operations defined in Yocto/Math . Yocto/Color supports storing colors in 8-bit representations as vec3b and vec4b . Conversion between float and byte representation are performed with byte_to_float(c8) and float_to_byte(cf) . auto red = vec3f { 1 , 0 , 0 }, green = vec3f { 0 , 1 , 0 }; // red and green colors auto yellow = red + green , darker = red * 0.5f ; // color arithmetic auto reddish = lerp ( red , green , 0.1f ); // color interpolation auto red8 = float_to_byte ( red ); // 8bit conversion Color Conversions Like most 3D graphics libraries, Yocto/Color does not explicitly track color spaces. Instead, we use conventions between library facilities to carry out color operations. Most color operations are defined on linear RGB colors. By default, Yocto/Color uses a linear color space with sRGB primaries, mostly since lots of freely available graphics data encodes colors in that manner. Yocto/Color supports conversions between linear RGB, sRGB, XYZ, xyY and HSV. Color conversion functions are named as <from>_to_<to> where <from> and <to> are the name of the color spaces. auto c_rgb = vec3f { 1 , 0.5 , 0 }; // color in linear RGB auto c_xyz = rgb_to_xyz ( c_rgb ); // convert to XYZ auto c_srgb = rgb_to_srgb ( c_rgb ); // convert to sRGB auto c_hsv = rgb_ro_hsv ( c_srgb ); // sRGB to HSV auto c_8bit = float_to_byte ( rgb_to_srgb ( c_rgb )); // encode in 8-bit sRGB Tonal Adjustment Yocto/Color provides minimal tonal adjustment functionality, mostly helpful when displaying images on screens. HDR images can be tone mapped with tonemap(hdr,e,f) that applies a simple exposure correction to the HDR colors and optionally a filmic tone curve. This functions converts from linear RGB to sRGB by default, but the latter conversion can be disabled. Saturation adjustment are implemented in sature(rgb,s) that interpolates to color with gray. Contrast adjustments are notoriously more complex since they depend on both the contrast function used and the color space it is applied with. To cater to most uses, Yocto/Color provides three contrast curves. contrast(rgb,c) generate smooth contrast variations by applying an S-shaped curve that typically used in non-linear color spaces. lincontrast(rgb,c,g) has a harsher look due to clipped colors and is obtained by applying linear scaling around a gray level. logcontrast(rgb,c,g) is suitable to contrast manipulation in HDR since it does not clip colors. This is implemented by applying scaling in the logarithm domain. Both linear and logarithmic contrast can be used for HDR and LDR by adjusting the gray level to 0.18 and 0.5 respectively. auto exposure = 1 ; auto filomic = true ; auto ldr = tonemap ( hdr , exposure , filmic ); // HDR to LDR tone mapping ldr = contrast ( saturate ( ldr , 0.7 ), 0.7 ); // contrast and saturation auto hdr2 = logcontrast ( hdr * tint , 0.7 , 0.18 ); // contrast and tint in HDR Color grading Several color corrections are bundled together, with their parameters packed in a convenience structure colorgrade_params , to implement a minimal set of minimal color grading tools in manner similar to Hable 2017 , using the function colorgrade(color, linear, params) . Color grading operations are applied in a fixed sequence and consist of the following operations: exposure compensation, color tint, contrast in the log domain, filmic curve, conversion to sRGB, S-shaped contrast, saturation, and shadow/midtone/highlight correction. Color tinting can be used to apply white balance by using compute_white_balance(img) to determine the correct color. Color grading corrections can be applied to either linear HDR or sRGB encoded colors. The results is always an LDR value encoded in sRGB. auto params = colorgrade_params {}; // default color grading params params . exposure = 1 ; // set desired params params . logcontrast = 0.75 ; // set desired params auto ldr = colorgrade ( hdr , linear , params ); // color grading Color map Yocto/Color defines functions to apply standard color maps. Use colormap(t, type) to apply a color map from a value in [0,1] and for different color map types. The library currently supports fitted Matplotlib colormaps from here . auto c0 = colormap ( 0.5 , colormap_type :: viridis ); auto c1 = colormap ( 0.5 , colormap_type :: plasma ); auto c2 = colormap ( 0.5 , colormap_type :: magma ); auto c3 = colormap ( 0.5 , colormap_type :: inferno );","title":"Color operations"},{"location":"yocto/yocto_color/#yoctocolor-color-operations","text":"Yocto/Color provides basic color utilities for writing graphics applications. In particular, we support color conversion to/from linear rgb, srgb, hsv, xyz, byte to float color conversions, colormaps, and a few color manipulations like contrast and saturation. Yocto/Color is implemented in yocto_color.h .","title":"Yocto/Color: Color operations"},{"location":"yocto/yocto_color/#color-representation","text":"Yocto/Color follows the conventions of using generic vector types to represent color quantities rather than defining specific types, and performing color computation in floats for increased precision. Colors are represented as vec3f for three channels and vec4f for four channel types. This way, colors support all arithmetic operations defined in Yocto/Math . Yocto/Color supports storing colors in 8-bit representations as vec3b and vec4b . Conversion between float and byte representation are performed with byte_to_float(c8) and float_to_byte(cf) . auto red = vec3f { 1 , 0 , 0 }, green = vec3f { 0 , 1 , 0 }; // red and green colors auto yellow = red + green , darker = red * 0.5f ; // color arithmetic auto reddish = lerp ( red , green , 0.1f ); // color interpolation auto red8 = float_to_byte ( red ); // 8bit conversion","title":"Color Representation"},{"location":"yocto/yocto_color/#color-conversions","text":"Like most 3D graphics libraries, Yocto/Color does not explicitly track color spaces. Instead, we use conventions between library facilities to carry out color operations. Most color operations are defined on linear RGB colors. By default, Yocto/Color uses a linear color space with sRGB primaries, mostly since lots of freely available graphics data encodes colors in that manner. Yocto/Color supports conversions between linear RGB, sRGB, XYZ, xyY and HSV. Color conversion functions are named as <from>_to_<to> where <from> and <to> are the name of the color spaces. auto c_rgb = vec3f { 1 , 0.5 , 0 }; // color in linear RGB auto c_xyz = rgb_to_xyz ( c_rgb ); // convert to XYZ auto c_srgb = rgb_to_srgb ( c_rgb ); // convert to sRGB auto c_hsv = rgb_ro_hsv ( c_srgb ); // sRGB to HSV auto c_8bit = float_to_byte ( rgb_to_srgb ( c_rgb )); // encode in 8-bit sRGB","title":"Color Conversions"},{"location":"yocto/yocto_color/#tonal-adjustment","text":"Yocto/Color provides minimal tonal adjustment functionality, mostly helpful when displaying images on screens. HDR images can be tone mapped with tonemap(hdr,e,f) that applies a simple exposure correction to the HDR colors and optionally a filmic tone curve. This functions converts from linear RGB to sRGB by default, but the latter conversion can be disabled. Saturation adjustment are implemented in sature(rgb,s) that interpolates to color with gray. Contrast adjustments are notoriously more complex since they depend on both the contrast function used and the color space it is applied with. To cater to most uses, Yocto/Color provides three contrast curves. contrast(rgb,c) generate smooth contrast variations by applying an S-shaped curve that typically used in non-linear color spaces. lincontrast(rgb,c,g) has a harsher look due to clipped colors and is obtained by applying linear scaling around a gray level. logcontrast(rgb,c,g) is suitable to contrast manipulation in HDR since it does not clip colors. This is implemented by applying scaling in the logarithm domain. Both linear and logarithmic contrast can be used for HDR and LDR by adjusting the gray level to 0.18 and 0.5 respectively. auto exposure = 1 ; auto filomic = true ; auto ldr = tonemap ( hdr , exposure , filmic ); // HDR to LDR tone mapping ldr = contrast ( saturate ( ldr , 0.7 ), 0.7 ); // contrast and saturation auto hdr2 = logcontrast ( hdr * tint , 0.7 , 0.18 ); // contrast and tint in HDR","title":"Tonal Adjustment"},{"location":"yocto/yocto_color/#color-grading","text":"Several color corrections are bundled together, with their parameters packed in a convenience structure colorgrade_params , to implement a minimal set of minimal color grading tools in manner similar to Hable 2017 , using the function colorgrade(color, linear, params) . Color grading operations are applied in a fixed sequence and consist of the following operations: exposure compensation, color tint, contrast in the log domain, filmic curve, conversion to sRGB, S-shaped contrast, saturation, and shadow/midtone/highlight correction. Color tinting can be used to apply white balance by using compute_white_balance(img) to determine the correct color. Color grading corrections can be applied to either linear HDR or sRGB encoded colors. The results is always an LDR value encoded in sRGB. auto params = colorgrade_params {}; // default color grading params params . exposure = 1 ; // set desired params params . logcontrast = 0.75 ; // set desired params auto ldr = colorgrade ( hdr , linear , params ); // color grading","title":"Color grading"},{"location":"yocto/yocto_color/#color-map","text":"Yocto/Color defines functions to apply standard color maps. Use colormap(t, type) to apply a color map from a value in [0,1] and for different color map types. The library currently supports fitted Matplotlib colormaps from here . auto c0 = colormap ( 0.5 , colormap_type :: viridis ); auto c1 = colormap ( 0.5 , colormap_type :: plasma ); auto c2 = colormap ( 0.5 , colormap_type :: magma ); auto c3 = colormap ( 0.5 , colormap_type :: inferno );","title":"Color map"},{"location":"yocto/yocto_geometry/","text":"Yocto/Geometry: Geometry operations Yocto/Geometry defines basic geometry operations, including computation of basic geometry quantities, ray-primitive intersection, point-primitive distance, primitive bounds, and several interpolation functions. Yocto/Geometry also defines rays, bounding boxes and their transforms. Yocto/Geometry is implemented in yocto_geometry.h . Primitive parametrization Yocto/Geometry supports operations on lines, triangles, quads and beziers. In these functions, triangles are parameterized with barycentric coordinates uv written with respect to the p1-p0 and p2-p0 axes respectively. Quads are internally handled as pairs of triangles p0,p1,p3 and p2,p3,p1 , with the uv coordinates of the second triangle corrected as 1-u and 1-v to produce a quad parametrization where u and v go from 0 to 1. Degenerate quads with p2==p3 represent triangles correctly. This parametrization is equivalent to Intel's Embree. Geometric properties For lines, Yocto/Geometry supports the computation of line lengths, with line_length(p0,p1) , and line tangents, with line_tangent(p0,p1) . For triangles, Yocto/Geometry supports the computation of triangle areas, with triangle_area(p0,p1,p2) , and triangle normals, triangle_normal(p0,p1,p2) . Similarly for quads, use quad_area(p0,p1,p2,p3) , quad_normal(p0,p1,p2,p3) for areas and normals. For triangles and quads, Yocto/Geometry also supports computing tangents and bitangents from texture coordinates. This is helpful for applying normal or bump mapping during rendering. Use triangle_tangents_fromuv(p0,p1,p2,uv0,uv1,uv2) for triangles and quad_tangents_fromuv(p0,p1,p2,p3,uv0,uv1,uv2,uv3,uv) for quads. For triangles, tangents and bitangents are defined with respect to the first vertex as the origin. For quads, we define the vectors on the two triangles and do not compute the average. For this pass an additional texture coordinate since internally we split the triangle into two and we need to known where to do it. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto ta = triangle_area ( p0 , p1 , p2 ); // triangle area auto qa = quad_area ( p0 , p1 , p2 , p3 ); // quad area auto tn = triangle_normal ( p0 , p1 , p2 ); // triangle normal auto qn = quad_normal ( p0 , p1 , p2 , p3 ); // quad normal auto uv0 = vec2f { 0 , 0 }, uv1 = vec2f { 1 , 0 }, uv2 = vec2f { 1 , 1 }, uv3 = vec2f { 0 , 1 }; auto [ tu , tv ] = triangle_tangents_fromuv ( p0 , p1 , p2 , uv0 , uv1 , uv2 ); // tangents Interpolation on primitives For all primitives, Yocto/Geometry defines interpolation functions that take values defined at the primitive vertices and compute the interpolate value at the parametrized point. Lines and beziers are parametrized with their natural parameter, while triangles and quads use barycentric interpolation as defined above. Use interpolate_line(p0,p1,u) for lines, interpolate_triangle(p0,p1,p2,uv) for triangles, interpolate_quad(p0,p1,p2,p3,uv) for quads and interpolate_bezier(p0,p1,p2,p3,u) for cubic Bezier segments, whose derivatives can be computed with interpolate_bezier_derivative(p0,p1,p2,p3,u) . auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto tp = interpolate_triangle ( p0 , p1 , p2 ,{ 0.3 , 0.5 }); // triangle point auto qp = interpolate_quad ( p0 , p1 , p2 , p3 ,{ 0.3 , 0.5 }); // quad point auto lp = interpolate_line ( p0 , p1 , 0.3 ); // line point auto bp = interpolate_bezier ( p0 , p1 , p2 , p3 , 0.3 ); // bezier point Bounding boxes Yocto/Math defines axies-aligned bounding boxes in 2 to 3 dimensions as bbox2f and bbox3f . Bounding boxes store the minimum and maximum coordinate values, that can be accessed with b.min and b.max . Bounding boxes are default-initialized to an invalid state that contains no points, or they are constructed by specifying the min and max values directly. To build bounds for complex primitives, bounding boxes are very initialized to empty bounds, that can be done by using the constants like invalidabXf , and then grown to encompass either points or other bounding boxes with merge(b,p) . To transform bounding boxes use transform_bbox(frame, bbox) . auto bbox = invalidb3f ; for ( auto point : points ) bbox = merge ( bbox , point ); auto transform = frame3f {...}; auto transformed = transform_bbox ( tranform , bbox ); Primitive bounding boxes Yocto/Geometry provides functions to compute bounding boxes for all primitives types. For points and lines, vertices might have a thickness associate with them. Use point_bounds(p0,r0) for points, line_bounds(p0,p1,r0,r1) for lines, triangle_bounds(p0,p1,p2) for triangles, quad_bounds(p0,p1,p2,p3) for quads. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto tb = triangle_bounds ( p0 , p1 , p2 ); // triangle bounding box auto qb = quad_bounds ( p0 , p1 , p2 , p3 ); // quad bounding box auto r0 = 0.01 , r1 = 0.01 ; auto lb = line_bounds ( p0 , p1 , r0 , r1 ); // line bounding box auto pb = point_bounds ( p0 , r0 ); // point bounding box Rays Yocto/Math defines rays in 2-3 dimensions as ray2f and ray3f . Rays are defined as an origin o , a direction d and minimum and maximum values for the distance along a ray, namely tmin and tmax . To compute a point in a ray, use ray_point(ray,t) . To transform rays use transform_ray(frame, ray) . auto ray = ray3f { origin , direction }; auto p = ray_point ( ray , 0.5 ); auto transform = frame3f {...}; auto transformed = transform_ray ( tranform , ray ); Ray-primitive intersections Yocto/Geometry defines functions for ray-primitive intersection. Each function returns wether the primitive was hit and, if so, sets the primitive parameters and the intersection distance as output variables. Triangle intersection are computed using the Moller-Trombone intersection algorithm. Quad intersections are computed by treating quads as two triangles. Point intersections are compute approximately, by treating points as ray-oriented disks. Line intersections are computed approximately, by treating lines as ray-oriented ribbons. Use intersect_point(ray,p0,r0,uv,d) for points, intersect_line(ray,p0,p1,r0,r1,uv,d) for lines, intersect_triangle(ray,p0,p1,p2,uv,d) for triangles, intersect_quad(ray,p0,p1,p2,p3,uv,d) for quads. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto r0 = 0.01 , r1 = 0.01 ; auto ray = ray3f {{ 0 , 0 , 0.5 },{ 0 , 0 , -1 }}; // ray auto uv = vec2f { 0 , 0 }; auto dist = float { 0 }; // hit distance and uvs auto th = intersect_triangle ( ray , p0 , p1 , p2 , uv , dist )); // triangle intersection auto qh = intersect_quad ( ray , p0 , p1 , p2 , p3 , uv , dist )); // quad intersection auto lh = intersect_line ( ray , p0 , p1 , r0 , r1 , uv , dist )); // line intersection auto ph = intersect_point ( ray , p0 , r0 , uv , dist )); // point intersection Yocto/Geometry defines two functions to test whether a ray hits a bounding box. In this case, we do not return the ray distance or hit, but just check for intersection, which is useful when defining BVH hierarchies. Use intersect_bbox(ray,bbox) as a simple alternative and intersect_bbox(ray,ray_dinv,bbox) for a faster one. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto bbox = quad_bounds ( p0 , p1 , p2 , p3 ); auto bh = intersect_bbox ( ray , bbox ); // bbox intersection check auto ray_dinv = 1 / ray . d ; // ray direction inverse auto bf = intersect_bbox ( ray , ray_dinv , bbox ); // fast bbox intersection Point-primitive overlaps Yocto/Geometry defines functions for point-primitive distance and overlap. Each function returns wether the primitive was hit and, if so, sets the primitive parameters and the overlap distance as output variables. Each function takes a position and a maximum distance to test within, together with primitive vertices and thickness. Use overlap_point(pt,md,p0,r0,uv,d) for points, overlap_line(pt,md,p0,p1,r0,r1,uv,d) for lines, overlap_triangle(pt,md,p0,p1,p2,r0,r1,r2,uv,d) for triangles, overlap_quad(pt,md,p0,p1,p2,p3,r0,r1,r2,r3,uv,d) for quads. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto r0 = 0.01 , r1 = 0.01 , r2 = 0.01 , r3 = 0.01 ; auto pt = vec3f { 0 , 0 , 0.5 }; auto md = float { 1 }; // point and max dist auto uv = vec2f { 0 , 0 }; auto dist = float { 0 }; // hit distance and uv auto th = overlap_triangle ( pt , md , p0 , p1 , p2 , uv , dist )); // triangle overlap auto qh = overlap_quad ( pt , md , p0 , p1 , p2 , p3 , uv , dist )); // quad overlap auto lh = overlap_line ( pt , md , p0 , p1 , r0 , r1 , uv , dist )); // line overlap auto ph = overlap_point ( pt , md , p0 , r0 , uv , dist )); // point overlap Yocto/Geometry defines a function to test whether a point is contained within a bounding bbox within a certain distance. Just like before, we do not return the ray distance or hit, but just check for overlap, which is useful when defining BVH hierarchies. Use overlap_bbox(pt,md,bbox) to test for overlap between a point and a bounding box and overlap_bbox(bbox1,bbox2) to test whether two bounding boxes overlap. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto bbox = quad_bounds ( p0 , p1 , p2 , p3 ); auto bbox2 = bbox3f {{ 0 , 0 , 0 }, { 1 , 1 , 1 }}; auto pt = vec3f { 0 , 0 , 0.5 }; auto md = float { 1 }; // point and max dist auto bh = overlap_bbox ( pt , md , bbox ); // bbox overlap check auto bh2 = overlap_bbox ( bbox , bbox2 ); // bbox overlap check","title":"Geometry operations"},{"location":"yocto/yocto_geometry/#yoctogeometry-geometry-operations","text":"Yocto/Geometry defines basic geometry operations, including computation of basic geometry quantities, ray-primitive intersection, point-primitive distance, primitive bounds, and several interpolation functions. Yocto/Geometry also defines rays, bounding boxes and their transforms. Yocto/Geometry is implemented in yocto_geometry.h .","title":"Yocto/Geometry: Geometry operations"},{"location":"yocto/yocto_geometry/#primitive-parametrization","text":"Yocto/Geometry supports operations on lines, triangles, quads and beziers. In these functions, triangles are parameterized with barycentric coordinates uv written with respect to the p1-p0 and p2-p0 axes respectively. Quads are internally handled as pairs of triangles p0,p1,p3 and p2,p3,p1 , with the uv coordinates of the second triangle corrected as 1-u and 1-v to produce a quad parametrization where u and v go from 0 to 1. Degenerate quads with p2==p3 represent triangles correctly. This parametrization is equivalent to Intel's Embree.","title":"Primitive parametrization"},{"location":"yocto/yocto_geometry/#geometric-properties","text":"For lines, Yocto/Geometry supports the computation of line lengths, with line_length(p0,p1) , and line tangents, with line_tangent(p0,p1) . For triangles, Yocto/Geometry supports the computation of triangle areas, with triangle_area(p0,p1,p2) , and triangle normals, triangle_normal(p0,p1,p2) . Similarly for quads, use quad_area(p0,p1,p2,p3) , quad_normal(p0,p1,p2,p3) for areas and normals. For triangles and quads, Yocto/Geometry also supports computing tangents and bitangents from texture coordinates. This is helpful for applying normal or bump mapping during rendering. Use triangle_tangents_fromuv(p0,p1,p2,uv0,uv1,uv2) for triangles and quad_tangents_fromuv(p0,p1,p2,p3,uv0,uv1,uv2,uv3,uv) for quads. For triangles, tangents and bitangents are defined with respect to the first vertex as the origin. For quads, we define the vectors on the two triangles and do not compute the average. For this pass an additional texture coordinate since internally we split the triangle into two and we need to known where to do it. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto ta = triangle_area ( p0 , p1 , p2 ); // triangle area auto qa = quad_area ( p0 , p1 , p2 , p3 ); // quad area auto tn = triangle_normal ( p0 , p1 , p2 ); // triangle normal auto qn = quad_normal ( p0 , p1 , p2 , p3 ); // quad normal auto uv0 = vec2f { 0 , 0 }, uv1 = vec2f { 1 , 0 }, uv2 = vec2f { 1 , 1 }, uv3 = vec2f { 0 , 1 }; auto [ tu , tv ] = triangle_tangents_fromuv ( p0 , p1 , p2 , uv0 , uv1 , uv2 ); // tangents","title":"Geometric properties"},{"location":"yocto/yocto_geometry/#interpolation-on-primitives","text":"For all primitives, Yocto/Geometry defines interpolation functions that take values defined at the primitive vertices and compute the interpolate value at the parametrized point. Lines and beziers are parametrized with their natural parameter, while triangles and quads use barycentric interpolation as defined above. Use interpolate_line(p0,p1,u) for lines, interpolate_triangle(p0,p1,p2,uv) for triangles, interpolate_quad(p0,p1,p2,p3,uv) for quads and interpolate_bezier(p0,p1,p2,p3,u) for cubic Bezier segments, whose derivatives can be computed with interpolate_bezier_derivative(p0,p1,p2,p3,u) . auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto tp = interpolate_triangle ( p0 , p1 , p2 ,{ 0.3 , 0.5 }); // triangle point auto qp = interpolate_quad ( p0 , p1 , p2 , p3 ,{ 0.3 , 0.5 }); // quad point auto lp = interpolate_line ( p0 , p1 , 0.3 ); // line point auto bp = interpolate_bezier ( p0 , p1 , p2 , p3 , 0.3 ); // bezier point","title":"Interpolation on primitives"},{"location":"yocto/yocto_geometry/#bounding-boxes","text":"Yocto/Math defines axies-aligned bounding boxes in 2 to 3 dimensions as bbox2f and bbox3f . Bounding boxes store the minimum and maximum coordinate values, that can be accessed with b.min and b.max . Bounding boxes are default-initialized to an invalid state that contains no points, or they are constructed by specifying the min and max values directly. To build bounds for complex primitives, bounding boxes are very initialized to empty bounds, that can be done by using the constants like invalidabXf , and then grown to encompass either points or other bounding boxes with merge(b,p) . To transform bounding boxes use transform_bbox(frame, bbox) . auto bbox = invalidb3f ; for ( auto point : points ) bbox = merge ( bbox , point ); auto transform = frame3f {...}; auto transformed = transform_bbox ( tranform , bbox );","title":"Bounding boxes"},{"location":"yocto/yocto_geometry/#primitive-bounding-boxes","text":"Yocto/Geometry provides functions to compute bounding boxes for all primitives types. For points and lines, vertices might have a thickness associate with them. Use point_bounds(p0,r0) for points, line_bounds(p0,p1,r0,r1) for lines, triangle_bounds(p0,p1,p2) for triangles, quad_bounds(p0,p1,p2,p3) for quads. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto tb = triangle_bounds ( p0 , p1 , p2 ); // triangle bounding box auto qb = quad_bounds ( p0 , p1 , p2 , p3 ); // quad bounding box auto r0 = 0.01 , r1 = 0.01 ; auto lb = line_bounds ( p0 , p1 , r0 , r1 ); // line bounding box auto pb = point_bounds ( p0 , r0 ); // point bounding box","title":"Primitive bounding boxes"},{"location":"yocto/yocto_geometry/#rays","text":"Yocto/Math defines rays in 2-3 dimensions as ray2f and ray3f . Rays are defined as an origin o , a direction d and minimum and maximum values for the distance along a ray, namely tmin and tmax . To compute a point in a ray, use ray_point(ray,t) . To transform rays use transform_ray(frame, ray) . auto ray = ray3f { origin , direction }; auto p = ray_point ( ray , 0.5 ); auto transform = frame3f {...}; auto transformed = transform_ray ( tranform , ray );","title":"Rays"},{"location":"yocto/yocto_geometry/#ray-primitive-intersections","text":"Yocto/Geometry defines functions for ray-primitive intersection. Each function returns wether the primitive was hit and, if so, sets the primitive parameters and the intersection distance as output variables. Triangle intersection are computed using the Moller-Trombone intersection algorithm. Quad intersections are computed by treating quads as two triangles. Point intersections are compute approximately, by treating points as ray-oriented disks. Line intersections are computed approximately, by treating lines as ray-oriented ribbons. Use intersect_point(ray,p0,r0,uv,d) for points, intersect_line(ray,p0,p1,r0,r1,uv,d) for lines, intersect_triangle(ray,p0,p1,p2,uv,d) for triangles, intersect_quad(ray,p0,p1,p2,p3,uv,d) for quads. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto r0 = 0.01 , r1 = 0.01 ; auto ray = ray3f {{ 0 , 0 , 0.5 },{ 0 , 0 , -1 }}; // ray auto uv = vec2f { 0 , 0 }; auto dist = float { 0 }; // hit distance and uvs auto th = intersect_triangle ( ray , p0 , p1 , p2 , uv , dist )); // triangle intersection auto qh = intersect_quad ( ray , p0 , p1 , p2 , p3 , uv , dist )); // quad intersection auto lh = intersect_line ( ray , p0 , p1 , r0 , r1 , uv , dist )); // line intersection auto ph = intersect_point ( ray , p0 , r0 , uv , dist )); // point intersection Yocto/Geometry defines two functions to test whether a ray hits a bounding box. In this case, we do not return the ray distance or hit, but just check for intersection, which is useful when defining BVH hierarchies. Use intersect_bbox(ray,bbox) as a simple alternative and intersect_bbox(ray,ray_dinv,bbox) for a faster one. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto bbox = quad_bounds ( p0 , p1 , p2 , p3 ); auto bh = intersect_bbox ( ray , bbox ); // bbox intersection check auto ray_dinv = 1 / ray . d ; // ray direction inverse auto bf = intersect_bbox ( ray , ray_dinv , bbox ); // fast bbox intersection","title":"Ray-primitive intersections"},{"location":"yocto/yocto_geometry/#point-primitive-overlaps","text":"Yocto/Geometry defines functions for point-primitive distance and overlap. Each function returns wether the primitive was hit and, if so, sets the primitive parameters and the overlap distance as output variables. Each function takes a position and a maximum distance to test within, together with primitive vertices and thickness. Use overlap_point(pt,md,p0,r0,uv,d) for points, overlap_line(pt,md,p0,p1,r0,r1,uv,d) for lines, overlap_triangle(pt,md,p0,p1,p2,r0,r1,r2,uv,d) for triangles, overlap_quad(pt,md,p0,p1,p2,p3,r0,r1,r2,r3,uv,d) for quads. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto r0 = 0.01 , r1 = 0.01 , r2 = 0.01 , r3 = 0.01 ; auto pt = vec3f { 0 , 0 , 0.5 }; auto md = float { 1 }; // point and max dist auto uv = vec2f { 0 , 0 }; auto dist = float { 0 }; // hit distance and uv auto th = overlap_triangle ( pt , md , p0 , p1 , p2 , uv , dist )); // triangle overlap auto qh = overlap_quad ( pt , md , p0 , p1 , p2 , p3 , uv , dist )); // quad overlap auto lh = overlap_line ( pt , md , p0 , p1 , r0 , r1 , uv , dist )); // line overlap auto ph = overlap_point ( pt , md , p0 , r0 , uv , dist )); // point overlap Yocto/Geometry defines a function to test whether a point is contained within a bounding bbox within a certain distance. Just like before, we do not return the ray distance or hit, but just check for overlap, which is useful when defining BVH hierarchies. Use overlap_bbox(pt,md,bbox) to test for overlap between a point and a bounding box and overlap_bbox(bbox1,bbox2) to test whether two bounding boxes overlap. auto p0 = vec3f { 0 , 0 , 0 }, p1 = vec3f { 1 , 0 , 0 }, p2 = vec3f { 1 , 1 , 0 }, p3 = vec3f { 0 , 1 , 0 }; auto bbox = quad_bounds ( p0 , p1 , p2 , p3 ); auto bbox2 = bbox3f {{ 0 , 0 , 0 }, { 1 , 1 , 1 }}; auto pt = vec3f { 0 , 0 , 0.5 }; auto md = float { 1 }; // point and max dist auto bh = overlap_bbox ( pt , md , bbox ); // bbox overlap check auto bh2 = overlap_bbox ( bbox , bbox2 ); // bbox overlap check","title":"Point-primitive overlaps"},{"location":"yocto/yocto_image/","text":"Yocto/Image: Image utilities Yocto/Image is a collection of image utilities useful when writing rendering algorithms. These include a simple image data structure, color conversion utilities and tone mapping, and image resizing. Yocto/Image is implemented in yocto_image.h and yocto_image.cpp , and depends on stb_image_resize.h . Image representation Images are represented as a simple struct called color_image , that stores the image width and height, a boolean flat that indicates whether the colors are in linear ot sRGB color space, and an array of pixels of vec4f type. While images can be constructed by direct manipulation of their values, th preferred way to construct images is by using the make_image(widgh, height, linear) function, where colors are default initialized to black. Image pixels are stored in row-major order and be accessed with index j * width + i . They can be conveniently accessed using get_pixel(image,i,j) and set_pixel(image,i,j,color) function. auto image = make_image ( 512 , 512 , false ); // creates a 512x512 sRGB image for ( auto & pixel : image . pixels ) // iterate over pixels print_info ( pixel ); auto color = get_pixel ( image , 128 , 128 ); // pixel access for ( auto j = 0 ; j < image . height ; j ++ ) // iterate over image rows for ( auto i = 0 ; i < image . width ; i ++ ) // iterate over row pixels print_info ( get_pixel ( image , i , j )); Images are sampled with eval_image(img,uv,...) , where uv are in the [0,1]x[0,1] range. By default, image values are returned in the color space of the image, but can be forced to to be linear. By default, images are sampled with bilinear interpolation and tiling, with nearest-neighbor interpolation and edge-clamp behavior available as overrides. auto hdr = make_image ( w , h , true ); // creates a linear image auto ch0 = eval_image ( hdr , { 0.5 , 0.5 }); // samples the image center auto ch1 = eval_image ( hdr , { 0.5 , 0.5 }, false , false ); // no interpolation auto ch2 = eval_image ( hdr , { 0.5 , 0.5 }, false , false , false ); // clamp to edge auto ldr = make_image ( w , h , false ); // creates a sRGB image auto ch0 = eval_image ( ldr , { 0.5 , 0.5 }); // samples in sRGB, returns as sRGB auto ch1 = eval_image ( ldr , { 0.5 , 0.5 }, true ); // treats sRGB values as linear Image loading and saving is defined in Yocto/SceneIO . Image utilities Images can be converted between linear RGB and sRGB color space using convert_image(image,linear) . auto linear = make_image ( w , h , true ); // initialize a linear image auto srgb = convert_image ( w , h , false ); // convert to sRGB HDR images can be tone mapped using tonemap_image(hdr,exposure,filmic) that applies an exposure correction followed by an optional filmic tone curve. Use tonemap_image_mt(...) to quickly tone map large images using multiple threads. auto hdr = make_image ( w , h , true ); // initialize am HDR image auto ldr = tonemap_image ( hdr , 2 ); // tone mapping with exposure 2 auto flm = tonemap_image ( hdr , 2 , true ); // filmic tone mapping Images can be color graded by applying a set of minimal color grading tools using colorgrade_image(image,params) , in manner similar to Hable 2017 . Color grading corrections can be applied on images that are either linear HDR or sRGB encoded. The results is always an LDR image encoded in sRGB. Use colorgrade_image_mt(...) to quickly tone map large images using multiple threads. Several color corrections are bundled together with their parameters packed in a convenience structure colorgrade_params . Color grading operations are applied in a fixed sequence and consist of the following operations: exposure compensation, color tint, contrast in the log domain, filmic curve, conversion to sRGB, S-shaped contrast, saturation, and shadow/midtone/highlight correction. Color tinting can be used to apply white balance by using compute_white_balance(img) to determine the correct color. auto hdr = make_image ( w , h , true ); // initialize an HDR image auto params = colorgrade_params {}; // default color grading params params . exposure = 1 ; // set desired params params . logcontrast = 0.75 ; // set desired params params . tint = compute_white_balance ( hdr ); // apply white balance auto ldr = colorgrade_image ( hdr , params ); // color grading Images are can resized with resize_image(image,w,h) . Just like all other functions, images are not resized in placed, but a new image is created. Resizing works for both linear and 8bit images. auto img = make_image (...); // initialize an image auto res = resize_image ( img , 512 , 512 ); // resizing to fixed size auto asp = resize_image ( img , 512 , 0 ); // aspect-preserving Image differences can be computed using image_difference(a,b) . This function performs a simple per-pixel difference and returns the image so that one can use any metric to determine whether images where different within some threshold. Optionally, a difference image is returned that highlights the diff. auto a = make_image (...), b = make_image (...); // init images auto diff = image_difference ( a , b ); // image difference auto display = image_difference ( a , nb , true ); // diff display Procedural images Yocto/Image defines several procedural images used for both testing and to quickly create textures for procedural scenes. Testing patterns take as input the desired image size, the pattern scale, and optionally two colors to interpolate between. Use make_grid(...) for a grid image, make_checker(...) for a checker, make_bumps(...) for a bumpy test, make_ramp(...) for a linear ramp, make_gammaramp(...) for a ramp with different gamma settings, make_uvramp(...) and make_uvgrid(...) for test images for texture coordinates as either ramps or grids, make_colormapramp(...) for a ramp to test different color maps, and make_blackbodyramp(...) for a ramp with different blackbody temperatures. Perlin noise patterns can be generated with make_noisemap(...) , make_fbmmap(...) , make_fbmmap(...) and make_fbmmap(...) . The latter three functions take as input the set of params that control fractal variations. See Yocto/Noise for a description. auto w = 1024 , h = 1024 ; // image size auto scale = float { 1 }; // pattern scale auto c0 = vec4f { 0 , 0 , 0 , 1 }, c1 = vec4f { 0 , 0 , 0 , 1 }; // colors auto i1 = make_grid ( w , h , scale , c0 , c1 ); // grid image auto i2 = make_checker ( w , h , scale , c0 , c1 ); // checker image auto i3 = make_bumps ( w , h , scale , c0 , c1 ); // bumps image auto i4 = make_ramp ( w , h , scale , c0 , c1 ); // ramp image auto i5 = make_gammaramp ( w , h , scale , c0 , c1 ); // gamma ramp image auto i6 = make_uvramp ( w , h , scale ); // uv ramp image auto i7 = make_uvgrid ( w , h , scale ); // uv grid image auto i8 = make_colormapramp ( w , h , scale ); // color map image auto t0 = 1000 , t1 = 12000 ; // blackbody temperatures auto b2 = make_blackbodyramp ( w , h , scale , t0 , t1 ); // blackbody ramp image auto noise = vec4f { 2 , 0.5 , 8 , 1 }; // noise params auto n1 = make_noisemap ( w , h , scale , noise , c0 , c1 ); // noise image auto n2 = make_fbmmap ( w , h , scale , noise , c0 , c1 ); // fbm image auto n3 = make_turbulencemap ( w , h , scale , noise , c0 , c1 ); // turbulence image auto n4 = make_ridgemap ( w , h , scale , noise , c0 , c1 ); // ridge image Procedurals skies are generated with make_sunsky(img, w, h, elevation, turbidity, sun) . The function returns a procedural HDR sky. The sun position is controlled by its elevation that is an angle in [0,pi/2\\] . The sky turbidity is controlled by the turbidity parameter that is defined in the range [1.7,10] . The sun flag determines whether the sun disk is present in the image. The function support optional parameters to control sun size and intensity and ground albedo, mostly used for artistic effects. auto sky = make_sunsky ( 1024 , 512 , pi / 2 , 3 ); // clear sky auto sun = make_sunsky ( 1024 , 512 , pi / 2 , 3 , true ); // clear sky with sun auto tur = make_sunsky ( 1024 , 512 , pi / 2 , 10 ); // sky with turbidity Use bump_to_normal(bumps) to convert a bump map to a normal map, with both images stored in a linear color spaces. auto bumps = make_bumps ( 512 , 512 ); // procedural bump map auto normal = bump_to_normal ( bumps ); // convert bump map to normal map Finally, borders can be added to images using add_border(img,width,color) . auto bordered = add_border ( img , 1 , { 0 , 0 , 0 , 1 }); // add a thin black border Low-level operations Yocto/Image supports versions of the most of the above functions that work directly on pixel arrays, rather than the image structure. This low-level interface may be helpful when building applications that mhave their own image data structure. In this interface we support arrays of vec4f pixels together with arrays of vec4b pixels for 8bit images, the latter with a much smaller number of functions. In this case, the color space is handled in the application logic. Conversion between color types is handled with float_to_byte(pixels) , byte_tyo_float(pixels) , rgb_to_srgb(pixels) and srgb_to_rgb(pixels) . Since most of these functions have signatures similar to the ones above, we do not document here explicitly.","title":"Image utilities"},{"location":"yocto/yocto_image/#yoctoimage-image-utilities","text":"Yocto/Image is a collection of image utilities useful when writing rendering algorithms. These include a simple image data structure, color conversion utilities and tone mapping, and image resizing. Yocto/Image is implemented in yocto_image.h and yocto_image.cpp , and depends on stb_image_resize.h .","title":"Yocto/Image: Image utilities"},{"location":"yocto/yocto_image/#image-representation","text":"Images are represented as a simple struct called color_image , that stores the image width and height, a boolean flat that indicates whether the colors are in linear ot sRGB color space, and an array of pixels of vec4f type. While images can be constructed by direct manipulation of their values, th preferred way to construct images is by using the make_image(widgh, height, linear) function, where colors are default initialized to black. Image pixels are stored in row-major order and be accessed with index j * width + i . They can be conveniently accessed using get_pixel(image,i,j) and set_pixel(image,i,j,color) function. auto image = make_image ( 512 , 512 , false ); // creates a 512x512 sRGB image for ( auto & pixel : image . pixels ) // iterate over pixels print_info ( pixel ); auto color = get_pixel ( image , 128 , 128 ); // pixel access for ( auto j = 0 ; j < image . height ; j ++ ) // iterate over image rows for ( auto i = 0 ; i < image . width ; i ++ ) // iterate over row pixels print_info ( get_pixel ( image , i , j )); Images are sampled with eval_image(img,uv,...) , where uv are in the [0,1]x[0,1] range. By default, image values are returned in the color space of the image, but can be forced to to be linear. By default, images are sampled with bilinear interpolation and tiling, with nearest-neighbor interpolation and edge-clamp behavior available as overrides. auto hdr = make_image ( w , h , true ); // creates a linear image auto ch0 = eval_image ( hdr , { 0.5 , 0.5 }); // samples the image center auto ch1 = eval_image ( hdr , { 0.5 , 0.5 }, false , false ); // no interpolation auto ch2 = eval_image ( hdr , { 0.5 , 0.5 }, false , false , false ); // clamp to edge auto ldr = make_image ( w , h , false ); // creates a sRGB image auto ch0 = eval_image ( ldr , { 0.5 , 0.5 }); // samples in sRGB, returns as sRGB auto ch1 = eval_image ( ldr , { 0.5 , 0.5 }, true ); // treats sRGB values as linear Image loading and saving is defined in Yocto/SceneIO .","title":"Image representation"},{"location":"yocto/yocto_image/#image-utilities","text":"Images can be converted between linear RGB and sRGB color space using convert_image(image,linear) . auto linear = make_image ( w , h , true ); // initialize a linear image auto srgb = convert_image ( w , h , false ); // convert to sRGB HDR images can be tone mapped using tonemap_image(hdr,exposure,filmic) that applies an exposure correction followed by an optional filmic tone curve. Use tonemap_image_mt(...) to quickly tone map large images using multiple threads. auto hdr = make_image ( w , h , true ); // initialize am HDR image auto ldr = tonemap_image ( hdr , 2 ); // tone mapping with exposure 2 auto flm = tonemap_image ( hdr , 2 , true ); // filmic tone mapping Images can be color graded by applying a set of minimal color grading tools using colorgrade_image(image,params) , in manner similar to Hable 2017 . Color grading corrections can be applied on images that are either linear HDR or sRGB encoded. The results is always an LDR image encoded in sRGB. Use colorgrade_image_mt(...) to quickly tone map large images using multiple threads. Several color corrections are bundled together with their parameters packed in a convenience structure colorgrade_params . Color grading operations are applied in a fixed sequence and consist of the following operations: exposure compensation, color tint, contrast in the log domain, filmic curve, conversion to sRGB, S-shaped contrast, saturation, and shadow/midtone/highlight correction. Color tinting can be used to apply white balance by using compute_white_balance(img) to determine the correct color. auto hdr = make_image ( w , h , true ); // initialize an HDR image auto params = colorgrade_params {}; // default color grading params params . exposure = 1 ; // set desired params params . logcontrast = 0.75 ; // set desired params params . tint = compute_white_balance ( hdr ); // apply white balance auto ldr = colorgrade_image ( hdr , params ); // color grading Images are can resized with resize_image(image,w,h) . Just like all other functions, images are not resized in placed, but a new image is created. Resizing works for both linear and 8bit images. auto img = make_image (...); // initialize an image auto res = resize_image ( img , 512 , 512 ); // resizing to fixed size auto asp = resize_image ( img , 512 , 0 ); // aspect-preserving Image differences can be computed using image_difference(a,b) . This function performs a simple per-pixel difference and returns the image so that one can use any metric to determine whether images where different within some threshold. Optionally, a difference image is returned that highlights the diff. auto a = make_image (...), b = make_image (...); // init images auto diff = image_difference ( a , b ); // image difference auto display = image_difference ( a , nb , true ); // diff display","title":"Image utilities"},{"location":"yocto/yocto_image/#procedural-images","text":"Yocto/Image defines several procedural images used for both testing and to quickly create textures for procedural scenes. Testing patterns take as input the desired image size, the pattern scale, and optionally two colors to interpolate between. Use make_grid(...) for a grid image, make_checker(...) for a checker, make_bumps(...) for a bumpy test, make_ramp(...) for a linear ramp, make_gammaramp(...) for a ramp with different gamma settings, make_uvramp(...) and make_uvgrid(...) for test images for texture coordinates as either ramps or grids, make_colormapramp(...) for a ramp to test different color maps, and make_blackbodyramp(...) for a ramp with different blackbody temperatures. Perlin noise patterns can be generated with make_noisemap(...) , make_fbmmap(...) , make_fbmmap(...) and make_fbmmap(...) . The latter three functions take as input the set of params that control fractal variations. See Yocto/Noise for a description. auto w = 1024 , h = 1024 ; // image size auto scale = float { 1 }; // pattern scale auto c0 = vec4f { 0 , 0 , 0 , 1 }, c1 = vec4f { 0 , 0 , 0 , 1 }; // colors auto i1 = make_grid ( w , h , scale , c0 , c1 ); // grid image auto i2 = make_checker ( w , h , scale , c0 , c1 ); // checker image auto i3 = make_bumps ( w , h , scale , c0 , c1 ); // bumps image auto i4 = make_ramp ( w , h , scale , c0 , c1 ); // ramp image auto i5 = make_gammaramp ( w , h , scale , c0 , c1 ); // gamma ramp image auto i6 = make_uvramp ( w , h , scale ); // uv ramp image auto i7 = make_uvgrid ( w , h , scale ); // uv grid image auto i8 = make_colormapramp ( w , h , scale ); // color map image auto t0 = 1000 , t1 = 12000 ; // blackbody temperatures auto b2 = make_blackbodyramp ( w , h , scale , t0 , t1 ); // blackbody ramp image auto noise = vec4f { 2 , 0.5 , 8 , 1 }; // noise params auto n1 = make_noisemap ( w , h , scale , noise , c0 , c1 ); // noise image auto n2 = make_fbmmap ( w , h , scale , noise , c0 , c1 ); // fbm image auto n3 = make_turbulencemap ( w , h , scale , noise , c0 , c1 ); // turbulence image auto n4 = make_ridgemap ( w , h , scale , noise , c0 , c1 ); // ridge image Procedurals skies are generated with make_sunsky(img, w, h, elevation, turbidity, sun) . The function returns a procedural HDR sky. The sun position is controlled by its elevation that is an angle in [0,pi/2\\] . The sky turbidity is controlled by the turbidity parameter that is defined in the range [1.7,10] . The sun flag determines whether the sun disk is present in the image. The function support optional parameters to control sun size and intensity and ground albedo, mostly used for artistic effects. auto sky = make_sunsky ( 1024 , 512 , pi / 2 , 3 ); // clear sky auto sun = make_sunsky ( 1024 , 512 , pi / 2 , 3 , true ); // clear sky with sun auto tur = make_sunsky ( 1024 , 512 , pi / 2 , 10 ); // sky with turbidity Use bump_to_normal(bumps) to convert a bump map to a normal map, with both images stored in a linear color spaces. auto bumps = make_bumps ( 512 , 512 ); // procedural bump map auto normal = bump_to_normal ( bumps ); // convert bump map to normal map Finally, borders can be added to images using add_border(img,width,color) . auto bordered = add_border ( img , 1 , { 0 , 0 , 0 , 1 }); // add a thin black border","title":"Procedural images"},{"location":"yocto/yocto_image/#low-level-operations","text":"Yocto/Image supports versions of the most of the above functions that work directly on pixel arrays, rather than the image structure. This low-level interface may be helpful when building applications that mhave their own image data structure. In this interface we support arrays of vec4f pixels together with arrays of vec4b pixels for 8bit images, the latter with a much smaller number of functions. In this case, the color space is handled in the application logic. Conversion between color types is handled with float_to_byte(pixels) , byte_tyo_float(pixels) , rgb_to_srgb(pixels) and srgb_to_rgb(pixels) . Since most of these functions have signatures similar to the ones above, we do not document here explicitly.","title":"Low-level operations"},{"location":"yocto/yocto_math/","text":"Yocto/Math: Math types Yocto/Math defines the basic math primitives used in graphics, including small-sized vectors, matrices, frames and quaternions, and their transforms. Yocto/Math is implemented in yocto_math.h . Vectors The most basic types defined in Yocto/Math are fixed-length vectors in 1 to 4 dimensions with either float or int coordinates, namely vec1f , vec2f , vec3f , vec4f , vec1i , vec2i , vec3i , vec4i . One-dimensional vectors are defined for completeness. Vectors coordinates are default-initialized to zeros. Vectors are constructed by specifying all their coordinates. For convenience, Yocto/Math defines common constants, i.e. zeroXX , to initialize zero vectors. Vector coordinates are accessed by index, e.g. v[0] , or by name, using v.x , v.y , v.z , v.w . While in graphics it is common to use the latter, we suggest to instead use the former since it better generalizes to different cases. Vectors support component-wise arithmetic, equality and assignment operators. For arithmetic operators, both vector and scalar operands are supported. Yocto/Math also overrides many common math function to work on vectors by component-wise evaluation, including trigonometric and exponentiation functions, and component-wise abs, max, min and clamp. Real vector types additionally support vector products and lengths. For 3D vectors, we also define reflection and refraction vectors following GLSL. Matrices Yocto/Math supports 2-4 dimensional square matrices, namely mat2f , mat3f and mat4f . Matrices are stored on column-major order. Matrices are initialized to the identity matrix and constructed by passing matrix columns. Matrix columns are accessed using indexing, i.e. mat[col] . Yocto/Math defines convenience constants for common matrices, e.g. indentity3x3f , etc. Matrices support linear algebra summation and scaling operations, component-wise equality, matrix-matrix and matrix-vector products. All these operators use standard math notation. Matrices also support the computation of transpose, inverse and adjoint matrices, with transpose(a) , inverse(a) and adjoint(a) . Frames To represent transformations, most of the library facilities prefer the use coordinate frames, aka rigid transforms, represented as frame2f and frame3f . Frames are represented in column-major order, with columns defined as the axis of the coordinate frame followed by the origin. This is equivalent to representing rigid transformations as column-major affine matrices. Use mat_to_frame(mat) and frame_to_mat(frame) to convert between these types. Frames support only multiplication operations with other frames, to chain transforms, the computation of their inverses, with inverse(f) , and the creation of frames aligned with one ot two axis, i.e. frame_fromz(o,z) and frame_fromxz(o,z,x) . For the inverse computation, the default is to assume that the frame is orthonormal to get a fast answer. This can be overridden as shown in the example. auto f1 = frame3f { x , y , z , o }; // construct a frame from axes and origin auto of = inverse ( f1 ); // assume f is orthonormal auto gf = inverse ( f1 , true ); // treat f as a generic affine matrix Quaternions Quaternions are represented as quat4f . Quaternions support is minimal and focuses on representing rotations, i.e. unit quaternions. Quaternions are initialized to a unit quaternion, that can also be set with the convenience constant identityq4f . Quaternions support addition, multiplication and scaling, together with dot(q1,q2) , length(q) and normalize(q) . For unit quaternions, Yocto/Math also defines the quaternion inverse inverse(q) and several interpolation function including linear interpolation, normalized linear interpolation and spherical interpolation, respectively with lerp(a,bt) , nlerp(a,b,t) and slerp(a,b,t) . Transforms Yocto/Math uses linear algebra vectors for holding different geometric quantities, such as points, vectors, directions and normals. For this reason, we define different functions to transform these quantities, namely transform_point(f,p) to transform points, transform_vector(f,v) to transform vectors, transform_direction(f,d) to transform directions intended as normalized vectors, and transform_normal(f,n) to transform normals. Yocto/Math provides overrides to transforms for both frames and matrices, but the preferred transform representation in Yocto/GL are frames . When transforming normals by matrices, the inverse transform is computed on the fly for correctness. When transforming normals by frames, frames are assumed to be orthonormal and used as is, unless specifically requested as for inverses. For convenience, Yocto/Math provides several functions to construct transform frames and matrices. Translation, rotation and scaling frames are created with translation_frame(t) , rotation_frame(r) and scaling_frame(s) . Rotation frames can be derived from axis-angle, quaternion and matrix representations. To define camera frames, one can use lookat_frame(from,to,up) . auto f = tranlation_frame ({ 1 , 0 , 0 }) * rotation_frame ({ 0 , 1 , 0 }, pi / 2 ); // transform auto lp = vec3f { 1 , 2 , 3 }, lv = vec3f { 0 , 2 , 3 }; // point and vector in local coords auto wp = transform_point ( f , lp ); // point in world coords auto wv = transform_vector ( f , lv ); // vector in world coords For use in GPU programming, Yocto/Math also defines various projection matrices in the style of GLU/GLM, namely frustum_mat(...) , ortho_mat(...) , ortho2d_mat(...) , and perspective_mat(...) . User-Interface Transforms Yocto/Math provides a few utilities for writing user interfaces for 2D images and 3D environments. For images, we assume that image are scaled and than translated to be place oin screen. User interfaces can directly manipulate the translation and zoom without further helpers. Yocto/Math just provides convenience functions for centering an image and compute a mouse to image coordinate transformation. auto image_size = vec2i { 512 , 512 }, window_size = vec2i { 1024 , 768 }; auto image_center = vec2f { 100 , 100 }; auto image_scale = float { 1 }; // get image coordinates from mouse auto ij = get_image_coords ( mouse_pos , image_center , image_scale , image_size ); // center image by setting image_center and image_scale update_imview ( image_center , image_scale , image_size , window_size , false ); // center image and for to screen by setting image_center and image_scale update_imview ( image_center , image_scale , image_size , window_size , true ); For 3D cameras, Yocto/Math supports a turntable interface, inspired by many 3D editors, with update_turntable(...) , and the camera's rays generation with camera_ray(...) . auto camera_frame = identity3x4f ; auto camera_focus = float { 10 }; // update camera position and focus update_turntable ( camera_frame , camera_focus , rotate , dolly , pan ); // turntable udpates works also for camera with explicit lookat parametrizations update_turntable ( camera_from , camera_to , camera_up , rotate , dolly , pan ); // generation of camera rays auto ray = camera_ray ( camera_frame , lens , aspect , film , image_uv );","title":"Math types"},{"location":"yocto/yocto_math/#yoctomath-math-types","text":"Yocto/Math defines the basic math primitives used in graphics, including small-sized vectors, matrices, frames and quaternions, and their transforms. Yocto/Math is implemented in yocto_math.h .","title":"Yocto/Math: Math types"},{"location":"yocto/yocto_math/#vectors","text":"The most basic types defined in Yocto/Math are fixed-length vectors in 1 to 4 dimensions with either float or int coordinates, namely vec1f , vec2f , vec3f , vec4f , vec1i , vec2i , vec3i , vec4i . One-dimensional vectors are defined for completeness. Vectors coordinates are default-initialized to zeros. Vectors are constructed by specifying all their coordinates. For convenience, Yocto/Math defines common constants, i.e. zeroXX , to initialize zero vectors. Vector coordinates are accessed by index, e.g. v[0] , or by name, using v.x , v.y , v.z , v.w . While in graphics it is common to use the latter, we suggest to instead use the former since it better generalizes to different cases. Vectors support component-wise arithmetic, equality and assignment operators. For arithmetic operators, both vector and scalar operands are supported. Yocto/Math also overrides many common math function to work on vectors by component-wise evaluation, including trigonometric and exponentiation functions, and component-wise abs, max, min and clamp. Real vector types additionally support vector products and lengths. For 3D vectors, we also define reflection and refraction vectors following GLSL.","title":"Vectors"},{"location":"yocto/yocto_math/#matrices","text":"Yocto/Math supports 2-4 dimensional square matrices, namely mat2f , mat3f and mat4f . Matrices are stored on column-major order. Matrices are initialized to the identity matrix and constructed by passing matrix columns. Matrix columns are accessed using indexing, i.e. mat[col] . Yocto/Math defines convenience constants for common matrices, e.g. indentity3x3f , etc. Matrices support linear algebra summation and scaling operations, component-wise equality, matrix-matrix and matrix-vector products. All these operators use standard math notation. Matrices also support the computation of transpose, inverse and adjoint matrices, with transpose(a) , inverse(a) and adjoint(a) .","title":"Matrices"},{"location":"yocto/yocto_math/#frames","text":"To represent transformations, most of the library facilities prefer the use coordinate frames, aka rigid transforms, represented as frame2f and frame3f . Frames are represented in column-major order, with columns defined as the axis of the coordinate frame followed by the origin. This is equivalent to representing rigid transformations as column-major affine matrices. Use mat_to_frame(mat) and frame_to_mat(frame) to convert between these types. Frames support only multiplication operations with other frames, to chain transforms, the computation of their inverses, with inverse(f) , and the creation of frames aligned with one ot two axis, i.e. frame_fromz(o,z) and frame_fromxz(o,z,x) . For the inverse computation, the default is to assume that the frame is orthonormal to get a fast answer. This can be overridden as shown in the example. auto f1 = frame3f { x , y , z , o }; // construct a frame from axes and origin auto of = inverse ( f1 ); // assume f is orthonormal auto gf = inverse ( f1 , true ); // treat f as a generic affine matrix","title":"Frames"},{"location":"yocto/yocto_math/#quaternions","text":"Quaternions are represented as quat4f . Quaternions support is minimal and focuses on representing rotations, i.e. unit quaternions. Quaternions are initialized to a unit quaternion, that can also be set with the convenience constant identityq4f . Quaternions support addition, multiplication and scaling, together with dot(q1,q2) , length(q) and normalize(q) . For unit quaternions, Yocto/Math also defines the quaternion inverse inverse(q) and several interpolation function including linear interpolation, normalized linear interpolation and spherical interpolation, respectively with lerp(a,bt) , nlerp(a,b,t) and slerp(a,b,t) .","title":"Quaternions"},{"location":"yocto/yocto_math/#transforms","text":"Yocto/Math uses linear algebra vectors for holding different geometric quantities, such as points, vectors, directions and normals. For this reason, we define different functions to transform these quantities, namely transform_point(f,p) to transform points, transform_vector(f,v) to transform vectors, transform_direction(f,d) to transform directions intended as normalized vectors, and transform_normal(f,n) to transform normals. Yocto/Math provides overrides to transforms for both frames and matrices, but the preferred transform representation in Yocto/GL are frames . When transforming normals by matrices, the inverse transform is computed on the fly for correctness. When transforming normals by frames, frames are assumed to be orthonormal and used as is, unless specifically requested as for inverses. For convenience, Yocto/Math provides several functions to construct transform frames and matrices. Translation, rotation and scaling frames are created with translation_frame(t) , rotation_frame(r) and scaling_frame(s) . Rotation frames can be derived from axis-angle, quaternion and matrix representations. To define camera frames, one can use lookat_frame(from,to,up) . auto f = tranlation_frame ({ 1 , 0 , 0 }) * rotation_frame ({ 0 , 1 , 0 }, pi / 2 ); // transform auto lp = vec3f { 1 , 2 , 3 }, lv = vec3f { 0 , 2 , 3 }; // point and vector in local coords auto wp = transform_point ( f , lp ); // point in world coords auto wv = transform_vector ( f , lv ); // vector in world coords For use in GPU programming, Yocto/Math also defines various projection matrices in the style of GLU/GLM, namely frustum_mat(...) , ortho_mat(...) , ortho2d_mat(...) , and perspective_mat(...) .","title":"Transforms"},{"location":"yocto/yocto_math/#user-interface-transforms","text":"Yocto/Math provides a few utilities for writing user interfaces for 2D images and 3D environments. For images, we assume that image are scaled and than translated to be place oin screen. User interfaces can directly manipulate the translation and zoom without further helpers. Yocto/Math just provides convenience functions for centering an image and compute a mouse to image coordinate transformation. auto image_size = vec2i { 512 , 512 }, window_size = vec2i { 1024 , 768 }; auto image_center = vec2f { 100 , 100 }; auto image_scale = float { 1 }; // get image coordinates from mouse auto ij = get_image_coords ( mouse_pos , image_center , image_scale , image_size ); // center image by setting image_center and image_scale update_imview ( image_center , image_scale , image_size , window_size , false ); // center image and for to screen by setting image_center and image_scale update_imview ( image_center , image_scale , image_size , window_size , true ); For 3D cameras, Yocto/Math supports a turntable interface, inspired by many 3D editors, with update_turntable(...) , and the camera's rays generation with camera_ray(...) . auto camera_frame = identity3x4f ; auto camera_focus = float { 10 }; // update camera position and focus update_turntable ( camera_frame , camera_focus , rotate , dolly , pan ); // turntable udpates works also for camera with explicit lookat parametrizations update_turntable ( camera_from , camera_to , camera_up , rotate , dolly , pan ); // generation of camera rays auto ray = camera_ray ( camera_frame , lens , aspect , film , image_uv );","title":"User-Interface Transforms"},{"location":"yocto/yocto_mesh/","text":"Yocto/Mesh: Mesh processing Yocto/Mesh is a collection of computational geometry functions on triangle meshes. Yocto/Mesh is implemented in yocto_mesh.h and yocto_mesh.cpp . This library is experimental and will be documented appropriately when the code reaches stability.","title":"Mesh processing"},{"location":"yocto/yocto_mesh/#yoctomesh-mesh-processing","text":"Yocto/Mesh is a collection of computational geometry functions on triangle meshes. Yocto/Mesh is implemented in yocto_mesh.h and yocto_mesh.cpp . This library is experimental and will be documented appropriately when the code reaches stability.","title":"Yocto/Mesh: Mesh processing"},{"location":"yocto/yocto_modelio/","text":"Yocto/ModelIO: Serialization for Obj, Ply and Pbrt models Yocto/ModelIO is a collection of utilities for loading and saving scenes and meshes in Ply, Obj, Stl and Pbrt formats. Yocto/ModelIO is implemented in yocto_modelio.h and yocto_modelio.cpp . Ply models The Ply file format is a generic file format used to serialize meshes and point clouds. To use this library is helpful to understand the basic of the Ply file format for example from the Ply Wikipedia page . Yocto/ModelIO represents Ply data with the ply_model struct. The internal representation matches the structure of a Ply file and can be accessed directly if desired. The Ply model is defined as an array of Ply elements, which in turn are defined as arrays of Ply properties. Ply properties can contain most C data types. All elements and properties are owned by the main ply_model . Yocto/ModelIO provides several functions to read and write Ply data whose use is preferred over direct data access. Use load_ply(filename, ply, error) to load Ply files and save_ply(filename, ply, error) to save them. Both loading and saving take a filename, a reference to a Ply model, and returns whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto ply = ply_model {}; // ply model buffer auto error = string {}; // error buffer if ( ! load_ply ( filename , ply , error )) // load ply print_error ( error ); // check and print error if ( ! save_ply ( filename , ply , error )) // save ply print_error ( error ); // check and print error Ply reading Yocto/ModelIO defines several functions to make it easy to extract data from Ply files. Since Ply properties cane be stored with many different C types, the convenience functions convert the various underlying representations to the requested one. Use has_property(ply,element,property) to check whether the model has a property named property in an element named element . Use get_property(ply,element,property) to get that property. Use get_value(ply, element, property, values) to get the property values and stored them in the array values . The function returns whether or not the property was present. Since Ply properties are often stored together, e.g. xyz coordinates, Yocto/ModelIO supports queries that take arrays of properties and returns values packed in vecXf . Use get_values(ply, element, properties, values) to read arrays of properties. For list properties, Yocto/ModelIO supports reading properties as arrays of arrays of dynamic size with get_lists(ply,element,property,lists) . A faster, but harder to use, method is to get lists sizes and values as separate arrays, where list values are packed together to avoid small memory allocations. Use get_list_sizes(ply, element, property, sizes) for sizes and get_list_values(ply, element, property, values) for values. auto ply = ply_model {}; // ply model buffer auto error = string {}; // error buffer load_ply ( filename , ply , error ); // load ply auto radius = vector < float > {}; // property buffer if ( ! get_value ( ply , \"vertex\" , \"radius\" , radius )) // read property print_error ( \"missing radius\" ); // error if missing auto positions = vector < vec3f > {}; // properties buffer if ( ! get_values ( ply , \"vertex\" , { \"x\" , \"y\" , \"z\" }, positions )) // read properties print_error ( \"missing positions\" ); // error if missing auto faces = vector < vector < int >> {}; // list property buffer if ( ! get_lists ( ply , \"face\" , \"indices\" , faces )) // read lists print_error ( \"missing faces\" ); // error if missing auto faces_sizes = vector < int > {}; // list property sizes auto faces_values = vector < int > {}; // list property values if ( ! get_list_sizes ( ply , \"face\" , \"indices\" , faces_sizes )) // read lists sizes print_error ( \"missing faces\" ); // error if missing if ( ! get_list_values ( ply , \"face\" , \"indices\" , faces_values )) // read lists values print_error ( \"missing faces\" ); // error if missing Yocto/Shape defines convenience functions to read the most used properties of meshes, using standard element and property names. For vertex properties, use get_positions(ply, positions) , get_normals(ply, normals) , get_texcoords(ply, texcoords, flipv) , get_colors(ply, colors) , and get_radius(ply, radius) to read positions, normals, texcoords, colors and radius if present. Texture coordinates can be optionally flipped vertically. For shape elements, use get_points(ply, points) , get_lines(ply, lines) , get_triangles(ply, triangles) , and get_quads(ply, quads) , to read points, lines, triangles and quads. Note that since Ply support arbitrary polygons and polylines, these functions tesselate the Ply polygons into the desired element type, for now using a simple fan-like algorithm that works only for convex elements. Use has_quads(ply) to check whether the Ply data has quads, or use get_faces(ply, triangles, quads) to triangles or quads. auto ply = ply_model {}; // ply model buffer auto error = string {}; // error buffer load_ply ( filename , ply , error ); // load ply auto positions = vector < vec3f > {}; // vertex properties buffers auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto colors = vector < vec3f > {}; auto radius = vector < float > {}; get_positions ( ply , positions ); // read vertex props. get_normals ( ply , normals ); get_texcoords ( ply , texcoords , false ); // last params, flips y is desired get_colors ( ply , colors ); get_radius ( ply , radius ); auto points = vector < vec4i > {}; // shape elements buffers auto lines = vector < vec4i > {}; auto triangles = vector < vec4i > {}; auto quads = vector < vec4i > {}; get_points ( ply , points ); get_lines ( ply , lines ); if ( has_quads ( ply )) get_quads ( ply , quads ); else get_triangles ( ply , triangles ); Ply writing Yocto/ModelIO defines several functions to make it easy to fill Ply data to save to file. Since Ply properties cane be stored with many different C types, the convenience functions maintain the same data type of the data passed in without performing any conversion. Use add_value(ply, element, property, values) to add the property values stored them in the array values . The function returns whether or not the property was successfully added. Since Ply properties are often stored together, e.g. xyz coordinates, Yocto/ModelIO supports adding arrays of properties whose values are packed in vecXf . Use add_values(ply, element, properties, values) to add arrays of properties. For list properties, Yocto/ModelIO supports adding list properties as arrays of arrays of dynamic size with add_lists(ply,element,property,lists) . A faster, but harder to use, method is to add lists sizes and values as separate arrays, where list values are packed together to avoid small memory allocations. Use add_lists(ply, element, property, sizes, values) . Finally, Yocto/ModelIO supports adding lists of fixed lengths, where the parameters are packed into vecXi , with add_lists(ply,element,property,values) . auto ply = ply_model {}; // ply model buffer auto radius = vector < float > {...}; // property buffer if ( ! add_value ( ply , \"vertex\" , \"radius\" , radius )) // add property print_error ( \"error in radius\" ); // error if missing auto positions = vector < vec3f > {...}; // properties buffer if ( ! add_values ( ply , \"vertex\" , { \"x\" , \"y\" , \"z\" }, positions )) // add properties print_error ( \"missing positions\" ); // error if missing auto faces = vector < vector < int >> {...}; // list property buffer if ( ! add_lists ( ply , \"face\" , \"indices\" , faces )) // add lists print_error ( \"missing faces\" ); // error if missing auto faces_sizes = vector < int > {...}; // list property sizes auto faces_values = vector < int > {...}; // list property values if ( ! add_lists ( ply , \"face\" , \"indices\" , faces_sizes , face_values )) // add lists print_error ( \"missing faces\" ); // error if missing auto triangles = vector < vec3i > {...}; // fixed length list property if ( ! add_lists ( ply , \"face\" , \"indices\" , triangles )) // add lists print_error ( \"missing faces\" ); // error if missing auto error = string {}; // error buffer save_ply ( filename , ply , error ); // save ply Yocto/ModelIO defines convenience functions to add the most used properties of meshes, using standard element and property names. For vertex properties, use add_positions(ply, positions) , add_normals(ply, normals) , add_texcoords(ply, texcoords, flipv) , add_colors(ply, colors) , and add_radius(ply, radius) to read positions, normals, texcoords, colors and radius if present. Texture coordinates can be optionally flipped vertically. For shape elements, use add_points(ply, points) , add_lines(ply, lines) , add_triangles(ply, triangles) , and add_quads(ply, quads) , to add points, lines, triangles and quads. Use add_faces(ply, faces) to add arbitrary polygonal faces. auto ply = ply_model {}; // ply model buffer auto positions = vector < vec3f > {...}; // vertex properties buffers auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto colors = vector < vec3f > {...}; auto radius = vector < float > {...}; add_positions ( ply , positions ); // add vertex props. add_normals ( ply , normals ); add_texcoords ( ply , texcoords , false ); // last params, flips y is desired add_colors ( ply , colors ); add_radius ( ply , radius ); auto points = vector < vec4i > {...}; // shape elements buffers auto lines = vector < vec4i > {...}; auto triangles = vector < vec4i > {...}; auto quads = vector < vec4i > {...}; add_points ( ply , points ); // add shape elements add_lines ( ply , lines ); add_triangles ( ply , triangles ); add_quads ( ply , quads ); auto error = string {}; // error buffer save_ply ( filename , ply , error ); // save ply Obj models The Obj file format is a file format used to serialize meshes and materials. To use this library is helpful to understand the basic of the Obj file format for example from the Obj Wikipedia page . Obj files come in pairs, .obj for shapes and .mtl for materials. Yocto/ModelIO represents Obj data with the obj_model struct. Obj models are defined as collections of shapes and materials. Obj shapes use a face-varying representation that has vertex positions, normals and texture coordinates, with their their own topology. In a shape, each face is tagged with a material used for that face. Yocto/ModelIO provides direct access to these tagged shapes by inspecting the obj_shape properties. In Yocto/Obj, materials are represented by the obj_material struct. Each material is a collection of values and textures that specify the material lobes, like emission, diffuse, specular, reflection, etc. Each value has a corresponding texture stored as an index to the texture array. Yocto/ModelIO defines two extensions to the Obj file format. Yocto/ModelIO adds another file, namely .obx , that stores cameras and environment maps, respectively as obj_camera and obj_environment . T his addition makes the extended Obj format capable of storing full scenes. The Obj model is defined as an array of objects of the types defined above. Obj objects are pointers owned by the main obj_model . Objects properties can be read and written directly from the model data, and are documented in the header file for now. For shapes, Yocto/ModelIO provides several functions to read and write Obj shapes, with a simpler interface than accessing data directly. auto obj = obj_model {...}; // obj model buffer for ( auto shape : obj . shapes ) // access shapes print_info ( shape . name ); // access shape properties for ( auto material : obj . material ) // access materials print_info ( material . diffuse ); // access material properties for ( auto material : obj . material ) // access materials print_info ( material . diffuse_tex ); // access material textures for ( auto camera : obj . cameras ) // access cameras [extension] print_info ( camera . frame ); // access camera properties for ( auto environment : obj . environments ) // access environments [extension] print_info ( environment . emission ); // access environment properties Use load_obj(filename, obj, error) to load Obj files and save_obj(filename, obj, error) to save them. Both loading and saving take a filename, a reference to an Obj model, and return whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Obj is a face-varying file format, while most applications handle only indexed meshes. The loading function takes an optional that specify whether to load as face-varying or convert to indexed meshes, which is the default. auto obj = obj_model {}; // obj model auto error = string {}; // error if ( ! load_obj ( filename , obj , error )) // load obj as indexed meshes print_error ( error ); // check and print error if ( ! load_obj ( filename , obj , error , true )) // load obj as face-varying print_error ( error ); // check and print error if ( ! save_obj ( filename , obj , error )) // save obj print_error ( error ); // check and print error It is common in graphics to use Obj file to store single meshes. Yocto/Obj supports this modality by providing specialized loading and saving functions that take references to shapes as parameters. Use load_obj(filename, shape, error) to load Obj shapes and save_obj(filename, shape, error) to save them. The loading function takes an optional that specify whether to load as face-varying or convert to indexed meshes, which is the default. auto shape = obj_shape {}; // obj shape auto error = string {}; // error if ( ! load_obj ( filename , shape , error )) // load obj as indexed meshes print_error ( error ); // check and print error if ( ! load_obj ( filename , shape , error , true )) // load obj as face-varying print_error ( error ); // check and print error if ( ! save_obj ( filename , shape , error )) // save obj print_error ( error ); // check and print error Obj reading Obj is a face-varying format and that geometry representation is maintained in obj_shape . Yocto/ModelIO provides easier accessed to Obj shape data, both as indexed meshes and as face-varying meshes. Use get_positions(shape, positions) , get_normals(shape, normals) , get_texcoords(shape, texcoords, flipv) , to read positions, normals, texcoords, if present. Texture coordinates can be optionally flipped vertically. For shape elements, use get_points(shape, points, materials) , get_lines(shape, lines, materials) , get_triangles(shape, triangles, materials) , and get_quads(shape, quads, materials) , to read points, lines, triangles and quads. Note that since Obj support arbitrary polygons and polylines, these functions tesselate the Obj polygons into the desired element type, for now using a simple fan-like algorithm that works only for convex elements. Use has_quads(shape) to check whether the Obj data has quads, or use get_faces(shape, triangles, quads, materials) to triangles or quads. In some cases, it may be desireable to extract the shape elements corresponding to a single material, for example for use in renderers that support a single shader per shape. To filtering elements by material index use get_points(shape, material, points) , get_lines(shape, material, lines) , get_triangles(shape, material, triangles) , and get_quads(shape, material, quads) . that are overrides of the previous get_<element>(...) functions, but differ in that they take a material is as input, instead of returning materials tags. auto obj = obj_model {}; // obj model buffer auto error = string {}; // error buffer load_obj ( filename , obj , error ); // load obj auto & shape = obj . shapes . front (); // get shape auto positions = vector < vec3f > {}; // vertex properties get_positions ( shape , positions ); auto normals = vector < vec3f > {}; get_normals ( shape , normals ); auto texcoords = vector < vec2f > {}; get_texcoords ( shape , texcoords ); auto triangles = vector < vec3i > {}; // element data auto quads = vector < vec4i > {}; auto materials = vector < int > {}; // per-face material ids if ( has_quads ( shape )) { get_triangles ( shape , triangles , materials ); // read as triangles } else { get_quads ( shape , quads , materials ); // read as quads } auto material_id = 0 ; // material id to extract to if ( has_quads ( shape )) { get_triangles ( shape , material_id , triangles ); // read as triangles } else { get_quads ( shape , material_id , quads ); // read as quads } Yocto/ModelIO supports also reading Obj shapes as face-varying quads with get_fvquads(...) . In this case, the model should be loaded as face-varying. auto obj = new obj_model {}; // obj model buffer auto error = string {}; // error buffer load_obj ( filename , obj , error , true ); // load obj as face-varying auto & shape = obj . shapes . front (); // get shape auto positions = vector < vec3f > {}; // vertex properties get_positions ( shape , positions ); auto normals = vector < vec3f > {}; get_normals ( shape , normals ); auto texcoords = vector < vec2f > {}; get_texcoords ( shape , texcoords ); auto quadspos = vector < vec4i > {}; // face-varying element data auto quadsnorm = vector < vec4i > {}; auto quadsuv = vector < vec4i > {}; auto materials = vector < int > {}; // per-face material ids get_fvquads ( shape , // read as face-varying quads quadspos , quadsnorm , quadsuv , materias ); Obj writing To save an Obj, create a scene and add objects to it by manipulating the objects' arrays directly. For all objects, set the objects' properties directly. For shapes, Yocto/ModelIO defines convenience functions that take either indexed mesh or face-varying meshes as input and create the appropriate Obj shape elements. Use add_positions(shape, positions) , add_normals(shape, normals) and add_texcoords(shape, texcoords, flipv) to add vertex properties to a shape. Use add_triangles(shape, triangles, material, has_normals, has_texcoords) , add_quads(shape, quads, material, has_normals, has_texcoords) , add_lines(shape, lines, material, has_normals, has_texcoords) , add_points(shape, points, material, has_normals, has_texcoords) to add triangles, quads, lines or points to shapes respectively. Material data is only represented as tags and can be left empty if only one material is used. To set material names use set_materials(shape, materials) . To add face-varying shapes, use add_fvquads(...) . auto obj = obj_model {}; // obj model auto camera = obj_camera {}; // init camera camera . name = \"camera\" ; // set camera name camera . frame = identity3x4f ; // set camera properties obj . cameras . push_back ( camera ); // add camera auto environment = add_environment ( obj ); // init environment environment . name = \"environment\" ; // set environment name environment . emission = { 1 , 1 , 1 }; // set environment properties obj . environments . push_back ( environment ); // add environment auto material = add_material ( obj ); // init material material . name = \"material\" ; // set material name material . diffuse = { 1 , 0 , 0 }; // set material properties obj . materials . push_back ( material ); // add material auto triangles = vector < vec3i > {...}; // element data auto positions = vector < vec3f > {...}; // vertex properties auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto shape = obj_shape {}; // init shape shape . name = \"shape\" ; // set shape name add_triangles ( shape , triangles , 0 ); // set shape geometry add_positions ( shape , positions ); add_normals ( shape , normals ); add_texcoords ( shape , texcoords ); auto error = string {}; // error buffer save_obj ( filename , obj , error ); // save obj And similarly for face-varying shapes. auto obj = obj_model {}; // obj model buffer auto quadspos = vector < vec4i > {...}; // face-varying element data auto quadsnorm = vector < vec4i > {...}; auto quadsuv = vector < vec4i > {...}; auto positions = vector < vec3f > {...}; // vertex properties auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > ....{}; auto shape = obj_shape {}; // add shape shape . name = \"shape\" ; // set shape name add_fvquads ( shape , quadspos , // set shape geometry quadsnorm , quadstexcoord , 0 ); add_positions ( shape , positions ); add_normals ( shape , normals ); add_texcoords ( shape , texcoords ); auto error = string {}; // error buffer save_obj ( filename , obj , error ); // save obj Pbrt models The Pbrt file format is a scene representation suitable for realistic rendering and implemented by the Pbrt renderer. To use this library is helpful to understand the basic of the Pbrt file format for example from the Pbrt format documentatioon . The Pbrt file format is an extensible file format for a plugin-based system. Representing the format directly allows for best fidelity but pushed the burden of interpreting standard plugins to the use. Yocto/ModelIO takes a different approach and translates camera, shapes, materials, textures and lights from Pbrt plugins to a common representation that presents users a simpler and more uniform scene representation. Yocto/ModelIO represents Pbrt data with the pbrt_scene struct. Pbrt models are defined as collections of cameras, instanced shapes, materials, texture and environments. Pbrt cameras are translate into a thin-len approximations. Pbrt materials are translated to a material representation similar to the Disney BSDF. Pbrt textures are either interpreted ion the fly or defined by a image file. Pbrt area lights are translated to either emissive materials and environments. The Pbrt model is defined as an array of objects of the types defined above. Pbrt objects are pointers owned by the main pbrt_scene . Objects properties can be read and written directly from the model data, and are documented in the header file for now. Yocto/ModelIO does not currently provide functions to read and write Pbrt shapes with a simpler interface than accessing data directly. In general, Pbrt support is still experimental even if the library can parse most Pbrt files. The objects properties documentations are for now stored in the header file. auto pbrt = new pbrt_scene {...}; // obj model buffer for ( auto shape : pbrt . shapes ) // access shapes print_info ( shape . name ); // access shape properties for ( auto material : pbrt . material ) // access materials print_info ( material . diffuse ); // access material properties for ( auto material : pbrt . material ) // access materials print_info ( material . color_tex ); // access material textures for ( auto camera : pbrt . cameras ) // access cameras [extension] print_info ( camera . frame ); // access camera properties for ( auto environment : pbrt . environments ) // access environments [extension] print_info ( environment . emission ); // access environment properties Use load_pbrt(filename, pbrt, error) to load Pbrt files and save_pbrt(filename, pbrt, error) to save them. Both loading and saving take a filename, a pointer to a Pbrt model, and returns whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto pbrt = new pbrt_scene {}; // obj model buffer auto error = string {}; // error buffer if ( ! load_pbrt ( filename , pbrt , error )) // load obj print_error ( error ); // check and print error if ( ! save_pbrt ( filename , pbrt , error )) // save obj print_error ( error ); // check and print error","title":"Model serialization"},{"location":"yocto/yocto_modelio/#yoctomodelio-serialization-for-obj-ply-and-pbrt-models","text":"Yocto/ModelIO is a collection of utilities for loading and saving scenes and meshes in Ply, Obj, Stl and Pbrt formats. Yocto/ModelIO is implemented in yocto_modelio.h and yocto_modelio.cpp .","title":"Yocto/ModelIO: Serialization for Obj, Ply and Pbrt models"},{"location":"yocto/yocto_modelio/#ply-models","text":"The Ply file format is a generic file format used to serialize meshes and point clouds. To use this library is helpful to understand the basic of the Ply file format for example from the Ply Wikipedia page . Yocto/ModelIO represents Ply data with the ply_model struct. The internal representation matches the structure of a Ply file and can be accessed directly if desired. The Ply model is defined as an array of Ply elements, which in turn are defined as arrays of Ply properties. Ply properties can contain most C data types. All elements and properties are owned by the main ply_model . Yocto/ModelIO provides several functions to read and write Ply data whose use is preferred over direct data access. Use load_ply(filename, ply, error) to load Ply files and save_ply(filename, ply, error) to save them. Both loading and saving take a filename, a reference to a Ply model, and returns whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto ply = ply_model {}; // ply model buffer auto error = string {}; // error buffer if ( ! load_ply ( filename , ply , error )) // load ply print_error ( error ); // check and print error if ( ! save_ply ( filename , ply , error )) // save ply print_error ( error ); // check and print error","title":"Ply models"},{"location":"yocto/yocto_modelio/#ply-reading","text":"Yocto/ModelIO defines several functions to make it easy to extract data from Ply files. Since Ply properties cane be stored with many different C types, the convenience functions convert the various underlying representations to the requested one. Use has_property(ply,element,property) to check whether the model has a property named property in an element named element . Use get_property(ply,element,property) to get that property. Use get_value(ply, element, property, values) to get the property values and stored them in the array values . The function returns whether or not the property was present. Since Ply properties are often stored together, e.g. xyz coordinates, Yocto/ModelIO supports queries that take arrays of properties and returns values packed in vecXf . Use get_values(ply, element, properties, values) to read arrays of properties. For list properties, Yocto/ModelIO supports reading properties as arrays of arrays of dynamic size with get_lists(ply,element,property,lists) . A faster, but harder to use, method is to get lists sizes and values as separate arrays, where list values are packed together to avoid small memory allocations. Use get_list_sizes(ply, element, property, sizes) for sizes and get_list_values(ply, element, property, values) for values. auto ply = ply_model {}; // ply model buffer auto error = string {}; // error buffer load_ply ( filename , ply , error ); // load ply auto radius = vector < float > {}; // property buffer if ( ! get_value ( ply , \"vertex\" , \"radius\" , radius )) // read property print_error ( \"missing radius\" ); // error if missing auto positions = vector < vec3f > {}; // properties buffer if ( ! get_values ( ply , \"vertex\" , { \"x\" , \"y\" , \"z\" }, positions )) // read properties print_error ( \"missing positions\" ); // error if missing auto faces = vector < vector < int >> {}; // list property buffer if ( ! get_lists ( ply , \"face\" , \"indices\" , faces )) // read lists print_error ( \"missing faces\" ); // error if missing auto faces_sizes = vector < int > {}; // list property sizes auto faces_values = vector < int > {}; // list property values if ( ! get_list_sizes ( ply , \"face\" , \"indices\" , faces_sizes )) // read lists sizes print_error ( \"missing faces\" ); // error if missing if ( ! get_list_values ( ply , \"face\" , \"indices\" , faces_values )) // read lists values print_error ( \"missing faces\" ); // error if missing Yocto/Shape defines convenience functions to read the most used properties of meshes, using standard element and property names. For vertex properties, use get_positions(ply, positions) , get_normals(ply, normals) , get_texcoords(ply, texcoords, flipv) , get_colors(ply, colors) , and get_radius(ply, radius) to read positions, normals, texcoords, colors and radius if present. Texture coordinates can be optionally flipped vertically. For shape elements, use get_points(ply, points) , get_lines(ply, lines) , get_triangles(ply, triangles) , and get_quads(ply, quads) , to read points, lines, triangles and quads. Note that since Ply support arbitrary polygons and polylines, these functions tesselate the Ply polygons into the desired element type, for now using a simple fan-like algorithm that works only for convex elements. Use has_quads(ply) to check whether the Ply data has quads, or use get_faces(ply, triangles, quads) to triangles or quads. auto ply = ply_model {}; // ply model buffer auto error = string {}; // error buffer load_ply ( filename , ply , error ); // load ply auto positions = vector < vec3f > {}; // vertex properties buffers auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto colors = vector < vec3f > {}; auto radius = vector < float > {}; get_positions ( ply , positions ); // read vertex props. get_normals ( ply , normals ); get_texcoords ( ply , texcoords , false ); // last params, flips y is desired get_colors ( ply , colors ); get_radius ( ply , radius ); auto points = vector < vec4i > {}; // shape elements buffers auto lines = vector < vec4i > {}; auto triangles = vector < vec4i > {}; auto quads = vector < vec4i > {}; get_points ( ply , points ); get_lines ( ply , lines ); if ( has_quads ( ply )) get_quads ( ply , quads ); else get_triangles ( ply , triangles );","title":"Ply reading"},{"location":"yocto/yocto_modelio/#ply-writing","text":"Yocto/ModelIO defines several functions to make it easy to fill Ply data to save to file. Since Ply properties cane be stored with many different C types, the convenience functions maintain the same data type of the data passed in without performing any conversion. Use add_value(ply, element, property, values) to add the property values stored them in the array values . The function returns whether or not the property was successfully added. Since Ply properties are often stored together, e.g. xyz coordinates, Yocto/ModelIO supports adding arrays of properties whose values are packed in vecXf . Use add_values(ply, element, properties, values) to add arrays of properties. For list properties, Yocto/ModelIO supports adding list properties as arrays of arrays of dynamic size with add_lists(ply,element,property,lists) . A faster, but harder to use, method is to add lists sizes and values as separate arrays, where list values are packed together to avoid small memory allocations. Use add_lists(ply, element, property, sizes, values) . Finally, Yocto/ModelIO supports adding lists of fixed lengths, where the parameters are packed into vecXi , with add_lists(ply,element,property,values) . auto ply = ply_model {}; // ply model buffer auto radius = vector < float > {...}; // property buffer if ( ! add_value ( ply , \"vertex\" , \"radius\" , radius )) // add property print_error ( \"error in radius\" ); // error if missing auto positions = vector < vec3f > {...}; // properties buffer if ( ! add_values ( ply , \"vertex\" , { \"x\" , \"y\" , \"z\" }, positions )) // add properties print_error ( \"missing positions\" ); // error if missing auto faces = vector < vector < int >> {...}; // list property buffer if ( ! add_lists ( ply , \"face\" , \"indices\" , faces )) // add lists print_error ( \"missing faces\" ); // error if missing auto faces_sizes = vector < int > {...}; // list property sizes auto faces_values = vector < int > {...}; // list property values if ( ! add_lists ( ply , \"face\" , \"indices\" , faces_sizes , face_values )) // add lists print_error ( \"missing faces\" ); // error if missing auto triangles = vector < vec3i > {...}; // fixed length list property if ( ! add_lists ( ply , \"face\" , \"indices\" , triangles )) // add lists print_error ( \"missing faces\" ); // error if missing auto error = string {}; // error buffer save_ply ( filename , ply , error ); // save ply Yocto/ModelIO defines convenience functions to add the most used properties of meshes, using standard element and property names. For vertex properties, use add_positions(ply, positions) , add_normals(ply, normals) , add_texcoords(ply, texcoords, flipv) , add_colors(ply, colors) , and add_radius(ply, radius) to read positions, normals, texcoords, colors and radius if present. Texture coordinates can be optionally flipped vertically. For shape elements, use add_points(ply, points) , add_lines(ply, lines) , add_triangles(ply, triangles) , and add_quads(ply, quads) , to add points, lines, triangles and quads. Use add_faces(ply, faces) to add arbitrary polygonal faces. auto ply = ply_model {}; // ply model buffer auto positions = vector < vec3f > {...}; // vertex properties buffers auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto colors = vector < vec3f > {...}; auto radius = vector < float > {...}; add_positions ( ply , positions ); // add vertex props. add_normals ( ply , normals ); add_texcoords ( ply , texcoords , false ); // last params, flips y is desired add_colors ( ply , colors ); add_radius ( ply , radius ); auto points = vector < vec4i > {...}; // shape elements buffers auto lines = vector < vec4i > {...}; auto triangles = vector < vec4i > {...}; auto quads = vector < vec4i > {...}; add_points ( ply , points ); // add shape elements add_lines ( ply , lines ); add_triangles ( ply , triangles ); add_quads ( ply , quads ); auto error = string {}; // error buffer save_ply ( filename , ply , error ); // save ply","title":"Ply writing"},{"location":"yocto/yocto_modelio/#obj-models","text":"The Obj file format is a file format used to serialize meshes and materials. To use this library is helpful to understand the basic of the Obj file format for example from the Obj Wikipedia page . Obj files come in pairs, .obj for shapes and .mtl for materials. Yocto/ModelIO represents Obj data with the obj_model struct. Obj models are defined as collections of shapes and materials. Obj shapes use a face-varying representation that has vertex positions, normals and texture coordinates, with their their own topology. In a shape, each face is tagged with a material used for that face. Yocto/ModelIO provides direct access to these tagged shapes by inspecting the obj_shape properties. In Yocto/Obj, materials are represented by the obj_material struct. Each material is a collection of values and textures that specify the material lobes, like emission, diffuse, specular, reflection, etc. Each value has a corresponding texture stored as an index to the texture array. Yocto/ModelIO defines two extensions to the Obj file format. Yocto/ModelIO adds another file, namely .obx , that stores cameras and environment maps, respectively as obj_camera and obj_environment . T his addition makes the extended Obj format capable of storing full scenes. The Obj model is defined as an array of objects of the types defined above. Obj objects are pointers owned by the main obj_model . Objects properties can be read and written directly from the model data, and are documented in the header file for now. For shapes, Yocto/ModelIO provides several functions to read and write Obj shapes, with a simpler interface than accessing data directly. auto obj = obj_model {...}; // obj model buffer for ( auto shape : obj . shapes ) // access shapes print_info ( shape . name ); // access shape properties for ( auto material : obj . material ) // access materials print_info ( material . diffuse ); // access material properties for ( auto material : obj . material ) // access materials print_info ( material . diffuse_tex ); // access material textures for ( auto camera : obj . cameras ) // access cameras [extension] print_info ( camera . frame ); // access camera properties for ( auto environment : obj . environments ) // access environments [extension] print_info ( environment . emission ); // access environment properties Use load_obj(filename, obj, error) to load Obj files and save_obj(filename, obj, error) to save them. Both loading and saving take a filename, a reference to an Obj model, and return whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Obj is a face-varying file format, while most applications handle only indexed meshes. The loading function takes an optional that specify whether to load as face-varying or convert to indexed meshes, which is the default. auto obj = obj_model {}; // obj model auto error = string {}; // error if ( ! load_obj ( filename , obj , error )) // load obj as indexed meshes print_error ( error ); // check and print error if ( ! load_obj ( filename , obj , error , true )) // load obj as face-varying print_error ( error ); // check and print error if ( ! save_obj ( filename , obj , error )) // save obj print_error ( error ); // check and print error It is common in graphics to use Obj file to store single meshes. Yocto/Obj supports this modality by providing specialized loading and saving functions that take references to shapes as parameters. Use load_obj(filename, shape, error) to load Obj shapes and save_obj(filename, shape, error) to save them. The loading function takes an optional that specify whether to load as face-varying or convert to indexed meshes, which is the default. auto shape = obj_shape {}; // obj shape auto error = string {}; // error if ( ! load_obj ( filename , shape , error )) // load obj as indexed meshes print_error ( error ); // check and print error if ( ! load_obj ( filename , shape , error , true )) // load obj as face-varying print_error ( error ); // check and print error if ( ! save_obj ( filename , shape , error )) // save obj print_error ( error ); // check and print error","title":"Obj models"},{"location":"yocto/yocto_modelio/#obj-reading","text":"Obj is a face-varying format and that geometry representation is maintained in obj_shape . Yocto/ModelIO provides easier accessed to Obj shape data, both as indexed meshes and as face-varying meshes. Use get_positions(shape, positions) , get_normals(shape, normals) , get_texcoords(shape, texcoords, flipv) , to read positions, normals, texcoords, if present. Texture coordinates can be optionally flipped vertically. For shape elements, use get_points(shape, points, materials) , get_lines(shape, lines, materials) , get_triangles(shape, triangles, materials) , and get_quads(shape, quads, materials) , to read points, lines, triangles and quads. Note that since Obj support arbitrary polygons and polylines, these functions tesselate the Obj polygons into the desired element type, for now using a simple fan-like algorithm that works only for convex elements. Use has_quads(shape) to check whether the Obj data has quads, or use get_faces(shape, triangles, quads, materials) to triangles or quads. In some cases, it may be desireable to extract the shape elements corresponding to a single material, for example for use in renderers that support a single shader per shape. To filtering elements by material index use get_points(shape, material, points) , get_lines(shape, material, lines) , get_triangles(shape, material, triangles) , and get_quads(shape, material, quads) . that are overrides of the previous get_<element>(...) functions, but differ in that they take a material is as input, instead of returning materials tags. auto obj = obj_model {}; // obj model buffer auto error = string {}; // error buffer load_obj ( filename , obj , error ); // load obj auto & shape = obj . shapes . front (); // get shape auto positions = vector < vec3f > {}; // vertex properties get_positions ( shape , positions ); auto normals = vector < vec3f > {}; get_normals ( shape , normals ); auto texcoords = vector < vec2f > {}; get_texcoords ( shape , texcoords ); auto triangles = vector < vec3i > {}; // element data auto quads = vector < vec4i > {}; auto materials = vector < int > {}; // per-face material ids if ( has_quads ( shape )) { get_triangles ( shape , triangles , materials ); // read as triangles } else { get_quads ( shape , quads , materials ); // read as quads } auto material_id = 0 ; // material id to extract to if ( has_quads ( shape )) { get_triangles ( shape , material_id , triangles ); // read as triangles } else { get_quads ( shape , material_id , quads ); // read as quads } Yocto/ModelIO supports also reading Obj shapes as face-varying quads with get_fvquads(...) . In this case, the model should be loaded as face-varying. auto obj = new obj_model {}; // obj model buffer auto error = string {}; // error buffer load_obj ( filename , obj , error , true ); // load obj as face-varying auto & shape = obj . shapes . front (); // get shape auto positions = vector < vec3f > {}; // vertex properties get_positions ( shape , positions ); auto normals = vector < vec3f > {}; get_normals ( shape , normals ); auto texcoords = vector < vec2f > {}; get_texcoords ( shape , texcoords ); auto quadspos = vector < vec4i > {}; // face-varying element data auto quadsnorm = vector < vec4i > {}; auto quadsuv = vector < vec4i > {}; auto materials = vector < int > {}; // per-face material ids get_fvquads ( shape , // read as face-varying quads quadspos , quadsnorm , quadsuv , materias );","title":"Obj reading"},{"location":"yocto/yocto_modelio/#obj-writing","text":"To save an Obj, create a scene and add objects to it by manipulating the objects' arrays directly. For all objects, set the objects' properties directly. For shapes, Yocto/ModelIO defines convenience functions that take either indexed mesh or face-varying meshes as input and create the appropriate Obj shape elements. Use add_positions(shape, positions) , add_normals(shape, normals) and add_texcoords(shape, texcoords, flipv) to add vertex properties to a shape. Use add_triangles(shape, triangles, material, has_normals, has_texcoords) , add_quads(shape, quads, material, has_normals, has_texcoords) , add_lines(shape, lines, material, has_normals, has_texcoords) , add_points(shape, points, material, has_normals, has_texcoords) to add triangles, quads, lines or points to shapes respectively. Material data is only represented as tags and can be left empty if only one material is used. To set material names use set_materials(shape, materials) . To add face-varying shapes, use add_fvquads(...) . auto obj = obj_model {}; // obj model auto camera = obj_camera {}; // init camera camera . name = \"camera\" ; // set camera name camera . frame = identity3x4f ; // set camera properties obj . cameras . push_back ( camera ); // add camera auto environment = add_environment ( obj ); // init environment environment . name = \"environment\" ; // set environment name environment . emission = { 1 , 1 , 1 }; // set environment properties obj . environments . push_back ( environment ); // add environment auto material = add_material ( obj ); // init material material . name = \"material\" ; // set material name material . diffuse = { 1 , 0 , 0 }; // set material properties obj . materials . push_back ( material ); // add material auto triangles = vector < vec3i > {...}; // element data auto positions = vector < vec3f > {...}; // vertex properties auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto shape = obj_shape {}; // init shape shape . name = \"shape\" ; // set shape name add_triangles ( shape , triangles , 0 ); // set shape geometry add_positions ( shape , positions ); add_normals ( shape , normals ); add_texcoords ( shape , texcoords ); auto error = string {}; // error buffer save_obj ( filename , obj , error ); // save obj And similarly for face-varying shapes. auto obj = obj_model {}; // obj model buffer auto quadspos = vector < vec4i > {...}; // face-varying element data auto quadsnorm = vector < vec4i > {...}; auto quadsuv = vector < vec4i > {...}; auto positions = vector < vec3f > {...}; // vertex properties auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > ....{}; auto shape = obj_shape {}; // add shape shape . name = \"shape\" ; // set shape name add_fvquads ( shape , quadspos , // set shape geometry quadsnorm , quadstexcoord , 0 ); add_positions ( shape , positions ); add_normals ( shape , normals ); add_texcoords ( shape , texcoords ); auto error = string {}; // error buffer save_obj ( filename , obj , error ); // save obj","title":"Obj writing"},{"location":"yocto/yocto_modelio/#pbrt-models","text":"The Pbrt file format is a scene representation suitable for realistic rendering and implemented by the Pbrt renderer. To use this library is helpful to understand the basic of the Pbrt file format for example from the Pbrt format documentatioon . The Pbrt file format is an extensible file format for a plugin-based system. Representing the format directly allows for best fidelity but pushed the burden of interpreting standard plugins to the use. Yocto/ModelIO takes a different approach and translates camera, shapes, materials, textures and lights from Pbrt plugins to a common representation that presents users a simpler and more uniform scene representation. Yocto/ModelIO represents Pbrt data with the pbrt_scene struct. Pbrt models are defined as collections of cameras, instanced shapes, materials, texture and environments. Pbrt cameras are translate into a thin-len approximations. Pbrt materials are translated to a material representation similar to the Disney BSDF. Pbrt textures are either interpreted ion the fly or defined by a image file. Pbrt area lights are translated to either emissive materials and environments. The Pbrt model is defined as an array of objects of the types defined above. Pbrt objects are pointers owned by the main pbrt_scene . Objects properties can be read and written directly from the model data, and are documented in the header file for now. Yocto/ModelIO does not currently provide functions to read and write Pbrt shapes with a simpler interface than accessing data directly. In general, Pbrt support is still experimental even if the library can parse most Pbrt files. The objects properties documentations are for now stored in the header file. auto pbrt = new pbrt_scene {...}; // obj model buffer for ( auto shape : pbrt . shapes ) // access shapes print_info ( shape . name ); // access shape properties for ( auto material : pbrt . material ) // access materials print_info ( material . diffuse ); // access material properties for ( auto material : pbrt . material ) // access materials print_info ( material . color_tex ); // access material textures for ( auto camera : pbrt . cameras ) // access cameras [extension] print_info ( camera . frame ); // access camera properties for ( auto environment : pbrt . environments ) // access environments [extension] print_info ( environment . emission ); // access environment properties Use load_pbrt(filename, pbrt, error) to load Pbrt files and save_pbrt(filename, pbrt, error) to save them. Both loading and saving take a filename, a pointer to a Pbrt model, and returns whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto pbrt = new pbrt_scene {}; // obj model buffer auto error = string {}; // error buffer if ( ! load_pbrt ( filename , pbrt , error )) // load obj print_error ( error ); // check and print error if ( ! save_pbrt ( filename , pbrt , error )) // save obj print_error ( error ); // check and print error","title":"Pbrt models"},{"location":"yocto/yocto_noise/","text":"Yocto/Noise: Noise functions Yocto/Noise provides a Perlin noise implementation. Yocto/Noise is implemented in yocto_noise.h . Noise functions Use perlin_noise(p, w) to generate Perlin noise with optional wrapping. Returned values are in the range [0, 1] following the Renderman convention and to ensure that all noise functions return values in the same range. For fractal variations, use perlin_ridge(p, l, g, o, f, w) , perlin_fbm(p, l, g, o, w) and perlin_turbulence(p, l, g, o, w) . Each fractal version is defined by its lacunarity l , its gain g , the number of octaves o and possibly an offet. auto p = vec3f { 0 , 0 , 0 }; auto n = perlin_noise ( p ); auto lacunarity = 2.0f , gain = 0.5.0f , , offset = 1.0f ; auto octaves = 6 ; auto n = perlin_ridge ( p , lacunarity , gain , octaves , offset ); auto n = perlin_fbm ( p , lacunarity , gain , octaves ); auto n = perlin_turbulence ( p , lacunarity , gain , octaves );","title":"Noise functions"},{"location":"yocto/yocto_noise/#yoctonoise-noise-functions","text":"Yocto/Noise provides a Perlin noise implementation. Yocto/Noise is implemented in yocto_noise.h .","title":"Yocto/Noise: Noise functions"},{"location":"yocto/yocto_noise/#noise-functions","text":"Use perlin_noise(p, w) to generate Perlin noise with optional wrapping. Returned values are in the range [0, 1] following the Renderman convention and to ensure that all noise functions return values in the same range. For fractal variations, use perlin_ridge(p, l, g, o, f, w) , perlin_fbm(p, l, g, o, w) and perlin_turbulence(p, l, g, o, w) . Each fractal version is defined by its lacunarity l , its gain g , the number of octaves o and possibly an offet. auto p = vec3f { 0 , 0 , 0 }; auto n = perlin_noise ( p ); auto lacunarity = 2.0f , gain = 0.5.0f , , offset = 1.0f ; auto octaves = 6 ; auto n = perlin_ridge ( p , lacunarity , gain , octaves , offset ); auto n = perlin_fbm ( p , lacunarity , gain , octaves ); auto n = perlin_turbulence ( p , lacunarity , gain , octaves );","title":"Noise functions"},{"location":"yocto/yocto_parallel/","text":"Yocto/Parallel: Concurrency utilities Yocto/Parallel is a collection of concurrency utilities helpful in implementing other Yocto/GL libraries. Yocto/Parallel is implemented in yocto_parallel.h . This library is experimental and will be documented appropriately when the code reaches stability.","title":"Concurrency utilities"},{"location":"yocto/yocto_parallel/#yoctoparallel-concurrency-utilities","text":"Yocto/Parallel is a collection of concurrency utilities helpful in implementing other Yocto/GL libraries. Yocto/Parallel is implemented in yocto_parallel.h . This library is experimental and will be documented appropriately when the code reaches stability.","title":"Yocto/Parallel: Concurrency utilities"},{"location":"yocto/yocto_sampling/","text":"Yocto/Sampling: Sampling routines Yocto/Sampling provides many functions to generate points and directions useful in path tracing and procedural generation. We also include a random number generator suitable for ray tracing. Random number generation Yocto/Sampling includes an implementation of the PCG32 random number generator, that is a portable generator well suited for graphics applications. The state of the generator is stored in rng_state and uses only 16 bytes. The generator is default-initialized to be able to provide random numbers as is. You can use make_rng(seed,seq) to initialize a generator with a given seed and byt selecting a specific random sequence. See PCG32 for a discussion. If you do not need to select a sequence, just use the default value. Use rand1f(rng) , rand2f(rng) , rand3f(rng) and rand4f(rng) to generate random 1-4 dimensional float vectors with coordinates in [0,1). Use rand1i(rng,n) to generate a random integer in the [0,n) range. Use shuffle(sequence, rng) to randomly shuffle a sequence. auto rng = make_rng ( 172784 ); // seed the generator auto r1 = rand1f ( rng ); auto r2 = rand2f ( rng ); // 1-2 dim. random numbers auto r3 = rand3f ( rng ); auto r4 = rand4f ( rng ); // 3-4 dim. random numbers auto ri = rand1i ( rng , 10 ); // random int in [0,10) auto vec = std :: vector < float > {...}; shuffle ( vec , rng ); // random shuffle of a vector Generating points and directions Yocto/Sampling defines several functions to generate random points and directions. Each of these functions is a warp that takes random numbers in the [0,1) domain and warps them to the desired distributions. The functions are particularly useful in procedural modeling and path tracing. For each function, Yocto/Sampling provides both the warp as well as its pdf, that can be used in Monte Carlo integration. Yocto/Sampling supports generating directions uniformly over the unit hemisphere and sphere, or cosine distributed over the hemisphere, using respectively sample_hemisphere(ruv) , sample_sphere(ruv) , sample_hemisphere_cos(ruv) sample_hemisphere_cos(ruv) and sample_hemisphere_cos(ruv) . For each of these functions, the corresponding sample_<distribution>_pdf(dir) computes the pdf that the given direction was chosen. auto rng = make_rng ( 172784 ); // seed the generator auto rhu = sample_hemisphere ( rand2f ( rng )); // random hemispherical direction auto phu = sample_hemisphere_pdf ( rand2f ( rng )); // direction pdf auto rhc = sample_hemisphere_cos ( rand2f ( rng )); // cos-distributed direction auto rsu = sample_sphere ( rand2f ( rng )); // random spherical direction auto rhu2 = sample_hemisphere ( normal , rand2f ( rng )); // oriented hemisphere auto rhc2 = sample_hemisphere_cos ( normal , rand2f ( rng )); // oriented hemisphere Yocto/Sampling supports generating points uniformly on geometric primitives. Use sample_disk(uv) to uniformly sample a disk and sample_triangle(uv) to uniformly sample a triangle. For triangles we also support direct sampling of triangle points with sample_triangle(p0,p1,p2,ruv) . by warping random numbers from the unit square to uniformly over the unit hemisphere and sphere, or cosine distributed over the hemisphere, using respectively sample_hemisphere(ruv) , sample_sphere(ruv) , sample_hemisphere_cos(ruv) sample_hemisphere_cos(ruv) and sample_hemisphere_cos(ruv) . For each of these functions, the corresponding sample_<distribution>_pdf(dir) computes the pdf that the given direction was chosen. auto rng = make_rng ( 172784 ); // seed the generator auto sdu = sample_disk ( rand2f ( rng )); // uniform uv on disk auto stu = sample_triangle ( rand2f ( rng )); // uniform uv on triangle auto stp = sample_triangle ( p0 , p1 , p2 , rand2f ( rng )); // uniform triangle point Sampling distributions Yocto/Sampling defines several functions to sample distributions. Each of these functions is a warp that takes a random number in the [0,1) domain and warps it to the desired distribution. For each function, Yocto/Sampling provides both the warp as well as its pdf, that can be used in Monte Carlo integration. Use sample_uniform(n,r) to randomly pick an index in the [0,n) range, sample_uniform(elems,r) to randomly pick an element from a sequence, sample_discrete_cdf(cdf,r) to pick an index from a discrete distribution that has CDF cdf and sample_discrete_weights(w,r) to pick an index from a discrete distribution with probability equal to the weights array. For discrete distribution, sample_discrete_cdf() is significantly faster when computing many samples. auto rng = make_rng ( 172784 ); // seed the generator auto idx = sample_uniform ( num , rand1f ( rng )); // uniform index auto & elem = sample_uniform ( elems , rand1f ( rng )); // uniform element auto prob = std :: vector < float > { 0.3 , 0.3 , 0.4 }; // probability distribution auto pidx = sample_discrete_weights ( prob , rand1f ( rng )); // index with prob auto ppidx = sample_discrete_weights_pdf ( prob , pidx ); // index pdf auto cdf = std :: vector < float > { prob . size ()}; for ( auto i : range ( prob . size ()) // compute cdf cdf [ i ] = prob [ i ] + ( i ? cdf [ i -1 ] : 0 ); auto cidx = sample_discrete_cdf ( cdf , rand1f ( rng )); // index with cdf auto pcidx = sample_discrete_cdf_pdf ( cdf , cidx ); // index pdf","title":"Sampling routines"},{"location":"yocto/yocto_sampling/#yoctosampling-sampling-routines","text":"Yocto/Sampling provides many functions to generate points and directions useful in path tracing and procedural generation. We also include a random number generator suitable for ray tracing.","title":"Yocto/Sampling: Sampling routines"},{"location":"yocto/yocto_sampling/#random-number-generation","text":"Yocto/Sampling includes an implementation of the PCG32 random number generator, that is a portable generator well suited for graphics applications. The state of the generator is stored in rng_state and uses only 16 bytes. The generator is default-initialized to be able to provide random numbers as is. You can use make_rng(seed,seq) to initialize a generator with a given seed and byt selecting a specific random sequence. See PCG32 for a discussion. If you do not need to select a sequence, just use the default value. Use rand1f(rng) , rand2f(rng) , rand3f(rng) and rand4f(rng) to generate random 1-4 dimensional float vectors with coordinates in [0,1). Use rand1i(rng,n) to generate a random integer in the [0,n) range. Use shuffle(sequence, rng) to randomly shuffle a sequence. auto rng = make_rng ( 172784 ); // seed the generator auto r1 = rand1f ( rng ); auto r2 = rand2f ( rng ); // 1-2 dim. random numbers auto r3 = rand3f ( rng ); auto r4 = rand4f ( rng ); // 3-4 dim. random numbers auto ri = rand1i ( rng , 10 ); // random int in [0,10) auto vec = std :: vector < float > {...}; shuffle ( vec , rng ); // random shuffle of a vector","title":"Random number generation"},{"location":"yocto/yocto_sampling/#generating-points-and-directions","text":"Yocto/Sampling defines several functions to generate random points and directions. Each of these functions is a warp that takes random numbers in the [0,1) domain and warps them to the desired distributions. The functions are particularly useful in procedural modeling and path tracing. For each function, Yocto/Sampling provides both the warp as well as its pdf, that can be used in Monte Carlo integration. Yocto/Sampling supports generating directions uniformly over the unit hemisphere and sphere, or cosine distributed over the hemisphere, using respectively sample_hemisphere(ruv) , sample_sphere(ruv) , sample_hemisphere_cos(ruv) sample_hemisphere_cos(ruv) and sample_hemisphere_cos(ruv) . For each of these functions, the corresponding sample_<distribution>_pdf(dir) computes the pdf that the given direction was chosen. auto rng = make_rng ( 172784 ); // seed the generator auto rhu = sample_hemisphere ( rand2f ( rng )); // random hemispherical direction auto phu = sample_hemisphere_pdf ( rand2f ( rng )); // direction pdf auto rhc = sample_hemisphere_cos ( rand2f ( rng )); // cos-distributed direction auto rsu = sample_sphere ( rand2f ( rng )); // random spherical direction auto rhu2 = sample_hemisphere ( normal , rand2f ( rng )); // oriented hemisphere auto rhc2 = sample_hemisphere_cos ( normal , rand2f ( rng )); // oriented hemisphere Yocto/Sampling supports generating points uniformly on geometric primitives. Use sample_disk(uv) to uniformly sample a disk and sample_triangle(uv) to uniformly sample a triangle. For triangles we also support direct sampling of triangle points with sample_triangle(p0,p1,p2,ruv) . by warping random numbers from the unit square to uniformly over the unit hemisphere and sphere, or cosine distributed over the hemisphere, using respectively sample_hemisphere(ruv) , sample_sphere(ruv) , sample_hemisphere_cos(ruv) sample_hemisphere_cos(ruv) and sample_hemisphere_cos(ruv) . For each of these functions, the corresponding sample_<distribution>_pdf(dir) computes the pdf that the given direction was chosen. auto rng = make_rng ( 172784 ); // seed the generator auto sdu = sample_disk ( rand2f ( rng )); // uniform uv on disk auto stu = sample_triangle ( rand2f ( rng )); // uniform uv on triangle auto stp = sample_triangle ( p0 , p1 , p2 , rand2f ( rng )); // uniform triangle point","title":"Generating points and directions"},{"location":"yocto/yocto_sampling/#sampling-distributions","text":"Yocto/Sampling defines several functions to sample distributions. Each of these functions is a warp that takes a random number in the [0,1) domain and warps it to the desired distribution. For each function, Yocto/Sampling provides both the warp as well as its pdf, that can be used in Monte Carlo integration. Use sample_uniform(n,r) to randomly pick an index in the [0,n) range, sample_uniform(elems,r) to randomly pick an element from a sequence, sample_discrete_cdf(cdf,r) to pick an index from a discrete distribution that has CDF cdf and sample_discrete_weights(w,r) to pick an index from a discrete distribution with probability equal to the weights array. For discrete distribution, sample_discrete_cdf() is significantly faster when computing many samples. auto rng = make_rng ( 172784 ); // seed the generator auto idx = sample_uniform ( num , rand1f ( rng )); // uniform index auto & elem = sample_uniform ( elems , rand1f ( rng )); // uniform element auto prob = std :: vector < float > { 0.3 , 0.3 , 0.4 }; // probability distribution auto pidx = sample_discrete_weights ( prob , rand1f ( rng )); // index with prob auto ppidx = sample_discrete_weights_pdf ( prob , pidx ); // index pdf auto cdf = std :: vector < float > { prob . size ()}; for ( auto i : range ( prob . size ()) // compute cdf cdf [ i ] = prob [ i ] + ( i ? cdf [ i -1 ] : 0 ); auto cidx = sample_discrete_cdf ( cdf , rand1f ( rng )); // index with cdf auto pcidx = sample_discrete_cdf_pdf ( cdf , cidx ); // index pdf","title":"Sampling distributions"},{"location":"yocto/yocto_scene/","text":"Yocto/Scene: Scene representation Yocto/Scene define a simple scene representation, and related utilities, used in the Yocto/GL path tracer and for scene IO. Yocto/Scene is implemented in yocto_scene.h and yocto_scene.cpp . Scene representation Scenes are stored in scene_model structs and are comprised of arrays of cameras, instances, shapes, materials, textures and environments. The various objects are stored as values in arrays named like the object type. Animation is not currently supported. The scene representation is geared toward modeling physically-based environments. In Yocto/Scene, lights are not explicitly defined, but implicitly comprised of instances with emissive materials and environment maps. All scenes and objects properties are accessible directly. All scenes objects may have names that are used in IO. If names are defined, that have to be unique. If not, names are automatically generated. Names are stored separately from objects, for performance reasons. So for each object array, Yocto/Scene stores a corresponding names array. For examples, cameras as stored as cameras and their names are stored as camera_names . Cameras, instances and environments have coordinate frames to define the local to world transformation. Frames are presented as affine 3x4 matrices and are intended to be rigid transforms, although most scene processing support frames with scaling. Objects are added to the scene by directly adding elements to the corresponding arrays. References to elements are expressed as indices to the corresponding arrays. For each element type, properties can be set directly. Also, all scene objects are values, so you can work freely with them without concerning yourself with memory management. The mantra we followed here is that \"if you know how to use std::vector , you know how to use scenes\". Here is an sketch of how to create a shape instance in a scene. auto scene = scene_model {}; // create a scene auto shape = scene_shape {}; // create a shape and add it set_shape_properties ( shape , ...); scene . shapes . push_back ( shape ); scene . materials . push_back ({}); // create a black material directly auto instance = scene_instance {}; // create an instance of last added shape instance . shape = ( int ) scene . shapes . size () -1 ; instance . material = ( int ) scene . materials . size () -1 ; Yocto/Scene defines several function to evaluate scene properties. Use compute_bounds(scene) to compute the scene bounding boxes, scene_stats(scene) to get scene stats and scene_validation(scene) to validate scene objects. auto scene = scene_scene {...}; // create a complete scene auto bbox = compute_bounds ( scene ); // get bounds auto stats = scene_stats ( scene ); // get stats for ( auto stat : stats ) print_info ( stat ); // print stats auto errors = validate_stats ( scene ); // get validation errors for ( auto error : errors ) print_error ( error ); // print error Cameras Cameras, represented by scene_camera , are based on a simple lens model. Cameras coordinate systems are defined by their frame. Cameras projections are described in photographic terms. In particular, we specify film size (35mm by default), film aspect ration, the lens' focal length, the focus distance and the lens aperture. All values are in meters. We support both perspective and orthographic cameras, but prefer the former. Common aspect ratios used in video and still photography are 3:2 on 35 mm (0.036 x 0.024), 16:9 on 35 mm (0.036 x 0.02025 or 0.04267 x 0.024), 2.35:1 on 35 mm (0.036 x 0.01532 or 0.05640 x 0.024), 2.39:1 on 35 mm (0.036 x 0.01506 or 0.05736 x 0.024), 2.40:1 on 35 mm (0.036 x 0.015 or 0.05760 x 0.024). To compute good apertures, one can use the F-stop number from photography and set the aperture to focal length over f-stop. To create cameras, you should set the camera frame, the camera view, via lens, aspect and film, and optionally the camera aperture and focus. auto camera = scene_camera {}; // create a camera camera . frame = identity3x4f ; // set frame to identity camera . lens = 0.050 ; // set as 50mm lens camera . aspect = 1.5 ; // set 3:2 aspect ratio camera . film = 0.036 ; // set the film as 35mm camera . aperture = 0.01 ; // set 10mm aperture camera . focus = 10 ; // set the focus at 10m Use get_camera(scene, name) to get a camera by name or the default camera is the name is not given. Use eval_camera(camera, image_uv, lens_uv) to get a camera ray from the normalized image coordinates image_uv and lens coordinates lens_uv . auto scene = scene_model {...}; // create a complete scene auto & camera = get_camera ( scene ); // get default camera auto ray = eval_camera ( camera ,{ 0.5 , 0.5 },{ 0 , 0 }); // get ray though image center Instances Instances, represented as scene_instance , place shapes in the scene by defining their coordinate frame, a shape index and a material index. Through the use of instancing, Yocto/Scene scales well to large environments without introducing more complex mechanisms. For instances, you should set the instance frame, shape and material. auto instance = scene_instance {}; // create an instance instance . frame = identity3x4f ; // set frame to identity instance . shape = shape_index ; // set shape index instance . material = material_index ; // set material index Several functions are defined to evaluate the geometric and material properties of points on shapes and instances, indicated by the shape element id and, when needed, the shape element barycentric coordinates. The difference between the shape and instance methods is that the former returns quantities in object space, while the latter in world space. Use eval_position(...) to evaluate the point position, eval_normal(...) to evaluate the interpolate point normal, eval_texcoord(...) to evaluate the point texture coordinates, eval_element_normal(...) to evaluate the point geometric normal, and eval_color(...) to evaluate the interpolate point color. Use eval_material(...) as a convenience function to evaluate material properties of instance points. auto eid = 0 ; auto euv = vec3f { 0.5 , 0.5 }; // element id and uvs auto pos = eval_position ( instance , eid , euv ); // eval point position auto norm = eval_normal ( instance , eid , euv ); // eval point normal auto st = eval_texcoord ( instance , eid , euv ); // eval point texture coords auto col = eval_color ( instance , eid , euv ); // eval point color auto gn = eval_element_normal ( instance , eid , euv ); // eval geometric normal auto mat = eval_material ( instance , eid , euv ); // eval point material Environments Environments, represented as scene_environment , store the background illumination as a scene. Environments have a frame, to rotate illumination, an emission term and an optional emission texture. The emission texture is an HDR environment map stored in a LatLon parametrization. For environments, set the frame, emission and optionally the emission texture. auto & environment = scene_environment {}; // create an environment environment . frame = identity3x4f ; // set identity transform environment . emission = { 1 , 1 , 1 }; // set emission scale environment . emission_tex = texture_index ; // add emission texture Use eval_environment(environment, direction) to evaluate an environment map emission along a specific direction direction . Use eval_environment(scene, direction) to accumulate the lighting for all environment maps. auto scene = new trace_scene {...}; // create a complete scene auto enva = eval_environment ( scene , dir ); // eval all environments auto environment = scene . environments . front (); // get first environment auto envi = eval_environment ( environment , dir ); // eval environment Shapes Shapes, represented by scene_shape , are indexed meshes of elements. Shapes can contain only one type of element, either points, lines, triangles or quads. Shape elements are parametrized as in Yocto/Geometry . Vertex properties are defined as separate arrays and include positions, normals, texture coords, colors, radius and tangent spaces. Additionally, Yocto/Scene supports face-varying primitives, as scene_fvshape , where each vertex data has its own topology. Shapes also work as a standalone mesh representation throughout the library and can be used even without a scene. For shapes, you should set the shape elements, i.e. point, limes, triangles or quads, and the vertex properties, i.e. positions, normals, texture coordinates, colors and radia. Shapes support only one element type. auto shape = scene_shape {}; // create a shape shape . triangles = vector < vec3i > {...}; // set triangle indices shape . positions = vector < vec3f > {...}; // set positions shape . normals = vector < vec3f > {...}; // set normals shape . texcoords = vector < vec2f > {...}; // set texture coordinates Several functions are defined to evaluate the geometric properties of points of shapes, indicated by the shape element id and, when needed, the shape element barycentric coordinates. Use eval_position(...) to evaluate the point position, eval_normal(...) to evaluate the interpolate point normal, eval_texcoord(...) to evaluate the point texture coordinates, eval_element_normal(...) to evaluate the point geometric normal, and eval_color(...) to evaluate the interpolate point color. auto eid = 0 ; auto euv = vec3f { 0.5 , 0.5 }; // element id and uvs auto pos = eval_position ( shape , eid , euv ); // eval point position auto norm = eval_normal ( shape , eid , euv ); // eval point normal auto st = eval_texcoord ( shape , eid , euv ); // eval point texture coords auto col = eval_color ( shape , eid , euv ); // eval point color auto gn = eval_element_normal ( shape , eid , euv ); // eval geometric normal Shape support random sampling with a uniform distribution using sample_shape(...) and sample_shape_cdf(shape) . Sampling works for lines and triangles in all cases, while for quad it requires that the elements are rectangular. auto cdf = sample_shape_cdfd ( shape ); // compute the shape CDF auto points = sample_shape ( shape , cdf , num ); // sample many points auto point = sample_shape ( shape , cdf , // sample a single point rand1f ( rng ), rand2f ( rng )); For shapes, we also support the computation of smooth vertex normals with compute_normals(shape) and converting to and from face-varying representations with shape_to_fvshape(shape) and fvshape_to_shape(fvshape) . Materials Materials, represented as scene_material , are defined by a material type and a few parameters, common to all materials. In particular, we support the following materials: matte , for materials like concrete or stucco, implemented as a lambertian bsdf; glossy , for materials like plastic or painted wood, implemented as the sum of a lambertian and a microfacet dielectric lobe; metallic , for materials like metals, implemented as either a delta or microfacet brdf lobe; transparent , for materials for thin glass, implemented as a delta or microfacet transmission bsdf; refractive , for materials for glass or water, implemented as a delta or microfacet refraction bsdf; also support homogenous volume scattering; subsurface , for materials for skin, implemented as a microfacet refraction bsdf with homogenous volume scattering - for no this is like refractive ; volume , for materials like homogeneous smoke or fog, implemented as the lack of a surface interface but with volumetric scattering. gltfpbr , for materials that range from glossy to metallic, implemented as the sum of a lambertian and a microfacet dielectric lobe; this is a compatibility material for loading and saving Khronos glTF data. All materials can specify a diffuse surface emission emission with HDR values that represent emitted radiance. Surface scattering is controlled by specifying the main surface color color , that represent the surface albedo, the surface roughness roughness and the index of refraction ior . The physical meaning of each parameter depends on the material type. By default surfaces are fully opaque, but can defined a opacity parameter and texture to define the surface coverage. Materials like refractive , subsurface and volume may also specify volumetric properties. In these cases, the color parameter controls the volume density, while the scattering also define volumetric scattering properties by setting a transmission parameter controls the homogenous volume scattering. All parameters can modulated by a corresponding textures, if present. For materials, we need to specify the material type and color at the minimum. We can further control the appearance by changing surface roughness, index of refraction and volumetric properties, when appropriate. Here are some examples. auto matte = scene_material {}; // create a matte material matte . type = scene_material_type :: matte ; matte . color = { 1 , 0.5 , 0.5 }; // with base color and matte . color_tex = texture_id ; // textured albedo auto glossy = scene_material {}; // create a glossy material glossy . type = scene_material_type :: glossy ; glossy . color = { 0.5 , 1 , 0.5 }; // with constant color glossyv . roughness = 0.1 ; // base roughness and a glossy . roughness_tex = texture_id ; // roughness texture auto metallic = scene_material {}; // create a metallic material glossy . type = scene_material_type :: metallic metal . color = { 0.5 , 0.5 , 1 }; // constant color metal . roughness = 0.1 ; // constant roughness auto tglass = scene_material {}; // create a transparent material tglass . type = scene_material_type :: transparent ; tglass . color = { 1 , 1 , 1 }; // with constant color auto glass = scene_material {}; // create a refractive material glass . type = scene_material_type :: transparent ; glass . color = { 1 , 0.9 , 0.9 }; // constant color auto subsurf = scene_material {}; // create a refractive material subsurf . type = scene_material_type :: subsurface ; subsurf . color = { 1 , 1 , 1 }; // that transmits all light subsurf . scattering = { 0.5 , 1 , 0.5 }; // and has volumetric scattering Lights are not explicit in Yocto/Scene but are specified by assigning emissive materials. auto light = scene_material {}; // create a material light . color = { 0 , 0 , 0 }; // that does not reflect light light . emission = { 10 , 10 , 10 }; // but emits it instead Use eval_material(material, texcoord) to evaluate material textures and combine them with parameter values. The function returns a material_point that has the same parameters of a material but no textures defined. auto mat = eval_material ( scene , material ,{ 0.5 , 0.5 }) // eval material Textures Textures, represented as scene_texture , contains either 8-bit LDR or 32-bit float HDR images with four channels. Textures can be encoded in either a linear color space or as sRGBs, depending on an internal flag. The use of float versus byte is just a memory saving feature. For textures, set the size, the color space, and either the hdr or ldr pixels. auto hdr_texture = scene_texture {}; // create a texture hdr_texture . width = 512 ; // set size hdr_texture . height = 512 ; hdr_texture . linear = true ; // set color space and pixels for an HDR hdr_texture . pixelsf = vector < vec4f > {...}; auto ldr_texture = scene_texture {}; // create a texture ldr_texture . width = 512 ; // set size ldr_texture . height = 512 ; ldr_texture . linear = false ; // set color space and pixels for an LDR ldr_texture . pixelsb = vector < vec4b > {...}; Use eval_texture(texture, uv) to evaluate the texture at specific uvs. Textures evaluation returns a color in linear color space, regardless of the texture representation. auto col = eval_texture ( texture ,{ 0.5 , 0.5 }); // eval texture Subdivs Subdivs, represented as scene_subdiv , support tesselation and displacement mapping. Subdivs are represented as facee-varying shapes. Subdivs specify a level of subdivision and can be subdivide elements either linearly or using Catmull-Clark subdivision. Subdivs also support displacement by specifying both a displacement texture and a displacement amount. Differently from most systems, in Yocto/Scene displacement is specified in the shape and not the material. Subdivs only support tesselation to shapes, but do not directly support additional evaluation of properties. Subdivs specified to the shape index to which they are subdivided into. In this case, set the quads for positions, normals and texture coordinates. Also set the subdivision level, and whether to use Catmull-Clark or linear subdivision. Finally, displacement can also be applied by setting a displacement scale and texture. auto subdiv = scene_sundiv {}; // create a subdiv subdiv . quadspos = vector < vec4i > {...}; // set face-varying indices subdiv . quadstexcoord = vector < vec4i > {...}; // for positions and textures subdiv . positions = vector < vec3f > {...}; // set positions subdiv . texcoords = vector < vec2f > {...}; // set texture coordinates subdiv . subdivisions = 2 ; // set subdivision level subdiv . catmullclark = true ; // set Catmull-Clark subdivision subdiv . displacement = 1 ; // set displacement scale subdiv . displacement_tex = texture_id ; // and displacement map Most properties on subdivs cannot be directly evaluated, nor they are supported directly in scene processing. Instead, subdivs are converted to indexed shapes using tesselate_subdiv(subdiv, shape) for a specific subdiv, or tesselate_subdivs(scene) for the whole scene. tesselate_subdivs ( scene ); // tesselate all subdivs in the scene Face-Varying shapes We also support standalone face-varying shapes, that are not stored in the scene (see subdivs above). In this case, set the quads for positions, normals and texture coordinates. auto shape = scene_fvshape {}; // create a shape shape . quadspos = vector < vec4i > {...}; // set face-varying indices shape . quadstexcoord = vector < vec4i > {...}; // for positions and textures shape . positions = vector < vec3f > {...}; // set positions shape . texcoords = vector < vec2f > {...}; // set texture coordinates Example scenes Yocto/Scene has a function to create a simple Cornell Box scene for testing. There are plans to increase support for more test scenes in the future. auto scene = new sceneio_scene {...}; // create a complete scene make_cornellbox ( scene ); // make cornell box Procedural shapes Yocto/Scene has convenience function to create various procedural shapes, both for testing and for use in shape creation. These are wrappers to the corresponding functions in Yocto/Shape , where we maintain a comprehensive list of all procedural shapes supported. Procedural shapes take as input the desired shape resolution, the shape scale, the uv scale, and additional parameters specific to that procedural shape. These functions return a quad mesh, stored as a scene_shape struct. Use make_rect(...) for a rectangle in the XY plane, make_bulged_rect(...) for a bulged rectangle, make_recty(...) for a rectangle in the XZ plane, make_bulged_recty(...) for a bulged rectangle in the XZ plane, make_box(...) for a box, make_rounded_box(...) for a rounded box, make_floor(...) for a floor in the XZ plane, make_bent_floor(...) for a bent floor, make_sphere(...) for a sphere obtained from a cube, make_uvsphere(...) for a sphere tessellated along its uvs, make_capped_uvsphere(...) for a sphere with flipped caps, make_disk(...) for a disk obtained from a quad, make_bulged_disk(...) for a bulged disk, make_uvdisk(...) for a disk tessellated along its uvs, make_uvcylinder(...) for a cylinder tessellated along its uvs, make_rounded_uvcylinder(...) for a rounded cylinder. // make shapes with 32 steps in resolution and scale of 1 auto shape_01 = make_rect ({ 32 , 32 }, { 1 , 1 }); auto shape_02 = make_bulged_rect ({ 32 , 32 }, { 1 , 1 }); auto shape_03 = make_recty ({ 32 , 32 }, { 1 , 1 }); auto shape_04 = make_box ({ 32 , 32 , 32 }, { 1 , 1 , 1 }); auto shape_05 = make_rounded_box ({ 32 , 32 , 32 }, { 1 , 1 , 1 }); auto shape_06 = make_floor ({ 32 , 32 }, { 10 , 10 }); auto shape_07 = make_bent_floor ({ 32 , 32 }, { 10 , 10 }); auto shape_08 = make_sphere ( 32 , 1 ); auto shape_09 = make_uvsphere ({ 32 , 32 }, 1 ); auto shape_10 = make_capped_uvsphere ({ 32 , 32 }, 1 ); auto shape_11 = make_disk ( 32 , 1 ); auto shape_12 = make_bulged_disk ( 32 , 1 ); auto shape_13 = make_uvdiskm ({ 32 , 32 }, 1 ); auto shape_14 = make_uvcylinder ({ 32 , 32 , 32 }, { 1 , 1 }); auto shape_15 = make_rounded_uvcylinder ({ 32 , 32 , 32 }, { 1 , 1 }); Yocto/Shape defines a few procedural face-varying shapes with similar interfaces to the above functions. In this case, the functions return face-varying quads packed in a scene_fvshape struct. Use make_fvrect(...) for a rectangle in the XY plane, make_fvbox(...) for a box, make_fvsphere(...) for a sphere obtained from a cube. // make face-varying shapes with 32 steps in resolution and scale of 1 auto fvshape_01 = make_fvrect ({ 32 , 32 }, { 1 , 1 }); auto fvshape_02 = make_fvbox ({ 32 , 32 , 32 }, { 1 , 1 , 1 }); auto fvshape_03 = make_fvsphere ( 32 , 1 ); Yocto/Shape provides functions to create predefined shapes helpful in testing. These functions take only a scale and often provide only the positions as vertex data. These functions return either triangles, quads, or face-varying quads in a scene_shape or scene_fvshape struct. Use make_monkey(...) for the Blender monkey as quads and positions only, make_quad(...) for a simple quad, make_quady(...) for a simple quad in the XZ plane, make_cube(...) for a simple cube as quads and positions only, make_fvcube(...) for a simple face-varying unit cube, make_geosphere(...) for a geodesic sphere as triangles and positions only. These functions return a scene_shape or scene_fvshape . auto monkey = make_monkey ( 1 ); auto quad = make_quad ( 1 ); auto quady = make_quady ( 1 ); auto cube = make_cube ( 1 ); auto geosph = make_geosphere ( 1 ); auto fvcube = make_fvcube ( 1 ); Yocto/Shape supports the generation of points and lines sets. Use make_lines(...) to create a line set in the XY plane, make_points(...) for a collection of points at the origin, adn make_random_points(...) for a point set randomly placed in a box. These functions return points or lines, packed in a scene_shape struct. auto lines_01 = make_lines ({ 4 , 65536 }, // line steps and number of lines { 1 , 1 }, { 1 , 1 }, // line set scale and uvscale { 0.001 , 0.001 }); // radius at the bottom and top // procedural points return points, positions, normals, texcoords, radia auto [ points , positions , normals , texcoords , radius ] = make_points ( 65536 ); auto points_01 = make_points ( 65536 , // number of points 1 , // uvscale 0.001 ); // point radius auto points_02 = make_random_points ( 65536 , // number of points { 1 , 1 , 1 }, 1 , // line set scale and uvscale 0.001 ); // point radius Yocto/Shape also defines a simple functions to generate randomized hairs on a triangle or quad mesh. Use make_hair(...) to create a hair shape from a triangle and quad mesh, and return a line set. // Make a hair ball around a shape auto lines = make_hair ( make_sphere (), // sampled surface { 8 , 65536 }, // steps: line steps and number of lines { 0.1 , 0.1 }, // length: minimum and maximum length { 0.001 , 0.001 }, // radius: minimum and maximum radius from base to tip { 0 , 10 }, // noise: noise added to hair (strength/scale) { 0 , 128 }, // clump: clump added to hair (strength/number) { 0 , 0 }); // rotation: rotation added to hair (angle/strength) Finally, Yocto/Shape defines a function to create a quad mesh from a heighfield. Use make_heightfield(...) to create a heightfield meshes. auto heightfield = vctor < float > {...}; // heightfield data auto shape = make_heightfield ( size , heightfield ); // make heightfield mesh","title":"Scene representation"},{"location":"yocto/yocto_scene/#yoctoscene-scene-representation","text":"Yocto/Scene define a simple scene representation, and related utilities, used in the Yocto/GL path tracer and for scene IO. Yocto/Scene is implemented in yocto_scene.h and yocto_scene.cpp .","title":"Yocto/Scene: Scene representation"},{"location":"yocto/yocto_scene/#scene-representation","text":"Scenes are stored in scene_model structs and are comprised of arrays of cameras, instances, shapes, materials, textures and environments. The various objects are stored as values in arrays named like the object type. Animation is not currently supported. The scene representation is geared toward modeling physically-based environments. In Yocto/Scene, lights are not explicitly defined, but implicitly comprised of instances with emissive materials and environment maps. All scenes and objects properties are accessible directly. All scenes objects may have names that are used in IO. If names are defined, that have to be unique. If not, names are automatically generated. Names are stored separately from objects, for performance reasons. So for each object array, Yocto/Scene stores a corresponding names array. For examples, cameras as stored as cameras and their names are stored as camera_names . Cameras, instances and environments have coordinate frames to define the local to world transformation. Frames are presented as affine 3x4 matrices and are intended to be rigid transforms, although most scene processing support frames with scaling. Objects are added to the scene by directly adding elements to the corresponding arrays. References to elements are expressed as indices to the corresponding arrays. For each element type, properties can be set directly. Also, all scene objects are values, so you can work freely with them without concerning yourself with memory management. The mantra we followed here is that \"if you know how to use std::vector , you know how to use scenes\". Here is an sketch of how to create a shape instance in a scene. auto scene = scene_model {}; // create a scene auto shape = scene_shape {}; // create a shape and add it set_shape_properties ( shape , ...); scene . shapes . push_back ( shape ); scene . materials . push_back ({}); // create a black material directly auto instance = scene_instance {}; // create an instance of last added shape instance . shape = ( int ) scene . shapes . size () -1 ; instance . material = ( int ) scene . materials . size () -1 ; Yocto/Scene defines several function to evaluate scene properties. Use compute_bounds(scene) to compute the scene bounding boxes, scene_stats(scene) to get scene stats and scene_validation(scene) to validate scene objects. auto scene = scene_scene {...}; // create a complete scene auto bbox = compute_bounds ( scene ); // get bounds auto stats = scene_stats ( scene ); // get stats for ( auto stat : stats ) print_info ( stat ); // print stats auto errors = validate_stats ( scene ); // get validation errors for ( auto error : errors ) print_error ( error ); // print error","title":"Scene representation"},{"location":"yocto/yocto_scene/#cameras","text":"Cameras, represented by scene_camera , are based on a simple lens model. Cameras coordinate systems are defined by their frame. Cameras projections are described in photographic terms. In particular, we specify film size (35mm by default), film aspect ration, the lens' focal length, the focus distance and the lens aperture. All values are in meters. We support both perspective and orthographic cameras, but prefer the former. Common aspect ratios used in video and still photography are 3:2 on 35 mm (0.036 x 0.024), 16:9 on 35 mm (0.036 x 0.02025 or 0.04267 x 0.024), 2.35:1 on 35 mm (0.036 x 0.01532 or 0.05640 x 0.024), 2.39:1 on 35 mm (0.036 x 0.01506 or 0.05736 x 0.024), 2.40:1 on 35 mm (0.036 x 0.015 or 0.05760 x 0.024). To compute good apertures, one can use the F-stop number from photography and set the aperture to focal length over f-stop. To create cameras, you should set the camera frame, the camera view, via lens, aspect and film, and optionally the camera aperture and focus. auto camera = scene_camera {}; // create a camera camera . frame = identity3x4f ; // set frame to identity camera . lens = 0.050 ; // set as 50mm lens camera . aspect = 1.5 ; // set 3:2 aspect ratio camera . film = 0.036 ; // set the film as 35mm camera . aperture = 0.01 ; // set 10mm aperture camera . focus = 10 ; // set the focus at 10m Use get_camera(scene, name) to get a camera by name or the default camera is the name is not given. Use eval_camera(camera, image_uv, lens_uv) to get a camera ray from the normalized image coordinates image_uv and lens coordinates lens_uv . auto scene = scene_model {...}; // create a complete scene auto & camera = get_camera ( scene ); // get default camera auto ray = eval_camera ( camera ,{ 0.5 , 0.5 },{ 0 , 0 }); // get ray though image center","title":"Cameras"},{"location":"yocto/yocto_scene/#instances","text":"Instances, represented as scene_instance , place shapes in the scene by defining their coordinate frame, a shape index and a material index. Through the use of instancing, Yocto/Scene scales well to large environments without introducing more complex mechanisms. For instances, you should set the instance frame, shape and material. auto instance = scene_instance {}; // create an instance instance . frame = identity3x4f ; // set frame to identity instance . shape = shape_index ; // set shape index instance . material = material_index ; // set material index Several functions are defined to evaluate the geometric and material properties of points on shapes and instances, indicated by the shape element id and, when needed, the shape element barycentric coordinates. The difference between the shape and instance methods is that the former returns quantities in object space, while the latter in world space. Use eval_position(...) to evaluate the point position, eval_normal(...) to evaluate the interpolate point normal, eval_texcoord(...) to evaluate the point texture coordinates, eval_element_normal(...) to evaluate the point geometric normal, and eval_color(...) to evaluate the interpolate point color. Use eval_material(...) as a convenience function to evaluate material properties of instance points. auto eid = 0 ; auto euv = vec3f { 0.5 , 0.5 }; // element id and uvs auto pos = eval_position ( instance , eid , euv ); // eval point position auto norm = eval_normal ( instance , eid , euv ); // eval point normal auto st = eval_texcoord ( instance , eid , euv ); // eval point texture coords auto col = eval_color ( instance , eid , euv ); // eval point color auto gn = eval_element_normal ( instance , eid , euv ); // eval geometric normal auto mat = eval_material ( instance , eid , euv ); // eval point material","title":"Instances"},{"location":"yocto/yocto_scene/#environments","text":"Environments, represented as scene_environment , store the background illumination as a scene. Environments have a frame, to rotate illumination, an emission term and an optional emission texture. The emission texture is an HDR environment map stored in a LatLon parametrization. For environments, set the frame, emission and optionally the emission texture. auto & environment = scene_environment {}; // create an environment environment . frame = identity3x4f ; // set identity transform environment . emission = { 1 , 1 , 1 }; // set emission scale environment . emission_tex = texture_index ; // add emission texture Use eval_environment(environment, direction) to evaluate an environment map emission along a specific direction direction . Use eval_environment(scene, direction) to accumulate the lighting for all environment maps. auto scene = new trace_scene {...}; // create a complete scene auto enva = eval_environment ( scene , dir ); // eval all environments auto environment = scene . environments . front (); // get first environment auto envi = eval_environment ( environment , dir ); // eval environment","title":"Environments"},{"location":"yocto/yocto_scene/#shapes","text":"Shapes, represented by scene_shape , are indexed meshes of elements. Shapes can contain only one type of element, either points, lines, triangles or quads. Shape elements are parametrized as in Yocto/Geometry . Vertex properties are defined as separate arrays and include positions, normals, texture coords, colors, radius and tangent spaces. Additionally, Yocto/Scene supports face-varying primitives, as scene_fvshape , where each vertex data has its own topology. Shapes also work as a standalone mesh representation throughout the library and can be used even without a scene. For shapes, you should set the shape elements, i.e. point, limes, triangles or quads, and the vertex properties, i.e. positions, normals, texture coordinates, colors and radia. Shapes support only one element type. auto shape = scene_shape {}; // create a shape shape . triangles = vector < vec3i > {...}; // set triangle indices shape . positions = vector < vec3f > {...}; // set positions shape . normals = vector < vec3f > {...}; // set normals shape . texcoords = vector < vec2f > {...}; // set texture coordinates Several functions are defined to evaluate the geometric properties of points of shapes, indicated by the shape element id and, when needed, the shape element barycentric coordinates. Use eval_position(...) to evaluate the point position, eval_normal(...) to evaluate the interpolate point normal, eval_texcoord(...) to evaluate the point texture coordinates, eval_element_normal(...) to evaluate the point geometric normal, and eval_color(...) to evaluate the interpolate point color. auto eid = 0 ; auto euv = vec3f { 0.5 , 0.5 }; // element id and uvs auto pos = eval_position ( shape , eid , euv ); // eval point position auto norm = eval_normal ( shape , eid , euv ); // eval point normal auto st = eval_texcoord ( shape , eid , euv ); // eval point texture coords auto col = eval_color ( shape , eid , euv ); // eval point color auto gn = eval_element_normal ( shape , eid , euv ); // eval geometric normal Shape support random sampling with a uniform distribution using sample_shape(...) and sample_shape_cdf(shape) . Sampling works for lines and triangles in all cases, while for quad it requires that the elements are rectangular. auto cdf = sample_shape_cdfd ( shape ); // compute the shape CDF auto points = sample_shape ( shape , cdf , num ); // sample many points auto point = sample_shape ( shape , cdf , // sample a single point rand1f ( rng ), rand2f ( rng )); For shapes, we also support the computation of smooth vertex normals with compute_normals(shape) and converting to and from face-varying representations with shape_to_fvshape(shape) and fvshape_to_shape(fvshape) .","title":"Shapes"},{"location":"yocto/yocto_scene/#materials","text":"Materials, represented as scene_material , are defined by a material type and a few parameters, common to all materials. In particular, we support the following materials: matte , for materials like concrete or stucco, implemented as a lambertian bsdf; glossy , for materials like plastic or painted wood, implemented as the sum of a lambertian and a microfacet dielectric lobe; metallic , for materials like metals, implemented as either a delta or microfacet brdf lobe; transparent , for materials for thin glass, implemented as a delta or microfacet transmission bsdf; refractive , for materials for glass or water, implemented as a delta or microfacet refraction bsdf; also support homogenous volume scattering; subsurface , for materials for skin, implemented as a microfacet refraction bsdf with homogenous volume scattering - for no this is like refractive ; volume , for materials like homogeneous smoke or fog, implemented as the lack of a surface interface but with volumetric scattering. gltfpbr , for materials that range from glossy to metallic, implemented as the sum of a lambertian and a microfacet dielectric lobe; this is a compatibility material for loading and saving Khronos glTF data. All materials can specify a diffuse surface emission emission with HDR values that represent emitted radiance. Surface scattering is controlled by specifying the main surface color color , that represent the surface albedo, the surface roughness roughness and the index of refraction ior . The physical meaning of each parameter depends on the material type. By default surfaces are fully opaque, but can defined a opacity parameter and texture to define the surface coverage. Materials like refractive , subsurface and volume may also specify volumetric properties. In these cases, the color parameter controls the volume density, while the scattering also define volumetric scattering properties by setting a transmission parameter controls the homogenous volume scattering. All parameters can modulated by a corresponding textures, if present. For materials, we need to specify the material type and color at the minimum. We can further control the appearance by changing surface roughness, index of refraction and volumetric properties, when appropriate. Here are some examples. auto matte = scene_material {}; // create a matte material matte . type = scene_material_type :: matte ; matte . color = { 1 , 0.5 , 0.5 }; // with base color and matte . color_tex = texture_id ; // textured albedo auto glossy = scene_material {}; // create a glossy material glossy . type = scene_material_type :: glossy ; glossy . color = { 0.5 , 1 , 0.5 }; // with constant color glossyv . roughness = 0.1 ; // base roughness and a glossy . roughness_tex = texture_id ; // roughness texture auto metallic = scene_material {}; // create a metallic material glossy . type = scene_material_type :: metallic metal . color = { 0.5 , 0.5 , 1 }; // constant color metal . roughness = 0.1 ; // constant roughness auto tglass = scene_material {}; // create a transparent material tglass . type = scene_material_type :: transparent ; tglass . color = { 1 , 1 , 1 }; // with constant color auto glass = scene_material {}; // create a refractive material glass . type = scene_material_type :: transparent ; glass . color = { 1 , 0.9 , 0.9 }; // constant color auto subsurf = scene_material {}; // create a refractive material subsurf . type = scene_material_type :: subsurface ; subsurf . color = { 1 , 1 , 1 }; // that transmits all light subsurf . scattering = { 0.5 , 1 , 0.5 }; // and has volumetric scattering Lights are not explicit in Yocto/Scene but are specified by assigning emissive materials. auto light = scene_material {}; // create a material light . color = { 0 , 0 , 0 }; // that does not reflect light light . emission = { 10 , 10 , 10 }; // but emits it instead Use eval_material(material, texcoord) to evaluate material textures and combine them with parameter values. The function returns a material_point that has the same parameters of a material but no textures defined. auto mat = eval_material ( scene , material ,{ 0.5 , 0.5 }) // eval material","title":"Materials"},{"location":"yocto/yocto_scene/#textures","text":"Textures, represented as scene_texture , contains either 8-bit LDR or 32-bit float HDR images with four channels. Textures can be encoded in either a linear color space or as sRGBs, depending on an internal flag. The use of float versus byte is just a memory saving feature. For textures, set the size, the color space, and either the hdr or ldr pixels. auto hdr_texture = scene_texture {}; // create a texture hdr_texture . width = 512 ; // set size hdr_texture . height = 512 ; hdr_texture . linear = true ; // set color space and pixels for an HDR hdr_texture . pixelsf = vector < vec4f > {...}; auto ldr_texture = scene_texture {}; // create a texture ldr_texture . width = 512 ; // set size ldr_texture . height = 512 ; ldr_texture . linear = false ; // set color space and pixels for an LDR ldr_texture . pixelsb = vector < vec4b > {...}; Use eval_texture(texture, uv) to evaluate the texture at specific uvs. Textures evaluation returns a color in linear color space, regardless of the texture representation. auto col = eval_texture ( texture ,{ 0.5 , 0.5 }); // eval texture","title":"Textures"},{"location":"yocto/yocto_scene/#subdivs","text":"Subdivs, represented as scene_subdiv , support tesselation and displacement mapping. Subdivs are represented as facee-varying shapes. Subdivs specify a level of subdivision and can be subdivide elements either linearly or using Catmull-Clark subdivision. Subdivs also support displacement by specifying both a displacement texture and a displacement amount. Differently from most systems, in Yocto/Scene displacement is specified in the shape and not the material. Subdivs only support tesselation to shapes, but do not directly support additional evaluation of properties. Subdivs specified to the shape index to which they are subdivided into. In this case, set the quads for positions, normals and texture coordinates. Also set the subdivision level, and whether to use Catmull-Clark or linear subdivision. Finally, displacement can also be applied by setting a displacement scale and texture. auto subdiv = scene_sundiv {}; // create a subdiv subdiv . quadspos = vector < vec4i > {...}; // set face-varying indices subdiv . quadstexcoord = vector < vec4i > {...}; // for positions and textures subdiv . positions = vector < vec3f > {...}; // set positions subdiv . texcoords = vector < vec2f > {...}; // set texture coordinates subdiv . subdivisions = 2 ; // set subdivision level subdiv . catmullclark = true ; // set Catmull-Clark subdivision subdiv . displacement = 1 ; // set displacement scale subdiv . displacement_tex = texture_id ; // and displacement map Most properties on subdivs cannot be directly evaluated, nor they are supported directly in scene processing. Instead, subdivs are converted to indexed shapes using tesselate_subdiv(subdiv, shape) for a specific subdiv, or tesselate_subdivs(scene) for the whole scene. tesselate_subdivs ( scene ); // tesselate all subdivs in the scene","title":"Subdivs"},{"location":"yocto/yocto_scene/#face-varying-shapes","text":"We also support standalone face-varying shapes, that are not stored in the scene (see subdivs above). In this case, set the quads for positions, normals and texture coordinates. auto shape = scene_fvshape {}; // create a shape shape . quadspos = vector < vec4i > {...}; // set face-varying indices shape . quadstexcoord = vector < vec4i > {...}; // for positions and textures shape . positions = vector < vec3f > {...}; // set positions shape . texcoords = vector < vec2f > {...}; // set texture coordinates","title":"Face-Varying shapes"},{"location":"yocto/yocto_scene/#example-scenes","text":"Yocto/Scene has a function to create a simple Cornell Box scene for testing. There are plans to increase support for more test scenes in the future. auto scene = new sceneio_scene {...}; // create a complete scene make_cornellbox ( scene ); // make cornell box","title":"Example scenes"},{"location":"yocto/yocto_scene/#procedural-shapes","text":"Yocto/Scene has convenience function to create various procedural shapes, both for testing and for use in shape creation. These are wrappers to the corresponding functions in Yocto/Shape , where we maintain a comprehensive list of all procedural shapes supported. Procedural shapes take as input the desired shape resolution, the shape scale, the uv scale, and additional parameters specific to that procedural shape. These functions return a quad mesh, stored as a scene_shape struct. Use make_rect(...) for a rectangle in the XY plane, make_bulged_rect(...) for a bulged rectangle, make_recty(...) for a rectangle in the XZ plane, make_bulged_recty(...) for a bulged rectangle in the XZ plane, make_box(...) for a box, make_rounded_box(...) for a rounded box, make_floor(...) for a floor in the XZ plane, make_bent_floor(...) for a bent floor, make_sphere(...) for a sphere obtained from a cube, make_uvsphere(...) for a sphere tessellated along its uvs, make_capped_uvsphere(...) for a sphere with flipped caps, make_disk(...) for a disk obtained from a quad, make_bulged_disk(...) for a bulged disk, make_uvdisk(...) for a disk tessellated along its uvs, make_uvcylinder(...) for a cylinder tessellated along its uvs, make_rounded_uvcylinder(...) for a rounded cylinder. // make shapes with 32 steps in resolution and scale of 1 auto shape_01 = make_rect ({ 32 , 32 }, { 1 , 1 }); auto shape_02 = make_bulged_rect ({ 32 , 32 }, { 1 , 1 }); auto shape_03 = make_recty ({ 32 , 32 }, { 1 , 1 }); auto shape_04 = make_box ({ 32 , 32 , 32 }, { 1 , 1 , 1 }); auto shape_05 = make_rounded_box ({ 32 , 32 , 32 }, { 1 , 1 , 1 }); auto shape_06 = make_floor ({ 32 , 32 }, { 10 , 10 }); auto shape_07 = make_bent_floor ({ 32 , 32 }, { 10 , 10 }); auto shape_08 = make_sphere ( 32 , 1 ); auto shape_09 = make_uvsphere ({ 32 , 32 }, 1 ); auto shape_10 = make_capped_uvsphere ({ 32 , 32 }, 1 ); auto shape_11 = make_disk ( 32 , 1 ); auto shape_12 = make_bulged_disk ( 32 , 1 ); auto shape_13 = make_uvdiskm ({ 32 , 32 }, 1 ); auto shape_14 = make_uvcylinder ({ 32 , 32 , 32 }, { 1 , 1 }); auto shape_15 = make_rounded_uvcylinder ({ 32 , 32 , 32 }, { 1 , 1 }); Yocto/Shape defines a few procedural face-varying shapes with similar interfaces to the above functions. In this case, the functions return face-varying quads packed in a scene_fvshape struct. Use make_fvrect(...) for a rectangle in the XY plane, make_fvbox(...) for a box, make_fvsphere(...) for a sphere obtained from a cube. // make face-varying shapes with 32 steps in resolution and scale of 1 auto fvshape_01 = make_fvrect ({ 32 , 32 }, { 1 , 1 }); auto fvshape_02 = make_fvbox ({ 32 , 32 , 32 }, { 1 , 1 , 1 }); auto fvshape_03 = make_fvsphere ( 32 , 1 ); Yocto/Shape provides functions to create predefined shapes helpful in testing. These functions take only a scale and often provide only the positions as vertex data. These functions return either triangles, quads, or face-varying quads in a scene_shape or scene_fvshape struct. Use make_monkey(...) for the Blender monkey as quads and positions only, make_quad(...) for a simple quad, make_quady(...) for a simple quad in the XZ plane, make_cube(...) for a simple cube as quads and positions only, make_fvcube(...) for a simple face-varying unit cube, make_geosphere(...) for a geodesic sphere as triangles and positions only. These functions return a scene_shape or scene_fvshape . auto monkey = make_monkey ( 1 ); auto quad = make_quad ( 1 ); auto quady = make_quady ( 1 ); auto cube = make_cube ( 1 ); auto geosph = make_geosphere ( 1 ); auto fvcube = make_fvcube ( 1 ); Yocto/Shape supports the generation of points and lines sets. Use make_lines(...) to create a line set in the XY plane, make_points(...) for a collection of points at the origin, adn make_random_points(...) for a point set randomly placed in a box. These functions return points or lines, packed in a scene_shape struct. auto lines_01 = make_lines ({ 4 , 65536 }, // line steps and number of lines { 1 , 1 }, { 1 , 1 }, // line set scale and uvscale { 0.001 , 0.001 }); // radius at the bottom and top // procedural points return points, positions, normals, texcoords, radia auto [ points , positions , normals , texcoords , radius ] = make_points ( 65536 ); auto points_01 = make_points ( 65536 , // number of points 1 , // uvscale 0.001 ); // point radius auto points_02 = make_random_points ( 65536 , // number of points { 1 , 1 , 1 }, 1 , // line set scale and uvscale 0.001 ); // point radius Yocto/Shape also defines a simple functions to generate randomized hairs on a triangle or quad mesh. Use make_hair(...) to create a hair shape from a triangle and quad mesh, and return a line set. // Make a hair ball around a shape auto lines = make_hair ( make_sphere (), // sampled surface { 8 , 65536 }, // steps: line steps and number of lines { 0.1 , 0.1 }, // length: minimum and maximum length { 0.001 , 0.001 }, // radius: minimum and maximum radius from base to tip { 0 , 10 }, // noise: noise added to hair (strength/scale) { 0 , 128 }, // clump: clump added to hair (strength/number) { 0 , 0 }); // rotation: rotation added to hair (angle/strength) Finally, Yocto/Shape defines a function to create a quad mesh from a heighfield. Use make_heightfield(...) to create a heightfield meshes. auto heightfield = vctor < float > {...}; // heightfield data auto shape = make_heightfield ( size , heightfield ); // make heightfield mesh","title":"Procedural shapes"},{"location":"yocto/yocto_sceneio/","text":"Yocto/SceneIO: Scene serialization Yocto/SceneIO is a collection of functions to load and save images and scene elements, together with path manipulation utilities. Yocto/SceneIO is implemented in yocto_sceneio.h and yocto_sceneio.cpp , and depends on json.hpp for Json serialization, and stb_image.h , stb_image_write.h and tinyexr.h for the image serialization. Image serialization Images are loaded with load_image(filename, img, error) and saved with save_image(filename, img, error) . Both loading and saving take a filename, an image buffer and return whether or not the image was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Yocto/SceneIO supports loading and saving to JPG, PNG, TGA, BMP, HDR, EXR. When loading images, the color space is detected by the filename and stored in the returned image. Since color space information is not present in many images and since it is customary in 3D graphics to misuse color encoding, e.g. normal maps stored in sRGB, during loading 8bit file formats are assume to be encoded sRGB, while float formats are assumed to be encoded in linear RGB. Use is_hdr_filename(filename) to determine whether a supported format contains linear float data. When saving images, pixel values are converted to the color space supported by the chosen file format. auto error = string {}; auto image = color_image {}; // define an image if ( ! load_image ( filename , image , error )) // load image print_error ( error ); // check and print error if ( ! save_image ( filename , image , error )) // save image print_error ( error ); // check and print error Scene serialization Scenes are loaded with load_scene(filename, scene, error, progress) and saved with save_scene(filename, scene, error, progress) . Both loading and saving take a filename, a scene reference and return whether or not the scene was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Yocto/SceneIO supports loading and saving to a custom Json format, Obj, glTF, Pbrt, and all shape file formats. auto scene = scene_model {}; // scene auto error = string {}; // error buffer if ( ! load_scene ( filename , scene , error )) // load scene print_error ( error ); if ( ! save_scene ( filename , scene , error )) // save scene print_error ( error ); Shape serialization Shapes are loaded with load_shape(filename, shape, error) and saved with save_shape(filename, shape, error) . Face-varying shapes with load_fvshape(filename, shape, error) and saved with save_fvshape(filename, shape, error) . Both loading and saving take a filename, a scene reference and return whether or not the scene was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Yocto/SceneIO supports loading and saving to Ply, Obj, Stl. For indexed meshes, the type of elements is determined during loading, while face-varying coerce all face to quads. By default, texture coordinates are flipped vertically to match the convention of OpenGL texturing; this can be disabled by setting the flipv flag. auto shape = scene_shape {}; // shape auto error = string {}; // error buffer if ( ! load_shape ( filename , shape , error )) // load shape print_error ( error ); if ( ! save_shape ( filename , shape , error )) // save shape print_error ( error ); auto fvshape = scene_fvshape {}; // face-varying shape auto error = string {}; // error buffer if ( ! load_fvshape ( filename , fvshape , error )) // load shape print_error ( error ); if ( ! save_fvshape ( filename , fvshape , error )) // save shape print_error ( error ); Texture serialization Textures are loaded with load_texture(filename, texture, error) and saved with save_texture(filename, texture, error) . Both loading and saving take a filename, a texture and return whether or not the image was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Yocto/SceneIO supports loading and saving to JPG, PNG, TGA, BMP, HDR, EXR. When loading textures, the color space and bit depth is detected by the filename. Texture are loaded as float for float file formats, and as bytes for 8bit file formats. Since color space information is not present in many images, we assume that byte textures are encoded in sRGB, and float texture in linear RGB. Use is_hdr_filename(filename) to determine whether a supported format contains linear float data. When saving images, pixel values are converted to the color space supported by the chosen file format. auto error = string {}; auto texture = scene_texture {}; // define a texture if ( ! load_texture ( filename , texture , error )) // load texture print_error ( error ); // check and print error if ( ! save_texture ( filename , texture , error )) // save texture print_error ( error ); // check and print error Text and binary serialization Text files are loaded with load_text(filename, text, error) and saved with save_text(filename, text, error) . Binary files are loaded with load_binary(filename, binary, error) and saved with save_binary(filename, binary, error) . Both loading and saving take a filename, a text or binary buffer, and return whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto error = string {}; // error buffer auto text = string {}; // text buffer if ( ! load_text ( filename , text , error )) // load a text file print_error ( error ); // check and print error if ( ! save_text ( filename , text , error )) // save a text file print_error ( error ); // check and print error auto data = vector < byte > {}; // data buffer if ( ! load_binary ( filename , data , error )) // load a binary file print_error ( error ); // check and print error if ( ! save_binary ( filename , data , error )) // save a binary file print_error ( error ); // check and print error Path utilities Yocto/SceneIO contains several helper function to manipulate paths. These are just convenience wrapper of std::filesystem . Use path_dirname(filename) , path_extension(filename) , path_filename(filename) , path_basename(fillename) to extract the directory, extension, filename and basename from a path. Use path_join(patha,pathb) to joins paths and replace_extension(filename,ext) to replace a path extension. Use path_exists(filename) to check if a path exists and path_isdir(filename) and path_isfile(filename) to check whether it is a directory ot file respectively. Use list_directory(dirname) to list directory contents, and path_current() to get the current directory.","title":"Scene serialization"},{"location":"yocto/yocto_sceneio/#yoctosceneio-scene-serialization","text":"Yocto/SceneIO is a collection of functions to load and save images and scene elements, together with path manipulation utilities. Yocto/SceneIO is implemented in yocto_sceneio.h and yocto_sceneio.cpp , and depends on json.hpp for Json serialization, and stb_image.h , stb_image_write.h and tinyexr.h for the image serialization.","title":"Yocto/SceneIO: Scene serialization"},{"location":"yocto/yocto_sceneio/#image-serialization","text":"Images are loaded with load_image(filename, img, error) and saved with save_image(filename, img, error) . Both loading and saving take a filename, an image buffer and return whether or not the image was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Yocto/SceneIO supports loading and saving to JPG, PNG, TGA, BMP, HDR, EXR. When loading images, the color space is detected by the filename and stored in the returned image. Since color space information is not present in many images and since it is customary in 3D graphics to misuse color encoding, e.g. normal maps stored in sRGB, during loading 8bit file formats are assume to be encoded sRGB, while float formats are assumed to be encoded in linear RGB. Use is_hdr_filename(filename) to determine whether a supported format contains linear float data. When saving images, pixel values are converted to the color space supported by the chosen file format. auto error = string {}; auto image = color_image {}; // define an image if ( ! load_image ( filename , image , error )) // load image print_error ( error ); // check and print error if ( ! save_image ( filename , image , error )) // save image print_error ( error ); // check and print error","title":"Image serialization"},{"location":"yocto/yocto_sceneio/#scene-serialization","text":"Scenes are loaded with load_scene(filename, scene, error, progress) and saved with save_scene(filename, scene, error, progress) . Both loading and saving take a filename, a scene reference and return whether or not the scene was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Yocto/SceneIO supports loading and saving to a custom Json format, Obj, glTF, Pbrt, and all shape file formats. auto scene = scene_model {}; // scene auto error = string {}; // error buffer if ( ! load_scene ( filename , scene , error )) // load scene print_error ( error ); if ( ! save_scene ( filename , scene , error )) // save scene print_error ( error );","title":"Scene serialization"},{"location":"yocto/yocto_sceneio/#shape-serialization","text":"Shapes are loaded with load_shape(filename, shape, error) and saved with save_shape(filename, shape, error) . Face-varying shapes with load_fvshape(filename, shape, error) and saved with save_fvshape(filename, shape, error) . Both loading and saving take a filename, a scene reference and return whether or not the scene was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Yocto/SceneIO supports loading and saving to Ply, Obj, Stl. For indexed meshes, the type of elements is determined during loading, while face-varying coerce all face to quads. By default, texture coordinates are flipped vertically to match the convention of OpenGL texturing; this can be disabled by setting the flipv flag. auto shape = scene_shape {}; // shape auto error = string {}; // error buffer if ( ! load_shape ( filename , shape , error )) // load shape print_error ( error ); if ( ! save_shape ( filename , shape , error )) // save shape print_error ( error ); auto fvshape = scene_fvshape {}; // face-varying shape auto error = string {}; // error buffer if ( ! load_fvshape ( filename , fvshape , error )) // load shape print_error ( error ); if ( ! save_fvshape ( filename , fvshape , error )) // save shape print_error ( error );","title":"Shape serialization"},{"location":"yocto/yocto_sceneio/#texture-serialization","text":"Textures are loaded with load_texture(filename, texture, error) and saved with save_texture(filename, texture, error) . Both loading and saving take a filename, a texture and return whether or not the image was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. Yocto/SceneIO supports loading and saving to JPG, PNG, TGA, BMP, HDR, EXR. When loading textures, the color space and bit depth is detected by the filename. Texture are loaded as float for float file formats, and as bytes for 8bit file formats. Since color space information is not present in many images, we assume that byte textures are encoded in sRGB, and float texture in linear RGB. Use is_hdr_filename(filename) to determine whether a supported format contains linear float data. When saving images, pixel values are converted to the color space supported by the chosen file format. auto error = string {}; auto texture = scene_texture {}; // define a texture if ( ! load_texture ( filename , texture , error )) // load texture print_error ( error ); // check and print error if ( ! save_texture ( filename , texture , error )) // save texture print_error ( error ); // check and print error","title":"Texture serialization"},{"location":"yocto/yocto_sceneio/#text-and-binary-serialization","text":"Text files are loaded with load_text(filename, text, error) and saved with save_text(filename, text, error) . Binary files are loaded with load_binary(filename, binary, error) and saved with save_binary(filename, binary, error) . Both loading and saving take a filename, a text or binary buffer, and return whether or not the file was loaded successfully. In the case of an error, the IO functions set the error string with a message suitable for displaying to a user. auto error = string {}; // error buffer auto text = string {}; // text buffer if ( ! load_text ( filename , text , error )) // load a text file print_error ( error ); // check and print error if ( ! save_text ( filename , text , error )) // save a text file print_error ( error ); // check and print error auto data = vector < byte > {}; // data buffer if ( ! load_binary ( filename , data , error )) // load a binary file print_error ( error ); // check and print error if ( ! save_binary ( filename , data , error )) // save a binary file print_error ( error ); // check and print error","title":"Text and binary serialization"},{"location":"yocto/yocto_sceneio/#path-utilities","text":"Yocto/SceneIO contains several helper function to manipulate paths. These are just convenience wrapper of std::filesystem . Use path_dirname(filename) , path_extension(filename) , path_filename(filename) , path_basename(fillename) to extract the directory, extension, filename and basename from a path. Use path_join(patha,pathb) to joins paths and replace_extension(filename,ext) to replace a path extension. Use path_exists(filename) to check if a path exists and path_isdir(filename) and path_isfile(filename) to check whether it is a directory ot file respectively. Use list_directory(dirname) to list directory contents, and path_current() to get the current directory.","title":"Path utilities"},{"location":"yocto/yocto_shading/","text":"Yocto/Shading: Shading routines Yocto/Shading defines shading and sampling functions useful to write path tracing algorithms. Yocto/Shading is implemented in yocto_shading.h . Shading utilities Yocto/Shading defines many functions to handle Fresnel effects, both approximate and correct ones. Use fresnel_dielectric(eta, normal, outgoing) or fresnel_conductor(eta, etak, normal,outgoiong) to evaluate the fresnel term for dielectrics and conductors, or use fresnel_schlick(reflectivity, normal, outgoiong) for the Schlick fresnel approximation. The Schlick approximation uses reflectivity while the other functions use the index of refraction. All these functions that the normal and outgoing, or incoming, direction as input. Use eta_to_reflectivity(eta) and reflectivity_to_eta(reflectivity) to convert the dielectric index of refraction to reflectivity and vice-versa. Use eta_to_edgetint(eta, etak) and edgetint_to_eta(reflectivity, edgetint) to convert between the conductor index of refraction and its artist-friendly parametrization. Use conductor_eta(name) to get tabulated index of refractions for conductors. // approximate Fresnel for dielectric and conductors auto reflectivity1 = vec3f { 0.04 , 0.04 , 0.04 }; // dielectric reflectivity auto reflectivity2 = vec3f { 0.80 , 0.70 , 0.90 }; // conductor reflectivity auto fs1 = fresnel_schlick ( reflectivity_d , normal , outgoing ); auto fs1 = fresnel_schlick ( reflectivity_c , normal , outgoing ); // accurate Fresnel for dielectrics auto ior1 = vec3f { 1.5 , 1.5 , 1.5 }; // dielectric ior auto fd1 = fresnel_dielectric ( ior_d , normal , outgoing ); auto ior2 = reflectivity_to_eta ( reflectivity1 ); // reflectivity to ior // accurate Fresnel for conductors { \"Au\" , {{ 0.1431189557f , 0.3749570432f , 1.4424785571f }, { 3.9831604247f , 2.3857207478f , 1.6032152899f }}}, auto eta1 = vec3f { 0.143 , 0.375 , 1.442 }; // conductor complex ior auto etak1 = vec3f { 3.983 , 2.386 , 1.603 }; // conductor complex ior auto fc1 = fresnel_conductor ( eta1 , etak1 , normal , outgoing ); auto [ eta2 , etak2 ] = edgetint_to_eta ( reflectivity2 , vec3f {...}); // refl. to ior auto [ eta3 , etak3 ] = conductor_eta ( \"Au\" ); // get gold eta Most shaders today use some version of microfacet lobes for reflections and transmissions. Yocto/Shading has several functions to simplify writing those shaders. Use microfacet_distribution(roughness, normal, halfway, ggx) to evaluate the microfacet distribution and microfacet_shadowing(roughness, normal, halfway, ggx) to evaluate the shadow-masking term. Both functions take the surface roughness, the shading normal, the halfway vector and whether or not to use the GGX or Beckman distribution. Yocto/Shading also supports generating directions according to the microfacet distribution, both for GGX and Beckman. Use sample_microfacet(roughness, normal, rn, ggx) to generate halfway vector with distribution proportional to the microfacet distribution function and sample_microfacet(roughness, normal, outgoing, rn, ggx) to generate dictions using the distribution of visible normals. Use sample_microfacet_pdf(roughness, normal, halfway, ggx) or sample_microfacet_pdf(roughness, normal, halfway, outgoing, ggx) to compute the PDF for each sampling routine. auto normal = vec3f {...}; // shading normal auto incoming = vec3f {...} // incoming direction auto outgoing = vec3f {...}; // outgoing direction auto halfway = normalize ( incoming , outgoing ); // halfway vector reflection auto D = microfacet_distribution ( roughness , normal , halfway ); // distribution auto G = microfacet_shadowing ( roughness , normal , halfway ); // shadowing auto halfway1 = sample_microfacet ( roughness , normal , rand2f ( rng )); // sample auto pdf = sample_microfacet_pdf ( roughness , normal , halfway1 ); // sample pdf Yocto/Shading defines functions to simplify the implementation of volumetric effects. Use eval_transmittance(density, distance) to evaluate the transmittance of a homogeneous volume, sample_transmittance(density, max_distance, rn) to sample a distance inside an homogeneous medium, sample_transmittance_pdf(density, distance, max_distance) to compute the pdf of the sampled distance. The sampling function may return a distance equal to max distance, in which case the ray has exited the medium. Use mfp_to_transmission(mfp, depth) to convert mean-free-path to transmission at a specific depth. auto density = vec3f { 0.99 , 0.99 , 0.99 }; // medium density auto max_distance = float { 1 }; // maximum distance inside the medium auto distance = sample_transmittance ( density , max_distance , // sample distance rand1f ( rng ), rand1f ( rng )); auto pdf = sample_transmittance_pdf ( density , distance , max_distance ) // pdf auto transmittance = eval_transmittance ( density , distance ); Use eval_phasefunction(anisotropy, outgoing, incoming) to evaluate the HG phase function, sample_phasefunction(anisotropy, outgoing, rn) to sample a direction according to the phse function, sample_phasefunction_pdf(anisotropy, outgoing, incoming) to compute the pdf of the sampled direction. auto outgoing = vec3f {...}; // outgoing direction auto anisotropy = float { 0 }; // isotropic phase function auto incoming = sample_phasefunction ( anisotropy , outgoing , rand2f ( rng )); auto phasefunc = eval_phasefunction ( anisotropy , outgoing , incoming ); auto pdf = sample_phasefunction_pdf ( anisotropy , outgoing , incoming ); Surface materials Yocto/Shading provides implementation for several material types. Use eval_<material>(<params>, normal, outgoing, incoming) to evaluates the lobe BSDF multiplied by the cosine, sample_<material>(<params>, normal, outgoing, rn) to sample an incoming direction, and sample_<material>_pdf(<params>, normal, outgoing, incoming) to compute the sampled direction pdf. Yocto/Shading supports the following materials: matte : matte appearance implemented as a diffuse bsdf glossy : glossy appearance implemented as a sum of diffuse and microfacet bsdfs metallic : metallic appearance implemented as a delta or microfacet bsdfs transparent : thin glass-like appearance brdf implemented as a delta or microfacet bsdf refractive : glass-like appearance implemented as a delta or microfacet bsdf passthrough : used in volume rendering to simulated the absence of an interface gltfpbr : the pbr model used in Khronos glTF auto normal = vec3f {...}; // shading normal auto incoming = vec3f {...} // incoming direction auto outgoing = vec3f {...}; // outgoing direction auto color = vec3f { 1 , 0.5 , 0.5 }; // surface color auto roughness = float { 0.1 }; // roughness auto ior = float { 1.5 }; // dielectric ior // evaluate smooth lobes auto b1 = eval_matte ( color , normal , outgoing , incoming ); auto b3 = eval_glossy ( color , ior , roughness , normal , outgoing , incoming ); auto b4 = eval_metallic ( color , roughness , normal , outgoing , incoming ); auto b5 = eval_transparent ( color , ior , roughness , normal , outgoing , incoming ); auto b6 = eval_refractive ( color , ior , roughness , normal , outgoing , incoming ); // sample smooth lobes auto incoming1 = sample_matte ( color , normal , outgoing , rand2f ( rng )); auto pdf1 = sample_matte_pdf ( color , normal , outgoing , incoming ) // eval and sample delta lobes auto incoming2 = sample_metallic ( color , normal , outgoing ); auto b7 = eval_metallic ( color , normal , outgoing , incoming ); Design considerations Yocto/Shading evolved from using sum of Bsdf lobes to use full Bsdfs. Coincidentally, this evolution is similar to the way PBRT evolved from version 3 to version 4. But the motivation for this is different. In PBRT, the motivation for removing the sum of lobes representation was that a sum of lobes cannot reproduce materials in a physically-correct manner. In Yocto/Shading, the motivation is simplicity, which is a guiding principle in Yocto/GL. In the end, all materials are just approximations of real-world behavior. So saying that a material does not properly follow physics is weak in Yocto/GL, but entirely reasonable in systems that have different goals. On the other hand, the resulting code is significantly simpler and produces th same same results visually for all scenes that we have.","title":"Shading routines"},{"location":"yocto/yocto_shading/#yoctoshading-shading-routines","text":"Yocto/Shading defines shading and sampling functions useful to write path tracing algorithms. Yocto/Shading is implemented in yocto_shading.h .","title":"Yocto/Shading: Shading routines"},{"location":"yocto/yocto_shading/#shading-utilities","text":"Yocto/Shading defines many functions to handle Fresnel effects, both approximate and correct ones. Use fresnel_dielectric(eta, normal, outgoing) or fresnel_conductor(eta, etak, normal,outgoiong) to evaluate the fresnel term for dielectrics and conductors, or use fresnel_schlick(reflectivity, normal, outgoiong) for the Schlick fresnel approximation. The Schlick approximation uses reflectivity while the other functions use the index of refraction. All these functions that the normal and outgoing, or incoming, direction as input. Use eta_to_reflectivity(eta) and reflectivity_to_eta(reflectivity) to convert the dielectric index of refraction to reflectivity and vice-versa. Use eta_to_edgetint(eta, etak) and edgetint_to_eta(reflectivity, edgetint) to convert between the conductor index of refraction and its artist-friendly parametrization. Use conductor_eta(name) to get tabulated index of refractions for conductors. // approximate Fresnel for dielectric and conductors auto reflectivity1 = vec3f { 0.04 , 0.04 , 0.04 }; // dielectric reflectivity auto reflectivity2 = vec3f { 0.80 , 0.70 , 0.90 }; // conductor reflectivity auto fs1 = fresnel_schlick ( reflectivity_d , normal , outgoing ); auto fs1 = fresnel_schlick ( reflectivity_c , normal , outgoing ); // accurate Fresnel for dielectrics auto ior1 = vec3f { 1.5 , 1.5 , 1.5 }; // dielectric ior auto fd1 = fresnel_dielectric ( ior_d , normal , outgoing ); auto ior2 = reflectivity_to_eta ( reflectivity1 ); // reflectivity to ior // accurate Fresnel for conductors { \"Au\" , {{ 0.1431189557f , 0.3749570432f , 1.4424785571f }, { 3.9831604247f , 2.3857207478f , 1.6032152899f }}}, auto eta1 = vec3f { 0.143 , 0.375 , 1.442 }; // conductor complex ior auto etak1 = vec3f { 3.983 , 2.386 , 1.603 }; // conductor complex ior auto fc1 = fresnel_conductor ( eta1 , etak1 , normal , outgoing ); auto [ eta2 , etak2 ] = edgetint_to_eta ( reflectivity2 , vec3f {...}); // refl. to ior auto [ eta3 , etak3 ] = conductor_eta ( \"Au\" ); // get gold eta Most shaders today use some version of microfacet lobes for reflections and transmissions. Yocto/Shading has several functions to simplify writing those shaders. Use microfacet_distribution(roughness, normal, halfway, ggx) to evaluate the microfacet distribution and microfacet_shadowing(roughness, normal, halfway, ggx) to evaluate the shadow-masking term. Both functions take the surface roughness, the shading normal, the halfway vector and whether or not to use the GGX or Beckman distribution. Yocto/Shading also supports generating directions according to the microfacet distribution, both for GGX and Beckman. Use sample_microfacet(roughness, normal, rn, ggx) to generate halfway vector with distribution proportional to the microfacet distribution function and sample_microfacet(roughness, normal, outgoing, rn, ggx) to generate dictions using the distribution of visible normals. Use sample_microfacet_pdf(roughness, normal, halfway, ggx) or sample_microfacet_pdf(roughness, normal, halfway, outgoing, ggx) to compute the PDF for each sampling routine. auto normal = vec3f {...}; // shading normal auto incoming = vec3f {...} // incoming direction auto outgoing = vec3f {...}; // outgoing direction auto halfway = normalize ( incoming , outgoing ); // halfway vector reflection auto D = microfacet_distribution ( roughness , normal , halfway ); // distribution auto G = microfacet_shadowing ( roughness , normal , halfway ); // shadowing auto halfway1 = sample_microfacet ( roughness , normal , rand2f ( rng )); // sample auto pdf = sample_microfacet_pdf ( roughness , normal , halfway1 ); // sample pdf Yocto/Shading defines functions to simplify the implementation of volumetric effects. Use eval_transmittance(density, distance) to evaluate the transmittance of a homogeneous volume, sample_transmittance(density, max_distance, rn) to sample a distance inside an homogeneous medium, sample_transmittance_pdf(density, distance, max_distance) to compute the pdf of the sampled distance. The sampling function may return a distance equal to max distance, in which case the ray has exited the medium. Use mfp_to_transmission(mfp, depth) to convert mean-free-path to transmission at a specific depth. auto density = vec3f { 0.99 , 0.99 , 0.99 }; // medium density auto max_distance = float { 1 }; // maximum distance inside the medium auto distance = sample_transmittance ( density , max_distance , // sample distance rand1f ( rng ), rand1f ( rng )); auto pdf = sample_transmittance_pdf ( density , distance , max_distance ) // pdf auto transmittance = eval_transmittance ( density , distance ); Use eval_phasefunction(anisotropy, outgoing, incoming) to evaluate the HG phase function, sample_phasefunction(anisotropy, outgoing, rn) to sample a direction according to the phse function, sample_phasefunction_pdf(anisotropy, outgoing, incoming) to compute the pdf of the sampled direction. auto outgoing = vec3f {...}; // outgoing direction auto anisotropy = float { 0 }; // isotropic phase function auto incoming = sample_phasefunction ( anisotropy , outgoing , rand2f ( rng )); auto phasefunc = eval_phasefunction ( anisotropy , outgoing , incoming ); auto pdf = sample_phasefunction_pdf ( anisotropy , outgoing , incoming );","title":"Shading utilities"},{"location":"yocto/yocto_shading/#surface-materials","text":"Yocto/Shading provides implementation for several material types. Use eval_<material>(<params>, normal, outgoing, incoming) to evaluates the lobe BSDF multiplied by the cosine, sample_<material>(<params>, normal, outgoing, rn) to sample an incoming direction, and sample_<material>_pdf(<params>, normal, outgoing, incoming) to compute the sampled direction pdf. Yocto/Shading supports the following materials: matte : matte appearance implemented as a diffuse bsdf glossy : glossy appearance implemented as a sum of diffuse and microfacet bsdfs metallic : metallic appearance implemented as a delta or microfacet bsdfs transparent : thin glass-like appearance brdf implemented as a delta or microfacet bsdf refractive : glass-like appearance implemented as a delta or microfacet bsdf passthrough : used in volume rendering to simulated the absence of an interface gltfpbr : the pbr model used in Khronos glTF auto normal = vec3f {...}; // shading normal auto incoming = vec3f {...} // incoming direction auto outgoing = vec3f {...}; // outgoing direction auto color = vec3f { 1 , 0.5 , 0.5 }; // surface color auto roughness = float { 0.1 }; // roughness auto ior = float { 1.5 }; // dielectric ior // evaluate smooth lobes auto b1 = eval_matte ( color , normal , outgoing , incoming ); auto b3 = eval_glossy ( color , ior , roughness , normal , outgoing , incoming ); auto b4 = eval_metallic ( color , roughness , normal , outgoing , incoming ); auto b5 = eval_transparent ( color , ior , roughness , normal , outgoing , incoming ); auto b6 = eval_refractive ( color , ior , roughness , normal , outgoing , incoming ); // sample smooth lobes auto incoming1 = sample_matte ( color , normal , outgoing , rand2f ( rng )); auto pdf1 = sample_matte_pdf ( color , normal , outgoing , incoming ) // eval and sample delta lobes auto incoming2 = sample_metallic ( color , normal , outgoing ); auto b7 = eval_metallic ( color , normal , outgoing , incoming );","title":"Surface materials"},{"location":"yocto/yocto_shading/#design-considerations","text":"Yocto/Shading evolved from using sum of Bsdf lobes to use full Bsdfs. Coincidentally, this evolution is similar to the way PBRT evolved from version 3 to version 4. But the motivation for this is different. In PBRT, the motivation for removing the sum of lobes representation was that a sum of lobes cannot reproduce materials in a physically-correct manner. In Yocto/Shading, the motivation is simplicity, which is a guiding principle in Yocto/GL. In the end, all materials are just approximations of real-world behavior. So saying that a material does not properly follow physics is weak in Yocto/GL, but entirely reasonable in systems that have different goals. On the other hand, the resulting code is significantly simpler and produces th same same results visually for all scenes that we have.","title":"Design considerations"},{"location":"yocto/yocto_shape/","text":"Yocto/Shape: Shape utilities Yocto/Shape is a collection of utilities for manipulating shapes in 3D graphics, with a focus on triangle and quad meshes. Yocto/Shape is implemented in yocto_shape.h and yocto_shape.cpp . Shape representation Yocto/Shape supports shapes defined as collection of either points, lines, triangles and quads. Most functions have overrides for all element types when appropriate. Shapes are represented as indexed meshes, with arbitrary properties for each vertex. Each vertex property is stored as a separate array, and shape elements are stored as arrays of indices to faces. For element parametrization, we follow Yocto/Geometry . Vertex data is stored as vector<vecXf> , while element indices are stored as vector<vec3i> , vector<vec4i> , vector<vec2i> , vector<int> for triangle meshes, quad meshes, line sets and point sets respectively. auto triangles = vector < vec3i > {...}; // triangle indices auto positions = vector < vec3f > {...}; // vertex positions auto texcoords = vector < vec2f > {...}; // vertex uvs Face-varying shapes are also supported by specifying separate element indices for each vertex property, with arrays of vertex properties possibly of different length. This makes sure that any topology can be represented. For now, only face-varying quads are supported. auto quadspos = vector < vec4i > {...}; // quads indices for positions auto positions = vector < vec3f > {...}; // vertex positions auto quadstexcoords = vector < vec4i > {...}; // quads indices for uvs auto texcoords = vector < vec2f > {...}; // vertex uvs Throughout the library, functions may either take index and vertex arrays directly as input and output, or may pack these array in structs if deemed appropriate. This design tries to balance readability and generality, without forcing a single convention that would not be appropriate everywhere. If a higher level design is needed, Yocto/Scene contains the standalone types scene_shape and scene_fvshape to store indexed and face-varying shapes respectively, a a collection of methods to work on these type, that are essentially wrappers to the functionality in this library. Shape loading and saving is defined in Yocto/SceneIO . Vertex properties Yocto/Shape provides many facilities to compute vertex properties for indexed elements. Use triangles_normals(...) and quads_normals(...) to compute vertex normals for triangle and quad meshes, and line_tangents(...) for line tangents. Use skin_vertices(...) to apply linear-blend skinning. Use triangle_tangent_spaces(...) to compute tangents spaces for each ech meshes. auto triangles = vector < vec3i > {...}; // triangle indices auto positions = vector < vec3f > {...}; // vertex positions auto texcoords = vector < vec2f > {...}; // vertex uvs auto normals = triangle_normals ( triangles , positions ); // vertex normals auto tangsp = triangle_tangent_spaces ( triangles , positions , normals , texcoords ); auto weights = vector < vec4f > {...}; // skinning weights for 4 bones per vertex auto joints = vector < vec4i > {...}; // bine indices for 4 bones per vertex auto frames = vector < frame3f > {...}; // bone frames auto [ skinned_pos , skinned_norm ] = skin_vertices ( positions , normals , weights , joints , frames ); // skinned positions ans normals Flipping and aligning Yocto/Shape provides functions to correct shapes that have inconsistent orientations or normals. Use flip_normals(normals) to flip all mesh normals. Use flip_triangles(triangles) and flip_quads(quads) to change face orientations. Use align_vertices(positions,alignment) to align vertex positions to the main axes. auto triangles = vector < vec3i > {...}; // triangle indices auto positions = vector < vec3f > {...}; // vertex positions auto normals = vector < vec3f > {...}; // vertex normals triangles = flip_triangles ( triangles ); // flip faces normals = flip_normals ( normals ); // flip normals // align positions to the origin along the y axis only positions = align_vertices ( positions , { 0 , 1 , 0 }); Edges and adjacencies Use get_edges(triangles) amd get_edges(quads) to get a list of unique edges for a triangle or quads mesh. auto triangles = vector < vec3i > {...}; // triangle indices auto edges = get_edges ( triangles ); // edge indices Internally, these functions use an edge_map , that is a dictionary that has pairs of vertex ids as keys and an edge index as value. Two opposing half-edges have the same representation in an edge_map , making it useful in tesselation algorithms to avoid cracks. In Yocto/Shape, edge maps also stores the number of incident faces per edge, so that we can determine which edges belong to the boundary. auto triangles = vector < vec3i > {...}; // triangle indices auto emap = make_edge_map ( triangles ); // edge map auto edges = get_edges ( emap ); // edge indices for ( auto & edge : edges ) // iterate over edges print ( edge_index ( emap , edge )); // get edge indices auto boundary = get_boundary ( emap ); // get unsorted boundary edges Ray-intersection and point-overlap Yocto/Shape provides ray-scene intersection for points, lines, triangles and quads accelerated by a BVH data structure. Our BVH is written for minimal code and not maximum speed, but still gives fast-enough results. See Yocto/Geometry for intersection parametrization, and Yocto/Bvh for a more comprehensive version. The BVH tree is stored in a shape_bvh struct. The tree stored an array of nodes and an array of element indices. Each node in the tree has references to either other nodes or elements. References are represented as indices in the nodes or elements arrays. Nodes indices refer to the nodes array, for internal nodes, or the element arrays, for leaf nodes. The BVH does not store shape data, which is instead passed explicitly to all calls. BVH nodes contain their bounds, indices to the BVH arrays of either primitives or internal nodes, node element type, and the split axis. Leaf and internal nodes are identical, except that indices refer to primitives for leaf nodes or other nodes for internal nodes. The BVH is initialized with make_triangles_bvh(bvh,triangles,positions) for triangles, make_quads_bvh(bvh,quads,positions) for quads, make_lines_bvh(bvh,lines,positions,radius) for lines, and make_points_bvh(bvh,points,positions,radius) for points. auto triangles = vector < vec3i > {...}; // mesh data auto positions = vector < vec3f > {...}; auto bvh = make_triangles_bvh ( triangles , positions ); // BVH construction Intersect and overlap functions return a bvh_intersection that bundles the intersection distance, the intersected element index and uvs, and a hit flag that signals whether an element was hit. intersect_<element>_bvh(...) computed intersections between rays and shapes. Use intersect_triangles_bvh(bvh,triangles,positions, ray) for triangles, intersect_quads_bvh(bvh,quads,positions) for quads, intersect_lines_bvh(bvh,lines,positions,radius,ray) for lines, and intersect_points_bvh(bvh,points,positions,radius,ray) for points. auto ray = ray3f {...}; // computes ray-triangles intersection auto isec = intersect_triangles_bvh ( bvh , triangles , positions , ray ); if ( isec . hit ) print_info ( isec . element , isec . uv , isec . distance ); else print_info ( \"no hit\" ); overlap_<element>_bvh(...) checks whether a shape overlaps a point within a given maximum distance and returns the distance, element and uv of the closest element. Use overlap_triangles_bvh(bvh, triangles, positions, ray) for triangles, overlap_quads_bvh(bvh, quads, positions) for quads, overlap_lines_bvh(bvh, lines, positions, radius, ray) for lines, and overlap_points_bvh(bvh, points, positions, radius, ray) for points. auto pt = vec3f {...}; auto max_dist = float {...}; // comnpute point-triangles overlap auto ovr = overlap_triangles_bvh ( bvh , triangles , positions , pt , mat_dist ); if ( ovr . hit ) print_info ( ovrl . element , ovrl . uv , ovrl . distance ); else print_info ( \"no overlap\" ); If vertices have moved little, BVHs can be updated instead of fully rebuild. Use update_triangles_bvh(bvh, triangles, positions) for triangles, update_quads_bvh(bvh, quads, positions) for quads, update_lines_bvh(bvh, lines, positions, radius) for lines, and update_points_bvh(bvh, points, positions, radius) for points. positions [...] = {...}; // update positions update_triangles_bvh ( bvh , triangles , positions ); // update BVH Nearest neighbors Nearest neighbors queries are computed by building a sparse hash grid defined as hash_grid . The grid is created by specifying a cell size for the underlying volumetric grid. Each cell stores the list of point indices that are present in that cell. To save memory, the grid is represented sparsely, using a dictionary, so that only cells with at least one vertex are defined. Initialize a hash grid with make_hash_grid(positions, size) . Use find_neighbors(grid, neighbors, position, max_radius) to find nearest neighbors. auto positions = vector < vec3f > {...}; // point positions auto grid = make_hash_grid ( positions , cell_size ); // create hash grid auto pt = vec3f {...}; auto max_dist = float {...}; // query point and dist auto neighbors = vector < int > {}; // neighbor buffer find_neighbors ( grid , neighbors , pt , max_dist ); // find neighbors by pos find_neighbors ( grid , neighbors , id , max_dist ); // find neighbors by id Element conversions and grouping Yocto/Shape support conversion between shape elements. Use quads_to_triangles(quads) to convert quads to triangles and triangles_to_quads(triangles) to convert triangles to degenerate quads. Use bezier_to_lines(lines) to convert B\u00e9zier segments to lines using three lines for each B\u00e9zier segment. auto quads = vector < vec4i > {...}; auto triangles = quads_to_triangles ( quads ); // convert quads to triangles Face-varying meshes are stored by having different face indices for each vertex propeerty. This way, every vertex property has its own topology. Use split_facevarying(...) to convert to an indexed mesh. During conversion vertices may be duplicated since the same topology is used for all vertex properties. auto fvquadspos = vector < vec4i > {...}; // face-varying indices auto fvquadsnorm = vector < vec4i > {...}; // arrays have some length auto fvquadstexcoord = vector < vec4i > {...}; auto fvpositions = vector < vec3f > {...}; // face-varying vertices auto fvnormals = vector < vec3f > {...}; // arrays may have different lengths auto fvtexcoords = vector < vec2f > {...}; auto [ quads , positions , normals , texcoords ] = // convert to indexed mesh split_facevarying ( fvquadspos , fvquadsnorm , fvquadstexcoord , fvpositions , fvnormals , fvtexcoords ); Yocto/Shape supports eliminating duplicate vertices in triangle and quad meshes. All vertices within a threshold are merged in a greedy fashion, which works well when duplicated vertices are near other while other vertices are further away. Use weld_triangles(triangles, positions, threshold) to eliminate duplicated triangle vertices and weld_quads(quads, positions, threshold) to eliminate duplicated quad vertices. For lower-level algorithms, use weld_vertices(positions, threshold) to group vertices together. auto triangles = vector < vec3i > {...}; // mesh data auto positions = vector < vec3f > {...}; auto tolerance = 0.1f ; auto [ mtriangles , mpositions ] = // remove duplicates weld_triangles ( triangles , positions , tolerance ); Yocto/Shape supports splitting shapes that are tagged by ids. This is helpful for example when drawing meshes that have per-face materials using renders that do support one material per shape only. Use ungroup_lines(lines,ids) , ungroud_triangles(triangles,ids) and ungroup_quads(quads,ids) for lines, triangles and quads respectively. auto triangles = vector < vec3i > {...}; // tagged mesh with one id per face auto ids = vector < int > {...}; auto split = ungroup_triangles ( triangles , ids ); // returns list of meshes Yocto/Shape supports merging shape elements. This is useful, for example, when building up shapes from parts. The merged shapes are just concatenation of the individual shape without vertex merging. Use merge_lines(...) for lines, merge_triangles(...) for triangles and merge_quads(...) for quads. auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto mtriangles = vector < vec3i > {...}; // shape to be merged auto mpositions = vector < vec3f > {...}; auto mnormals = vector < vec3f > {...}; auto mtexcoords = vector < vec2f > {...}; // merge mtriangles into triangles in-placee merge_triangles ( triangles , positions , normals , texcoords , mtriangles , mpositions , mnormals , mtexcoords ); You can also merge triangles and quads together in other to have one primitive only. Use merge_triangles_and_quads(triangles, quads, force_triangles) to merge elements in-place. The algorithms will output quads if present or triangles if not unless force_triangles is used. Shape subdivision Yocto/Shape defines functions to subdivide shape elements linearly, in order to obtain higher shape resolution, for example before applying displacement mapping. All functions will split all shape elements, regardless of their size. This ensures that meshes have no cracks. Use subdivide_lines(lines, vert, level) for lines, subdivide_triangles(triangles, vert, level) for triangles, subdivide_quads(quads, vert, level) for quads, and subdivide_bezier(beziers, vert, level) for Bezier segments. In this subdivision, each line is split in two lines, each triangle in three triangles, each quad in four quads, and each Bezier segment in two segments. The functions apply the subdivision rules level number of times and act on a single vertex property at a time for maximum flexibility. auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; // subdivide the triangle mesh recursively two times auto [ striangles , spositions ] = subdivide_triangles ( triangles , positions , 2 ); Yocto/Shape also supports Catmull-Clark subdivision surfaces with subdivide_catmullclark(quads, vert, level, creased) . In this case, Catmull-Clark subdivision rules are used to smooth the mesh after linear subdivision. The boundary can be treated as creases with creased , which is necessary when subdividing texture coordinates. auto quads = vector < vec4i > {...}; // initial shape auto positions = vector < vec3f > {...}; // subdivide the quad mesh recursively two times auto [ squads , spositions ] = subdivide_catmullclark ( quads , positions , 2 , false ); auto tquads = vector < vec4i > {...}; // face-varying shape with texture coords auto texcoords = vector < vec2f > {...}; // subdivide the triangle mesh recursively two times auto [ stquads , stexcoords ] = subdivide_catmullclark ( tquads , texcoords , 2 , true ); Shape sampling Yocto/Shape supports sampling meshes uniformly. All sampling require to first compute the shape CDF and then use it to sample the shape. For each shape type, the sampling functions return the shape element id and the element barycentric coordinates. Use sample_lines(cdf, re, rn) to sample lines, sample_triangles(cdf, re, rn) to sample triangles, sample_quads(cdf, re, rn) to sample quads. The shape CDFs are computed using sample_lines_dcf(lines, positions) , sample_triangles_dcf(triangles, positions) , and sample_quads_dcf(quads, positions) . auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; auto cdf = sample_triangles_cdf ( triangles , positions ); // shape cdf for ( auto sample : range ( samples )) { // sample the shape returning element id and uvs auto [ triangle_id , uv ] = sample_triangles ( cdf , rand1f ( rng ), rand2f ( rng )); } For triangles and quads, Yocto/Shape defines convenience functions that generate a set of points on the shape surface. Use sample_triangles(...) and sample_quads(...) for triangles and quads respectively. auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto sampled_positions = vector < vec3f > {...}; // sampled points auto sampled_normals = vector < vec3f > {...}; auto sampled_texcoords = vector < vec2f > {...}; // sample a set of npoints on the mesh auto npoints = 100 ; sample_triangles ( sampled_positions , sampled_normals , sampled_texcoords , triangles , positions , normals , texcoords , npoints ); Procedural shapes Yocto/Shape defines several procedural shapes used for both testing and to quickly create shapes for procedural scenes. Procedural shapes take as input the desired shape resolution, the shape scale, the uv scale, and additional parameters specific to that procedural shape. These functions return quads indices and vertex positions, normals and texture coordinates, with arrays passed in. Use make_rect(...) for a rectangle in the XY plane, make_bulged_rect(...) for a bulged rectangle, make_recty(...) for a rectangle in the XZ plane, make_bulged_recty(...) for a bulged rectangle in the XZ plane, make_box(...) for a box, make_rounded_box(...) for a rounded box, make_floor(...) for a floor in the XZ plane, make_bent_floor(...) for a bent floor, make_sphere(...) for a sphere obtained from a cube, make_uvsphere(...) for a sphere tessellated along its uvs, make_capped_uvsphere(...) for a sphere with flipped caps, make_disk(...) for a disk obtained from a quad, make_bulged_disk(...) for a bulged disk, make_uvdisk(...) for a disk tessellated along its uvs, make_uvcylinder(...) for a cylinder tessellated along its uvs, make_rounded_uvcylinder(...) for a rounded cylinder. // most procedural shapes return quads, positions, normals, and texcoords auto quads = vector < vec4i > {}; auto positions = vector < vec3f > {}; auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; // make shapes with 32 steps in resolution and scale of 1 make_rect ( quads , positions , normals , texcoords , { 32 , 32 }, { 1 , 1 }); make_bulged_rect ( quads , positions , normals , texcoords , { 32 , 32 }, { 1 , 1 }); make_recty ( quads , positions , normals , texcoords , { 32 , 32 }, { 1 , 1 }); make_box ( quads , positions , normals , texcoords , { 32 , 32 , 32 }, { 1 , 1 , 1 }); make_rounded_box ( quads , positions , normals , texcoords , { 32 , 32 , 32 }, { 1 , 1 , 1 }); make_floor ( quads , positions , normals , texcoords , { 32 , 32 }, { 10 , 10 }); make_bent_floor ( quads , positions , normals , texcoords , { 32 , 32 }, { 10 , 10 }); make_sphere ( quads , positions , normals , texcoords , 32 , 1 ); make_uvsphere ( quads , positions , normals , texcoords , { 32 , 32 }, 1 ); make_capped_uvsphere ( quads , positions , normals , texcoords , { 32 , 32 }, 1 ); make_disk ( quads , positions , normals , texcoords , 32 , 1 ); make_bulged_disk ( quads , positions , normals , texcoords , 32 , 1 ); make_uvdiskm ( quads , positions , normals , texcoords , { 32 , 32 }, 1 ); make_uvcylinder ( quads , positions , normals , texcoords , { 32 , 32 , 32 }, { 1 , 1 }); make_rounded_uvcylinder ( quads , positions , normals , texcoords , { 32 , 32 , 32 }, { 1 , 1 }); Yocto/Shape defines a few procedural face-varying shapes with similar interfaces to the above functions. In this case, the functions return face indices and vertex data for positions, normals and texture coordinates packed in a quads_fvshape struct. Use make_fvrect(...) for a rectangle in the XY plane, make_fvbox(...) for a box, make_fvsphere(...) for a sphere obtained from a cube. // procedural face-varying shapes return positions, normals, and texcoords auto quadspos = vector < vec4i > {}; auto quadsnorm = vector < vec4i > {}; auto quadstexcoord = vector < vec4i > {}; auto positions = vector < vec3f > {}; auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; // make face-varying shapes with 32 steps in resolution and scale of 1 make_fvrect ( quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , { 32 , 32 }, { 1 , 1 }); make_fvbox ( quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , { 32 , 32 , 32 }, { 1 , 1 , 1 }); make_fvsphere ( quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , 32 , 1 ); Yocto/Shape provides functions to create predefined shapes helpful in testing. These functions take only a scale and often provide only the positions as vertex data. These functions return either triangles, quads, or face-varying quads. Use make_monkey(...) for the Blender monkey as quads and positions only, make_quad(...) for a simple quad, make_quady(...) for a simple quad in the XZ plane, make_cube(...) for a simple cube as quads and positions only, make_fvcube(...) for a simple face-varying unit cube, make_geosphere(...) for a geodesic sphere as triangles and positions only. // built-in shapes return elemeents, positions, normals, and texcoords auto quads = vector < vec4i > {}; auto triangles = vector < vec3i > {}; auto quadspos = vector < vec4i > {}; auto quadsnorm = vector < vec4i > {}; auto quadstexcoord = vector < vec4i > {}; auto positions = vector < vec3f > {}; auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; // make built-in shapes with scale of 1 make_monkey ( quads , positions , normals , texcoords , 1 ); make_quad ( quads , positions , normals , texcoords , 1 ); make_quady ( quads , positions , normals , texcoords , 1 ); make_cube ( quads , positions , normals , texcoords , 1 ); make_geosphere ( triangles , positions , normals , texcoords , 1 ); make_fvcube ( quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , 1 ); Yocto/Shape supports the generation of points and lines sets. Use make_lines(...) to create a line set in the XY plane, make_points(...) for a collection of points at the origin, adn make_random_points(...) for a point set randomly placed in a box. These functions return shapes that are defined in terms of lines or points and return lines or points indices, and vertex positions, normals, texture coordinates and radia, packed in a lines_shape or points_shape struct. // procedural lines return lines, positions, normals, texcoords, radia auto lines = vector < vec2i > {}; auto positions = vector < vec3f > {}; auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto radius = vector < float > {}; make_lines ( lines , positions , normals , texcoords , radius , { 4 , 65536 }, // line steps and number of lines { 1 , 1 }, { 1 , 1 }, // line set scale and uvscale { 0.001 , 0.001 }); // radius at the bottom and top // procedural points return points, positions, normals, texcoords, radia make_points ( points , positions , normals , texcoords , radius , 65536 , // number of points 1 , // uvscale 0.001 ); // point radius make_random_points ( points , positions , normals , texcoords , radius , 65536 , // number of points { 1 , 1 , 1 }, 1 , // line set scale and uvscale 0.001 ); // point radius Yocto/Shape also defines a simple function to generate randomized hairs on a triangle or quad mesh. Use make_hair(...) to create a hair shape from a triangle and quad mesh, and return a line set. // Make a hair ball around a shape auto lines = vector < vec2i > {}; auto positions = vector < vec3f > {}; auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto radius = vector < float > {}; make_hair ( lines , positions , normals , texcoords , radius , surface_triangles , surface_quads , // sampled surface surface_positions , surface_normals , surface_texcoords { 8 , 65536 }, // steps: line steps and number of lines { 0.1 , 0.1 }, // length: minimum and maximum length { 0.001 , 0.001 }, // radius: minimum and maximum radius from base to tip { 0 , 10 }, // noise: noise added to hair (strength/scale) { 0 , 128 }, // clump: clump added to hair (strength/number) { 0 , 0 }); // rotation: rotation added to hair (angle/strength) Finally, Yocto/Shape defines a function to create a quad mesh from a heighfield. Use make_heightfield(...) to create a heightfield meshes. auto quads = vector < vec4i > {}; // shape element buffer auto positions = vector < vec3f > {}; // vertex data buffers auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto size = vec2i { 512 , 512 }; // heightfield size auto heightfield = vctor < float > {...}; // heightfield data make_heightfield ( quads , positions , normals , texcoords , size , heightfield ); // make heightfield mesh","title":"Shape utilities"},{"location":"yocto/yocto_shape/#yoctoshape-shape-utilities","text":"Yocto/Shape is a collection of utilities for manipulating shapes in 3D graphics, with a focus on triangle and quad meshes. Yocto/Shape is implemented in yocto_shape.h and yocto_shape.cpp .","title":"Yocto/Shape: Shape utilities"},{"location":"yocto/yocto_shape/#shape-representation","text":"Yocto/Shape supports shapes defined as collection of either points, lines, triangles and quads. Most functions have overrides for all element types when appropriate. Shapes are represented as indexed meshes, with arbitrary properties for each vertex. Each vertex property is stored as a separate array, and shape elements are stored as arrays of indices to faces. For element parametrization, we follow Yocto/Geometry . Vertex data is stored as vector<vecXf> , while element indices are stored as vector<vec3i> , vector<vec4i> , vector<vec2i> , vector<int> for triangle meshes, quad meshes, line sets and point sets respectively. auto triangles = vector < vec3i > {...}; // triangle indices auto positions = vector < vec3f > {...}; // vertex positions auto texcoords = vector < vec2f > {...}; // vertex uvs Face-varying shapes are also supported by specifying separate element indices for each vertex property, with arrays of vertex properties possibly of different length. This makes sure that any topology can be represented. For now, only face-varying quads are supported. auto quadspos = vector < vec4i > {...}; // quads indices for positions auto positions = vector < vec3f > {...}; // vertex positions auto quadstexcoords = vector < vec4i > {...}; // quads indices for uvs auto texcoords = vector < vec2f > {...}; // vertex uvs Throughout the library, functions may either take index and vertex arrays directly as input and output, or may pack these array in structs if deemed appropriate. This design tries to balance readability and generality, without forcing a single convention that would not be appropriate everywhere. If a higher level design is needed, Yocto/Scene contains the standalone types scene_shape and scene_fvshape to store indexed and face-varying shapes respectively, a a collection of methods to work on these type, that are essentially wrappers to the functionality in this library. Shape loading and saving is defined in Yocto/SceneIO .","title":"Shape representation"},{"location":"yocto/yocto_shape/#vertex-properties","text":"Yocto/Shape provides many facilities to compute vertex properties for indexed elements. Use triangles_normals(...) and quads_normals(...) to compute vertex normals for triangle and quad meshes, and line_tangents(...) for line tangents. Use skin_vertices(...) to apply linear-blend skinning. Use triangle_tangent_spaces(...) to compute tangents spaces for each ech meshes. auto triangles = vector < vec3i > {...}; // triangle indices auto positions = vector < vec3f > {...}; // vertex positions auto texcoords = vector < vec2f > {...}; // vertex uvs auto normals = triangle_normals ( triangles , positions ); // vertex normals auto tangsp = triangle_tangent_spaces ( triangles , positions , normals , texcoords ); auto weights = vector < vec4f > {...}; // skinning weights for 4 bones per vertex auto joints = vector < vec4i > {...}; // bine indices for 4 bones per vertex auto frames = vector < frame3f > {...}; // bone frames auto [ skinned_pos , skinned_norm ] = skin_vertices ( positions , normals , weights , joints , frames ); // skinned positions ans normals","title":"Vertex properties"},{"location":"yocto/yocto_shape/#flipping-and-aligning","text":"Yocto/Shape provides functions to correct shapes that have inconsistent orientations or normals. Use flip_normals(normals) to flip all mesh normals. Use flip_triangles(triangles) and flip_quads(quads) to change face orientations. Use align_vertices(positions,alignment) to align vertex positions to the main axes. auto triangles = vector < vec3i > {...}; // triangle indices auto positions = vector < vec3f > {...}; // vertex positions auto normals = vector < vec3f > {...}; // vertex normals triangles = flip_triangles ( triangles ); // flip faces normals = flip_normals ( normals ); // flip normals // align positions to the origin along the y axis only positions = align_vertices ( positions , { 0 , 1 , 0 });","title":"Flipping and aligning"},{"location":"yocto/yocto_shape/#edges-and-adjacencies","text":"Use get_edges(triangles) amd get_edges(quads) to get a list of unique edges for a triangle or quads mesh. auto triangles = vector < vec3i > {...}; // triangle indices auto edges = get_edges ( triangles ); // edge indices Internally, these functions use an edge_map , that is a dictionary that has pairs of vertex ids as keys and an edge index as value. Two opposing half-edges have the same representation in an edge_map , making it useful in tesselation algorithms to avoid cracks. In Yocto/Shape, edge maps also stores the number of incident faces per edge, so that we can determine which edges belong to the boundary. auto triangles = vector < vec3i > {...}; // triangle indices auto emap = make_edge_map ( triangles ); // edge map auto edges = get_edges ( emap ); // edge indices for ( auto & edge : edges ) // iterate over edges print ( edge_index ( emap , edge )); // get edge indices auto boundary = get_boundary ( emap ); // get unsorted boundary edges","title":"Edges and adjacencies"},{"location":"yocto/yocto_shape/#ray-intersection-and-point-overlap","text":"Yocto/Shape provides ray-scene intersection for points, lines, triangles and quads accelerated by a BVH data structure. Our BVH is written for minimal code and not maximum speed, but still gives fast-enough results. See Yocto/Geometry for intersection parametrization, and Yocto/Bvh for a more comprehensive version. The BVH tree is stored in a shape_bvh struct. The tree stored an array of nodes and an array of element indices. Each node in the tree has references to either other nodes or elements. References are represented as indices in the nodes or elements arrays. Nodes indices refer to the nodes array, for internal nodes, or the element arrays, for leaf nodes. The BVH does not store shape data, which is instead passed explicitly to all calls. BVH nodes contain their bounds, indices to the BVH arrays of either primitives or internal nodes, node element type, and the split axis. Leaf and internal nodes are identical, except that indices refer to primitives for leaf nodes or other nodes for internal nodes. The BVH is initialized with make_triangles_bvh(bvh,triangles,positions) for triangles, make_quads_bvh(bvh,quads,positions) for quads, make_lines_bvh(bvh,lines,positions,radius) for lines, and make_points_bvh(bvh,points,positions,radius) for points. auto triangles = vector < vec3i > {...}; // mesh data auto positions = vector < vec3f > {...}; auto bvh = make_triangles_bvh ( triangles , positions ); // BVH construction Intersect and overlap functions return a bvh_intersection that bundles the intersection distance, the intersected element index and uvs, and a hit flag that signals whether an element was hit. intersect_<element>_bvh(...) computed intersections between rays and shapes. Use intersect_triangles_bvh(bvh,triangles,positions, ray) for triangles, intersect_quads_bvh(bvh,quads,positions) for quads, intersect_lines_bvh(bvh,lines,positions,radius,ray) for lines, and intersect_points_bvh(bvh,points,positions,radius,ray) for points. auto ray = ray3f {...}; // computes ray-triangles intersection auto isec = intersect_triangles_bvh ( bvh , triangles , positions , ray ); if ( isec . hit ) print_info ( isec . element , isec . uv , isec . distance ); else print_info ( \"no hit\" ); overlap_<element>_bvh(...) checks whether a shape overlaps a point within a given maximum distance and returns the distance, element and uv of the closest element. Use overlap_triangles_bvh(bvh, triangles, positions, ray) for triangles, overlap_quads_bvh(bvh, quads, positions) for quads, overlap_lines_bvh(bvh, lines, positions, radius, ray) for lines, and overlap_points_bvh(bvh, points, positions, radius, ray) for points. auto pt = vec3f {...}; auto max_dist = float {...}; // comnpute point-triangles overlap auto ovr = overlap_triangles_bvh ( bvh , triangles , positions , pt , mat_dist ); if ( ovr . hit ) print_info ( ovrl . element , ovrl . uv , ovrl . distance ); else print_info ( \"no overlap\" ); If vertices have moved little, BVHs can be updated instead of fully rebuild. Use update_triangles_bvh(bvh, triangles, positions) for triangles, update_quads_bvh(bvh, quads, positions) for quads, update_lines_bvh(bvh, lines, positions, radius) for lines, and update_points_bvh(bvh, points, positions, radius) for points. positions [...] = {...}; // update positions update_triangles_bvh ( bvh , triangles , positions ); // update BVH","title":"Ray-intersection and point-overlap"},{"location":"yocto/yocto_shape/#nearest-neighbors","text":"Nearest neighbors queries are computed by building a sparse hash grid defined as hash_grid . The grid is created by specifying a cell size for the underlying volumetric grid. Each cell stores the list of point indices that are present in that cell. To save memory, the grid is represented sparsely, using a dictionary, so that only cells with at least one vertex are defined. Initialize a hash grid with make_hash_grid(positions, size) . Use find_neighbors(grid, neighbors, position, max_radius) to find nearest neighbors. auto positions = vector < vec3f > {...}; // point positions auto grid = make_hash_grid ( positions , cell_size ); // create hash grid auto pt = vec3f {...}; auto max_dist = float {...}; // query point and dist auto neighbors = vector < int > {}; // neighbor buffer find_neighbors ( grid , neighbors , pt , max_dist ); // find neighbors by pos find_neighbors ( grid , neighbors , id , max_dist ); // find neighbors by id","title":"Nearest neighbors"},{"location":"yocto/yocto_shape/#element-conversions-and-grouping","text":"Yocto/Shape support conversion between shape elements. Use quads_to_triangles(quads) to convert quads to triangles and triangles_to_quads(triangles) to convert triangles to degenerate quads. Use bezier_to_lines(lines) to convert B\u00e9zier segments to lines using three lines for each B\u00e9zier segment. auto quads = vector < vec4i > {...}; auto triangles = quads_to_triangles ( quads ); // convert quads to triangles Face-varying meshes are stored by having different face indices for each vertex propeerty. This way, every vertex property has its own topology. Use split_facevarying(...) to convert to an indexed mesh. During conversion vertices may be duplicated since the same topology is used for all vertex properties. auto fvquadspos = vector < vec4i > {...}; // face-varying indices auto fvquadsnorm = vector < vec4i > {...}; // arrays have some length auto fvquadstexcoord = vector < vec4i > {...}; auto fvpositions = vector < vec3f > {...}; // face-varying vertices auto fvnormals = vector < vec3f > {...}; // arrays may have different lengths auto fvtexcoords = vector < vec2f > {...}; auto [ quads , positions , normals , texcoords ] = // convert to indexed mesh split_facevarying ( fvquadspos , fvquadsnorm , fvquadstexcoord , fvpositions , fvnormals , fvtexcoords ); Yocto/Shape supports eliminating duplicate vertices in triangle and quad meshes. All vertices within a threshold are merged in a greedy fashion, which works well when duplicated vertices are near other while other vertices are further away. Use weld_triangles(triangles, positions, threshold) to eliminate duplicated triangle vertices and weld_quads(quads, positions, threshold) to eliminate duplicated quad vertices. For lower-level algorithms, use weld_vertices(positions, threshold) to group vertices together. auto triangles = vector < vec3i > {...}; // mesh data auto positions = vector < vec3f > {...}; auto tolerance = 0.1f ; auto [ mtriangles , mpositions ] = // remove duplicates weld_triangles ( triangles , positions , tolerance ); Yocto/Shape supports splitting shapes that are tagged by ids. This is helpful for example when drawing meshes that have per-face materials using renders that do support one material per shape only. Use ungroup_lines(lines,ids) , ungroud_triangles(triangles,ids) and ungroup_quads(quads,ids) for lines, triangles and quads respectively. auto triangles = vector < vec3i > {...}; // tagged mesh with one id per face auto ids = vector < int > {...}; auto split = ungroup_triangles ( triangles , ids ); // returns list of meshes Yocto/Shape supports merging shape elements. This is useful, for example, when building up shapes from parts. The merged shapes are just concatenation of the individual shape without vertex merging. Use merge_lines(...) for lines, merge_triangles(...) for triangles and merge_quads(...) for quads. auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto mtriangles = vector < vec3i > {...}; // shape to be merged auto mpositions = vector < vec3f > {...}; auto mnormals = vector < vec3f > {...}; auto mtexcoords = vector < vec2f > {...}; // merge mtriangles into triangles in-placee merge_triangles ( triangles , positions , normals , texcoords , mtriangles , mpositions , mnormals , mtexcoords ); You can also merge triangles and quads together in other to have one primitive only. Use merge_triangles_and_quads(triangles, quads, force_triangles) to merge elements in-place. The algorithms will output quads if present or triangles if not unless force_triangles is used.","title":"Element conversions and grouping"},{"location":"yocto/yocto_shape/#shape-subdivision","text":"Yocto/Shape defines functions to subdivide shape elements linearly, in order to obtain higher shape resolution, for example before applying displacement mapping. All functions will split all shape elements, regardless of their size. This ensures that meshes have no cracks. Use subdivide_lines(lines, vert, level) for lines, subdivide_triangles(triangles, vert, level) for triangles, subdivide_quads(quads, vert, level) for quads, and subdivide_bezier(beziers, vert, level) for Bezier segments. In this subdivision, each line is split in two lines, each triangle in three triangles, each quad in four quads, and each Bezier segment in two segments. The functions apply the subdivision rules level number of times and act on a single vertex property at a time for maximum flexibility. auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; // subdivide the triangle mesh recursively two times auto [ striangles , spositions ] = subdivide_triangles ( triangles , positions , 2 ); Yocto/Shape also supports Catmull-Clark subdivision surfaces with subdivide_catmullclark(quads, vert, level, creased) . In this case, Catmull-Clark subdivision rules are used to smooth the mesh after linear subdivision. The boundary can be treated as creases with creased , which is necessary when subdividing texture coordinates. auto quads = vector < vec4i > {...}; // initial shape auto positions = vector < vec3f > {...}; // subdivide the quad mesh recursively two times auto [ squads , spositions ] = subdivide_catmullclark ( quads , positions , 2 , false ); auto tquads = vector < vec4i > {...}; // face-varying shape with texture coords auto texcoords = vector < vec2f > {...}; // subdivide the triangle mesh recursively two times auto [ stquads , stexcoords ] = subdivide_catmullclark ( tquads , texcoords , 2 , true );","title":"Shape subdivision"},{"location":"yocto/yocto_shape/#shape-sampling","text":"Yocto/Shape supports sampling meshes uniformly. All sampling require to first compute the shape CDF and then use it to sample the shape. For each shape type, the sampling functions return the shape element id and the element barycentric coordinates. Use sample_lines(cdf, re, rn) to sample lines, sample_triangles(cdf, re, rn) to sample triangles, sample_quads(cdf, re, rn) to sample quads. The shape CDFs are computed using sample_lines_dcf(lines, positions) , sample_triangles_dcf(triangles, positions) , and sample_quads_dcf(quads, positions) . auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; auto cdf = sample_triangles_cdf ( triangles , positions ); // shape cdf for ( auto sample : range ( samples )) { // sample the shape returning element id and uvs auto [ triangle_id , uv ] = sample_triangles ( cdf , rand1f ( rng ), rand2f ( rng )); } For triangles and quads, Yocto/Shape defines convenience functions that generate a set of points on the shape surface. Use sample_triangles(...) and sample_quads(...) for triangles and quads respectively. auto triangles = vector < vec3i > {...}; // initial shape auto positions = vector < vec3f > {...}; auto normals = vector < vec3f > {...}; auto texcoords = vector < vec2f > {...}; auto sampled_positions = vector < vec3f > {...}; // sampled points auto sampled_normals = vector < vec3f > {...}; auto sampled_texcoords = vector < vec2f > {...}; // sample a set of npoints on the mesh auto npoints = 100 ; sample_triangles ( sampled_positions , sampled_normals , sampled_texcoords , triangles , positions , normals , texcoords , npoints );","title":"Shape sampling"},{"location":"yocto/yocto_shape/#procedural-shapes","text":"Yocto/Shape defines several procedural shapes used for both testing and to quickly create shapes for procedural scenes. Procedural shapes take as input the desired shape resolution, the shape scale, the uv scale, and additional parameters specific to that procedural shape. These functions return quads indices and vertex positions, normals and texture coordinates, with arrays passed in. Use make_rect(...) for a rectangle in the XY plane, make_bulged_rect(...) for a bulged rectangle, make_recty(...) for a rectangle in the XZ plane, make_bulged_recty(...) for a bulged rectangle in the XZ plane, make_box(...) for a box, make_rounded_box(...) for a rounded box, make_floor(...) for a floor in the XZ plane, make_bent_floor(...) for a bent floor, make_sphere(...) for a sphere obtained from a cube, make_uvsphere(...) for a sphere tessellated along its uvs, make_capped_uvsphere(...) for a sphere with flipped caps, make_disk(...) for a disk obtained from a quad, make_bulged_disk(...) for a bulged disk, make_uvdisk(...) for a disk tessellated along its uvs, make_uvcylinder(...) for a cylinder tessellated along its uvs, make_rounded_uvcylinder(...) for a rounded cylinder. // most procedural shapes return quads, positions, normals, and texcoords auto quads = vector < vec4i > {}; auto positions = vector < vec3f > {}; auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; // make shapes with 32 steps in resolution and scale of 1 make_rect ( quads , positions , normals , texcoords , { 32 , 32 }, { 1 , 1 }); make_bulged_rect ( quads , positions , normals , texcoords , { 32 , 32 }, { 1 , 1 }); make_recty ( quads , positions , normals , texcoords , { 32 , 32 }, { 1 , 1 }); make_box ( quads , positions , normals , texcoords , { 32 , 32 , 32 }, { 1 , 1 , 1 }); make_rounded_box ( quads , positions , normals , texcoords , { 32 , 32 , 32 }, { 1 , 1 , 1 }); make_floor ( quads , positions , normals , texcoords , { 32 , 32 }, { 10 , 10 }); make_bent_floor ( quads , positions , normals , texcoords , { 32 , 32 }, { 10 , 10 }); make_sphere ( quads , positions , normals , texcoords , 32 , 1 ); make_uvsphere ( quads , positions , normals , texcoords , { 32 , 32 }, 1 ); make_capped_uvsphere ( quads , positions , normals , texcoords , { 32 , 32 }, 1 ); make_disk ( quads , positions , normals , texcoords , 32 , 1 ); make_bulged_disk ( quads , positions , normals , texcoords , 32 , 1 ); make_uvdiskm ( quads , positions , normals , texcoords , { 32 , 32 }, 1 ); make_uvcylinder ( quads , positions , normals , texcoords , { 32 , 32 , 32 }, { 1 , 1 }); make_rounded_uvcylinder ( quads , positions , normals , texcoords , { 32 , 32 , 32 }, { 1 , 1 }); Yocto/Shape defines a few procedural face-varying shapes with similar interfaces to the above functions. In this case, the functions return face indices and vertex data for positions, normals and texture coordinates packed in a quads_fvshape struct. Use make_fvrect(...) for a rectangle in the XY plane, make_fvbox(...) for a box, make_fvsphere(...) for a sphere obtained from a cube. // procedural face-varying shapes return positions, normals, and texcoords auto quadspos = vector < vec4i > {}; auto quadsnorm = vector < vec4i > {}; auto quadstexcoord = vector < vec4i > {}; auto positions = vector < vec3f > {}; auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; // make face-varying shapes with 32 steps in resolution and scale of 1 make_fvrect ( quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , { 32 , 32 }, { 1 , 1 }); make_fvbox ( quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , { 32 , 32 , 32 }, { 1 , 1 , 1 }); make_fvsphere ( quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , 32 , 1 ); Yocto/Shape provides functions to create predefined shapes helpful in testing. These functions take only a scale and often provide only the positions as vertex data. These functions return either triangles, quads, or face-varying quads. Use make_monkey(...) for the Blender monkey as quads and positions only, make_quad(...) for a simple quad, make_quady(...) for a simple quad in the XZ plane, make_cube(...) for a simple cube as quads and positions only, make_fvcube(...) for a simple face-varying unit cube, make_geosphere(...) for a geodesic sphere as triangles and positions only. // built-in shapes return elemeents, positions, normals, and texcoords auto quads = vector < vec4i > {}; auto triangles = vector < vec3i > {}; auto quadspos = vector < vec4i > {}; auto quadsnorm = vector < vec4i > {}; auto quadstexcoord = vector < vec4i > {}; auto positions = vector < vec3f > {}; auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; // make built-in shapes with scale of 1 make_monkey ( quads , positions , normals , texcoords , 1 ); make_quad ( quads , positions , normals , texcoords , 1 ); make_quady ( quads , positions , normals , texcoords , 1 ); make_cube ( quads , positions , normals , texcoords , 1 ); make_geosphere ( triangles , positions , normals , texcoords , 1 ); make_fvcube ( quadspos , quadsnorm , quadstexcoord , positions , normals , texcoords , 1 ); Yocto/Shape supports the generation of points and lines sets. Use make_lines(...) to create a line set in the XY plane, make_points(...) for a collection of points at the origin, adn make_random_points(...) for a point set randomly placed in a box. These functions return shapes that are defined in terms of lines or points and return lines or points indices, and vertex positions, normals, texture coordinates and radia, packed in a lines_shape or points_shape struct. // procedural lines return lines, positions, normals, texcoords, radia auto lines = vector < vec2i > {}; auto positions = vector < vec3f > {}; auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto radius = vector < float > {}; make_lines ( lines , positions , normals , texcoords , radius , { 4 , 65536 }, // line steps and number of lines { 1 , 1 }, { 1 , 1 }, // line set scale and uvscale { 0.001 , 0.001 }); // radius at the bottom and top // procedural points return points, positions, normals, texcoords, radia make_points ( points , positions , normals , texcoords , radius , 65536 , // number of points 1 , // uvscale 0.001 ); // point radius make_random_points ( points , positions , normals , texcoords , radius , 65536 , // number of points { 1 , 1 , 1 }, 1 , // line set scale and uvscale 0.001 ); // point radius Yocto/Shape also defines a simple function to generate randomized hairs on a triangle or quad mesh. Use make_hair(...) to create a hair shape from a triangle and quad mesh, and return a line set. // Make a hair ball around a shape auto lines = vector < vec2i > {}; auto positions = vector < vec3f > {}; auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto radius = vector < float > {}; make_hair ( lines , positions , normals , texcoords , radius , surface_triangles , surface_quads , // sampled surface surface_positions , surface_normals , surface_texcoords { 8 , 65536 }, // steps: line steps and number of lines { 0.1 , 0.1 }, // length: minimum and maximum length { 0.001 , 0.001 }, // radius: minimum and maximum radius from base to tip { 0 , 10 }, // noise: noise added to hair (strength/scale) { 0 , 128 }, // clump: clump added to hair (strength/number) { 0 , 0 }); // rotation: rotation added to hair (angle/strength) Finally, Yocto/Shape defines a function to create a quad mesh from a heighfield. Use make_heightfield(...) to create a heightfield meshes. auto quads = vector < vec4i > {}; // shape element buffer auto positions = vector < vec3f > {}; // vertex data buffers auto normals = vector < vec3f > {}; auto texcoords = vector < vec2f > {}; auto size = vec2i { 512 , 512 }; // heightfield size auto heightfield = vctor < float > {...}; // heightfield data make_heightfield ( quads , positions , normals , texcoords , size , heightfield ); // make heightfield mesh","title":"Procedural shapes"},{"location":"yocto/yocto_trace/","text":"Yocto/Trace: Path tracing Yocto/Trace is a simple path tracer written on the Yocto/Scene model. Yocto/Trace is implemented in yocto_trace.h and yocto_trace.cpp . Rendering features Yocto/Trace uses the Yocto/Scene model to represent scene data. Consult the scene documentation for a detailed description of the scene data model. Yocto/Trace implements a fast but simple path tracer. The algorithm uses relatively advanced sampling features to reduce the numbers of rays used to render an image. At the same time, we focus on general solutions that work well in all cases, instead of tuning the algorithm to work well in some specific cases. Yocto/Trace is a progressive path tracer that computes images a few samples at a time. This is true for both offline and online rendering. This design allows for partial images to be used to give feedback before the render is finished. Rendering a scene To render a scene, first tesselate shapes for subdivs and displacement, with tesselate_shapes(scene, params) , then call trace_image(scene, camera, params) , where params are the rendering options. auto scene = scene_model {...}; // initialize scene auto params = trace_params {}; // default params tesselate_shapes ( scene , params ); // tesselate shapes if needed trace_image ( scene , params ); // render image Rendering options The rendering process is configured with the trace_params settings. sampler determines the algorithm used for rendering: path is the default algorithm and probably the one you want to use, naive is a simpler path tracing that may be used for testing, eyelight produces quick previews of the screen geometry, falsecolor is a debug feature to view scenes according to the falsecolor setting. THe image resolution is set by resolution and measures the resolution of the longest axis. samples is the number of per-pixel samples used while rendering and is the only parameter used to control the tradeoff between noise and speed. bounces is the maximum number of bounces and should be high for scenes with glass and volumes, but otherwise a low number would suffice. The remaining parameters are approximation used to reduce noise, at the expenses of bias. clamp remove high-energy fireflies. nocaustics removes certain path that cause caustics. tentfilter apply a linear filter to the image pixels. envhidden removes the environment map from the camera rays. Finally, highqualitybvh congtrols the BVH quality and embreebvh controls whether to use Intel's Embree. Please see the description in Yocto/Bvh . trace_sampler_names , trace_falsecolor_names and trace_bvh_names define string names for various enum values that can used for UIs or CLIs. // high quality rendering auto hq_params = trace_params {}; // default params hq_params . sampler = trace_sampler_type :: path ; // path tracing hq_params . resolution = 1280 ; // high-res render hq_params . samples = 1024 ; // high-sample count hq_params . bounce = 64 ; // high max bounces // geometry previewing auto pp_params = trace_params {}; // default params pp_params . sampler = trace_sampler_type :: eyelight ; // geometry preview pp_params . resolution = 720 ; // medium-res render pp_params . samples = 16 ; // low-sample count // scene debug viewing auto db_params = trace_params {}; // default params db_params . sampler = trace_sampler_type :: falsecolor ; // debug false colors db_params . falsecolor = trace_falsecolor_type :: normal ; // normal viewing db_params . resolution = 720 ; // medium-res render db_params . samples = 16 ; // low-sample count Low-Level Rendering API Yocto/Trace supports a low-level rendering API that is more flexible for applications that need it. In this modality, you have to manage all state manually. Yocto/Trace internally uses a bvh_scene BVH for ray-scene intersection, a trace_lights objects to store lighting information, and a trace_state object to tracks the rendering process and contains all data needed to perform progressive computation. Each object need to be initialized separately. To render a scene, first tesselate shapes for subdivs and displacement, with tesselate_shapes(scene, params, progress) , then initialize the scene bvh and lights, with make_bvh(scene, params) and make_lights(scene, params) , then the rendering state with make_state(state, scene) . Then, for each sample, call trace_samples(state, scene, lights, params) and retrieve the computed image with get_render(state) or get_render(image, state) . This interface can be useful to provide user feedback by either saving or displaying partial images. auto scene = scene_model {...}; // initialize scene auto params = trace_params {}; // default params tesselate_shapes ( scene , params ); // tesselate shapes if needed auto bvh = make_bvh ( scene , params ); // init bvh auto lights = make_lights ( scene , params ); // init lights auto state = make_state ( scene , params ); // init state for ( auto sample : range ( params . samples )) { // for each sample trace_samples ( state , scene , camera , bvh , // render sample lights , params ); process_image ( get_render ( state )); // get image computed so far }; Denoising with Intel's Open Image Denoise We support denoising of rendered images in the low-level interface. Just call get_denoised(...) instead of get_render(...) to get a denoised image. Alternatively, you can call get_albedo(state) or get_normal(state) to get denoising buffers and either run the denoiser in a different process, or call denoise_render(render, albedo, normal) to denoise the image. To denoise within Yocto/GL, the library should be compiled with OIDN support by setting the YOCTO_DENOISE compile flag and linking to OIDN's libraries. auto scene = scene_model {...}; // initialize scene auto params = trace_params {}; // default params tesselate_shapes ( scene , params ); // tesselate shapes if needed auto bvh = make_bvh ( scene , params ); // init bvh auto lights = make_lights ( scene , params ); // init lights auto state = make_state ( scene , params ); // init state for ( auto sample : range ( params . samples )) { // for each sample trace_samples ( state , scene , camera , bvh , // render sample lights , params ); }; auto denoised = get_denoised ( state ); // get denoised final image // alternative interface auto render = get_render ( state ); // get final image auto albedo = get_albedo ( state ); // get denoising buffers auto normal = get_normal ( state ); // run denoiser here or save buffers and run elsewhere auto denoised2 = denoise_render ( render , albedo , normal );","title":"Path tracing"},{"location":"yocto/yocto_trace/#yoctotrace-path-tracing","text":"Yocto/Trace is a simple path tracer written on the Yocto/Scene model. Yocto/Trace is implemented in yocto_trace.h and yocto_trace.cpp .","title":"Yocto/Trace: Path tracing"},{"location":"yocto/yocto_trace/#rendering-features","text":"Yocto/Trace uses the Yocto/Scene model to represent scene data. Consult the scene documentation for a detailed description of the scene data model. Yocto/Trace implements a fast but simple path tracer. The algorithm uses relatively advanced sampling features to reduce the numbers of rays used to render an image. At the same time, we focus on general solutions that work well in all cases, instead of tuning the algorithm to work well in some specific cases. Yocto/Trace is a progressive path tracer that computes images a few samples at a time. This is true for both offline and online rendering. This design allows for partial images to be used to give feedback before the render is finished.","title":"Rendering features"},{"location":"yocto/yocto_trace/#rendering-a-scene","text":"To render a scene, first tesselate shapes for subdivs and displacement, with tesselate_shapes(scene, params) , then call trace_image(scene, camera, params) , where params are the rendering options. auto scene = scene_model {...}; // initialize scene auto params = trace_params {}; // default params tesselate_shapes ( scene , params ); // tesselate shapes if needed trace_image ( scene , params ); // render image","title":"Rendering a scene"},{"location":"yocto/yocto_trace/#rendering-options","text":"The rendering process is configured with the trace_params settings. sampler determines the algorithm used for rendering: path is the default algorithm and probably the one you want to use, naive is a simpler path tracing that may be used for testing, eyelight produces quick previews of the screen geometry, falsecolor is a debug feature to view scenes according to the falsecolor setting. THe image resolution is set by resolution and measures the resolution of the longest axis. samples is the number of per-pixel samples used while rendering and is the only parameter used to control the tradeoff between noise and speed. bounces is the maximum number of bounces and should be high for scenes with glass and volumes, but otherwise a low number would suffice. The remaining parameters are approximation used to reduce noise, at the expenses of bias. clamp remove high-energy fireflies. nocaustics removes certain path that cause caustics. tentfilter apply a linear filter to the image pixels. envhidden removes the environment map from the camera rays. Finally, highqualitybvh congtrols the BVH quality and embreebvh controls whether to use Intel's Embree. Please see the description in Yocto/Bvh . trace_sampler_names , trace_falsecolor_names and trace_bvh_names define string names for various enum values that can used for UIs or CLIs. // high quality rendering auto hq_params = trace_params {}; // default params hq_params . sampler = trace_sampler_type :: path ; // path tracing hq_params . resolution = 1280 ; // high-res render hq_params . samples = 1024 ; // high-sample count hq_params . bounce = 64 ; // high max bounces // geometry previewing auto pp_params = trace_params {}; // default params pp_params . sampler = trace_sampler_type :: eyelight ; // geometry preview pp_params . resolution = 720 ; // medium-res render pp_params . samples = 16 ; // low-sample count // scene debug viewing auto db_params = trace_params {}; // default params db_params . sampler = trace_sampler_type :: falsecolor ; // debug false colors db_params . falsecolor = trace_falsecolor_type :: normal ; // normal viewing db_params . resolution = 720 ; // medium-res render db_params . samples = 16 ; // low-sample count","title":"Rendering options"},{"location":"yocto/yocto_trace/#low-level-rendering-api","text":"Yocto/Trace supports a low-level rendering API that is more flexible for applications that need it. In this modality, you have to manage all state manually. Yocto/Trace internally uses a bvh_scene BVH for ray-scene intersection, a trace_lights objects to store lighting information, and a trace_state object to tracks the rendering process and contains all data needed to perform progressive computation. Each object need to be initialized separately. To render a scene, first tesselate shapes for subdivs and displacement, with tesselate_shapes(scene, params, progress) , then initialize the scene bvh and lights, with make_bvh(scene, params) and make_lights(scene, params) , then the rendering state with make_state(state, scene) . Then, for each sample, call trace_samples(state, scene, lights, params) and retrieve the computed image with get_render(state) or get_render(image, state) . This interface can be useful to provide user feedback by either saving or displaying partial images. auto scene = scene_model {...}; // initialize scene auto params = trace_params {}; // default params tesselate_shapes ( scene , params ); // tesselate shapes if needed auto bvh = make_bvh ( scene , params ); // init bvh auto lights = make_lights ( scene , params ); // init lights auto state = make_state ( scene , params ); // init state for ( auto sample : range ( params . samples )) { // for each sample trace_samples ( state , scene , camera , bvh , // render sample lights , params ); process_image ( get_render ( state )); // get image computed so far };","title":"Low-Level Rendering API"},{"location":"yocto/yocto_trace/#denoising-with-intels-open-image-denoise","text":"We support denoising of rendered images in the low-level interface. Just call get_denoised(...) instead of get_render(...) to get a denoised image. Alternatively, you can call get_albedo(state) or get_normal(state) to get denoising buffers and either run the denoiser in a different process, or call denoise_render(render, albedo, normal) to denoise the image. To denoise within Yocto/GL, the library should be compiled with OIDN support by setting the YOCTO_DENOISE compile flag and linking to OIDN's libraries. auto scene = scene_model {...}; // initialize scene auto params = trace_params {}; // default params tesselate_shapes ( scene , params ); // tesselate shapes if needed auto bvh = make_bvh ( scene , params ); // init bvh auto lights = make_lights ( scene , params ); // init lights auto state = make_state ( scene , params ); // init state for ( auto sample : range ( params . samples )) { // for each sample trace_samples ( state , scene , camera , bvh , // render sample lights , params ); }; auto denoised = get_denoised ( state ); // get denoised final image // alternative interface auto render = get_render ( state ); // get final image auto albedo = get_albedo ( state ); // get denoising buffers auto normal = get_normal ( state ); // run denoiser here or save buffers and run elsewhere auto denoised2 = denoise_render ( render , albedo , normal );","title":"Denoising with Intel's Open Image Denoise"}]}