
        <!DOCTYPE html>
        <html lang="en">
        <head>
          <title>Yocto/GL</title>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
          <link rel="stylesheet" href="style.css">
        </head>
        <body>
        <header>
            <nav>
                <img src="images/logo_white.png">
                <a href="">doc</a>
                <a href="https://github.com/xelatihy/yocto-gl">code</a>
            </nav>
        </header>
        <article>
        <h1>Yocto/glTF</h1>
<p>Khronos GLTF loader and writer for Khronos glTF format. Supports
all the glTF spec and the Khronos extensions. All parsing and writing code
is autogenerated form the schema.
Supports glTF version 2.0 and the following extensions: <code>KHR_binary_glTF</code>,
<code>KHR_specular_glossiness</code>.</p>
<p>This library depends in yocto_math.h, JSON loading/writing depends on
json.hpp. Texture loading/saving depends on yocto_image.h. If the texture
loading/saving dependency is not desired, it can be disabled by defining
YGLTF_NO_IMAGE before including this file.</p>
<p>The library provides two interfaces. A low-level interface is a direct
C++ translation of the glTF schemas and should be used if one wants
complete control over the fromat or an application wants to have their
own scene code added. We also provide a high-level interface that is more
useful if an aplication needs direct access to shapes, textures and
animations and does not want to deal with all the intricacies of the format.
In particular all glTF buffers are resolved and normalized to standard C++
types. The high-level interface supports easy access to animation, skinning
and morphingd data.</p>
<p>Known limitations of the high-level interface are: (1) skinning matrices
are always in world space (waiting for the spec to be updated); (2)
spline based animation is not implemented properly yet (waiting for
official demo models).</p>
<h2>Usage Of High-Level Interface</h2>
<ol>
<li>load a group of scens with <code>load_scenes()</code></li>
<li>look at the <code>scene</code> data structures for access to individual elements</li>
<li>to support animation, use <code>update_animated_transforms()</code></li>
<li>to support skinning, use <code>get_skin_transforms()</code></li>
<li>for morphing, use <code>compute_morphing_deformation()</code></li>
<li>can also manipulate the scene by adding missing data with <code>add_XXX()</code>
   functions</li>
<li>for rendering scenes, use <code>get_scene_cameras()</code> and
   <code>get_scene_instances()</code> that avoid the need for explicirtly walking
   the glTF node hierarchy</li>
<li>use <code>save_scenes()</code> ti write the data to disk</li>
</ol>
<h2>Usage Of Low-Level Interface</h2>
<ol>
<li>load a glTF data with <code>load_gltf()</code>; can load also buffer and image
   data</li>
<li>look at the <code>glTFXXX</code> data structures for access to individual elements</li>
<li>use glTF back to disk with <code>save_gltf()</code>; can also save binary blobs</li>
<li>conversion from low- to -high-level data structures with
   <code>scenes_to_gltf()</code> and <code>gltf_to_scenes()</code></li>
</ol>
<h2>Design Considerations</h2>
<p>glTF is a <em>very</em> complex file format and was designed mainly with untyped
languages in mind. YOCTO_GLTF attempts to match the glTF low-level interface
to C++ as best as it can. Since the code is generated from the schema, we
follow glTF naming conventions and typing quite well. To simplify adoption
and keep the API relatively simple we use std::vector as arrays and use
pointers to reference to all glTF objects. While this makes it less effcient
than it might have been, glTF heavy use of optional values makes this
necessary. At the same time, we do not keep track of set/unset values
for basic types (int, float, bool) as a compromise for efficieny.</p>
<p>In the low level interface, glTF uses integer indices to access objects.
While writing code ourselves we found that we add signiicant problems
since we would use an index to access the wriong type of scene objects.
For this reasons, we use an explit index <code>glTFid&lt;T&gt;</code> that can only access
an object of type T. Internally this is just the same old glTF index. But
this can used to access the scene data with <code>scene::get&lt;T&gt;(index)</code>.</p>
<h2>History</h2>
<ul>
<li>v 0.21: use reference interface for textures</li>
<li>v 0.20: removal of buggy shape splitting function</li>
<li>v 0.19: explicit paths for separate buffer saving</li>
<li>v 0.18: add function to split meshes into single shapes</li>
<li>v 0.17: add per-mesh buffer on write from scene</li>
<li>v 0.16: add transforms under function calls</li>
<li>v 0.15: remove exception from code and add explicit error handling</li>
<li>v 0.14: texture have always 4 channels</li>
<li>v 0.13: change variable names for compilation on gcc</li>
<li>v 0.12: removed explicit root nodes</li>
<li>v 0.11: added camera near/far to high-level interface</li>
<li>v 0.10: added moprhing to high-level interface</li>
<li>v 0.9: use yocto_math in the interface and remove inline compilation</li>
<li>v 0.8: API changes to match to GLTF 2</li>
<li>v 0.7: new codegen to match to GLTF 2 (changes imposed by changing spec)</li>
<li>v 0.6: switch to .h/.cpp pair</li>
<li>v 0.5: bug fixes and added checks for missing files</li>
<li>v 0.4: internally use pointers for performance transaprency</li>
<li>v 0.4: doxygen documentation</li>
<li>v 0.3: load/write interface with exceptions</li>
<li>v 0.2: doxygen comments</li>
<li>v 0.1: bug fix when writing names</li>
<li>v 0.0: initial release</li>
</ul>
<h2>Namespace ygltf</h2>
<p>Reading and writing glTF fileformat.</p>
<h3>Struct camera</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">camera</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">ortho</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">aspect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">yfov</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">atan</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">near</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">far</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">focus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">aperture</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Camera</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>ortho:      orthographic</li>
<li>aspect:      aspect ratio</li>
<li>yfov:      vertical fov (perspective) or size (orthographic)</li>
<li>near:      near plane (0 for default)</li>
<li>far:      far plane (0 for default)</li>
<li>focus:      focus distance (extension not implemented yet)</li>
<li>aperture:      lens aperture (extension not implemented yet)</li>
</ul>
</li>
</ul>
<h3>Struct texture</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">texture</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">image4b</span> <span class="n">ldr</span><span class="p">;</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">image4f</span> <span class="n">hdr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nf">width</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">height</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>Texture</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>path:      path</li>
<li>ldr:      8-bit data</li>
<li>hdr:      float data</li>
<li>width():      get texture width</li>
<li>height():      get texture height</li>
</ul>
</li>
</ul>
<h3>Enum texture_wrap</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">texture_wrap</span> <span class="p">{</span>
    <span class="n">repeat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">clamp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">mirror</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Texture wrap mode</p>
<ul>
<li>Values:<ul>
<li>repeat:      repeat</li>
<li>clamp:      clamp</li>
<li>mirror:      mirror</li>
</ul>
</li>
</ul>
<h3>Enum texture_filter</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">texture_filter</span> <span class="p">{</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">nearest</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">linear_mipmap_linear</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">nearest_mipmap_nearest</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">linear_mipmap_nearest</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">nearest_mipmap_linear</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Texture filter mode</p>
<ul>
<li>Values:<ul>
<li>linear:      linear</li>
<li>nearest:      nearest</li>
<li>linear_mipmap_linear:      linear mipmap linear</li>
<li>nearest_mipmap_nearest:      nearest mipmap nearest</li>
<li>linear_mipmap_nearest:      linear mipmap nearest</li>
<li>nearest_mipmap_linear:      nearest mipmap linear</li>
</ul>
</li>
</ul>
<h3>Struct texture_info</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">texture_info</span> <span class="p">{</span>
    <span class="n">texture_wrap</span> <span class="n">wrap_s</span> <span class="o">=</span> <span class="n">texture_wrap</span><span class="o">::</span><span class="n">repeat</span><span class="p">;</span>
    <span class="n">texture_wrap</span> <span class="n">wrap_t</span> <span class="o">=</span> <span class="n">texture_wrap</span><span class="o">::</span><span class="n">repeat</span><span class="p">;</span>
    <span class="n">texture_filter</span> <span class="n">filter_mag</span> <span class="o">=</span> <span class="n">texture_filter</span><span class="o">::</span><span class="n">linear</span><span class="p">;</span>
    <span class="n">texture_filter</span> <span class="n">filter_min</span> <span class="o">=</span> <span class="n">texture_filter</span><span class="o">::</span><span class="n">linear_mipmap_linear</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">is_default</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>Texture information</p>
<ul>
<li>Members:<ul>
<li>wrap_s:      wrap mode for s coordinate</li>
<li>wrap_t:      wrap mdoe for t coordinate</li>
<li>filter_mag:      filter mode</li>
<li>filter_min:      filter mode</li>
<li>scale:      texture strength (occlusion and normal)</li>
<li>is_default():      check if it is default</li>
</ul>
</li>
</ul>
<h3>Struct material_metallic_rooughness</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">material_metallic_rooughness</span> <span class="p">{</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span> <span class="n">base</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">opacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">metallic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">roughness</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">base_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">metallic_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">base_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">metallic_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">material_metallic_rooughness</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Material PBR metallic roughness</p>
<ul>
<li>Members:<ul>
<li>base:      base color</li>
<li>opacity:      opacity</li>
<li>metallic:      metallic factor</li>
<li>roughness:      metallic roughness</li>
<li>base_txt:      base texture (kb.x, kb.y, kb.z, op)</li>
<li>metallic_txt:      metallic-roughness texture (n/a, roughness, metallic, n/a)</li>
<li>base_txt_info:      texture information for base_txt</li>
<li>metallic_txt_info:      texture information for metallic_txt</li>
<li>~material_metallic_rooughness():      cleanup</li>
</ul>
</li>
</ul>
<h3>Struct material_specular_glossiness</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">material_specular_glossiness</span> <span class="p">{</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">opacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span> <span class="n">specular</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">glossiness</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">diffuse_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">specular_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">diffuse_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">specular_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">material_specular_glossiness</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Material PBR specular glossiness</p>
<ul>
<li>Members:<ul>
<li>diffuse:      diffuse color and opacity</li>
<li>opacity:      opacity</li>
<li>specular:      specular color (spec.x, spec.y, spec.z, opacity)</li>
<li>glossiness:      specular glossiness</li>
<li>diffuse_txt:      diffuse texture (diff.x, diff.y, diff.z, opacity)</li>
<li>specular_txt:      specular-glossiness texture (spec.x, spec.y, spec.z, gloss)</li>
<li>diffuse_txt_info:      texture information for base_txt</li>
<li>specular_txt_info:      texture information for metallic_txt</li>
<li>~material_specular_glossiness():      cleanup</li>
</ul>
</li>
</ul>
<h3>Struct material</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">material</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span> <span class="n">emission</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">emission_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">emission_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">material_metallic_rooughness</span><span class="o">*</span> <span class="n">metallic_roughness</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">material_specular_glossiness</span><span class="o">*</span> <span class="n">specular_glossiness</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">occlusion_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">normal_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">occlusion_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">normal_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">double_sided</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="o">~</span><span class="n">material</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Material</p>
<p>glTF 2.0 has two physically-based aterial models: pbrMetallicRoughness
and pbrSpecularGlossiness, the latter as an extension. Here we support both
by including which one is defined. While it would have been more appropriate
to convert them, this requires a rewrite of texture data which w prefer to
avoid.</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>emission:      emission color</li>
<li>emission_txt:      emissive texture reference</li>
<li>emission_txt_info:      texture information for normal_txt</li>
<li>metallic_roughness:      metallic roughnesss</li>
<li>specular_glossiness:      specular glossiness</li>
<li>occlusion_txt:      occlusion texture</li>
<li>normal_txt:      normal texture</li>
<li>occlusion_txt_info:      texture information for collusion_txt</li>
<li>normal_txt_info:      texture information for normal_txt</li>
<li>double_sided:      double sided</li>
<li>~material():      cleanup</li>
</ul>
</li>
</ul>
<h3>Struct shape_morph</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">shape_morph</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">norm</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">tangsp</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">weight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Morph information for shapes</p>
<ul>
<li>Members:<ul>
<li>pos:      morph position</li>
<li>norm:      morph normal</li>
<li>tangsp:      morph tangent</li>
<li>weight:      default weight (the same for each shape in a mesh)</li>
</ul>
</li>
</ul>
<h3>Struct shape</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">shape</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">material</span><span class="o">*</span> <span class="n">mat</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">norm</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">texcoord</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">texcoord1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">radius</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">tangsp</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">skin_weights</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="n">skin_joints</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec2i</span><span class="o">&gt;</span> <span class="n">lines</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec3i</span><span class="o">&gt;</span> <span class="n">triangles</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">shape_morph</span><span class="o">*&gt;</span> <span class="n">morph_targets</span><span class="p">;</span>
    <span class="o">~</span><span class="n">shape</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Primitives</p>
<ul>
<li>Members:<ul>
<li>name:      name of the mesh that enclosed it</li>
<li>mat:      material reference</li>
<li>pos:      vertex position</li>
<li>norm:      vertex normal</li>
<li>texcoord:      vertex texcoord</li>
<li>texcoord1:      vertex additional texcoord</li>
<li>color:      vertex color</li>
<li>radius:      vertex radius</li>
<li>tangsp:      vertex tangent space</li>
<li>skin_weights:      vertex skinning weights</li>
<li>skin_joints:      vertex skinning joint indices</li>
<li>points:      point elements</li>
<li>lines:      line elements</li>
<li>triangles:      triangle elements</li>
<li>morph_targets:      morph targets</li>
<li>~shape():      cleanup</li>
</ul>
</li>
</ul>
<h3>Struct mesh</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">mesh</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">shape</span><span class="o">*&gt;</span> <span class="n">shapes</span><span class="p">;</span>
    <span class="o">~</span><span class="n">mesh</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Gltf mesh.</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>path:      path (only used when writing files on disk with glTF)</li>
<li>shapes:      primitives references</li>
<li>~mesh():      cleanup</li>
</ul>
</li>
</ul>
<h3>Struct node</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">mesh</span><span class="o">*</span> <span class="n">msh</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">skin</span><span class="o">*</span> <span class="n">skn</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*&gt;</span> <span class="n">children</span><span class="p">;</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">mat4f</span> <span class="n">matrix</span> <span class="o">=</span> <span class="n">ym</span><span class="o">::</span><span class="n">identity_mat4f</span><span class="p">;</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">quat4f</span> <span class="n">rotation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span> <span class="n">scale</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span> <span class="n">translation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">morph_weights</span><span class="p">;</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">mat4f</span> <span class="n">xform</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">ym</span><span class="o">::</span><span class="n">mat4f</span> <span class="n">local_xform</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">ym</span><span class="o">::</span><span class="n">mat4f</span> <span class="n">skin_xform</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">ym</span><span class="o">::</span><span class="n">mat4f</span> <span class="n">_xform</span> <span class="o">=</span> <span class="n">ym</span><span class="o">::</span><span class="n">identity_mat4f</span><span class="p">;</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">mat4f</span> <span class="n">_local_xform</span> <span class="o">=</span> <span class="n">ym</span><span class="o">::</span><span class="n">identity_mat4f</span><span class="p">;</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">mat4f</span> <span class="n">_skin_xform</span> <span class="o">=</span> <span class="n">ym</span><span class="o">::</span><span class="n">identity_mat4f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Node in the hierarchy.</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>cam:      camera reference</li>
<li>msh:      mesh reference</li>
<li>skn:      mesh reference</li>
<li>children:      children</li>
<li>matrix:      A floating-point 4x4 transformation matrix stored in column-major order.</li>
<li>rotation:      The node's unit quaternion rotation in the order (x, y, z, w), where w
 is the scalar.</li>
<li>scale:      The node's non-uniform scale.</li>
<li>translation:      The node's translation.</li>
<li>morph_weights:      morph target weights</li>
<li>parent:      parent node (computed during update_node_hierarchy())</li>
<li>xform():      transform (computed during update_transforms())</li>
<li>local_xform():      local transform (computed during update_transforms())</li>
<li>skin_xform():      skin transform (computed during update_transforms())</li>
<li>_xform:      transform (computed during update_transforms())</li>
<li>_local_xform:      local transform (computed during update_transforms())</li>
<li>_skin_xform:      skin transform (computed during update_transforms())</li>
</ul>
</li>
</ul>
<h3>Enum animation_interpolation</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">animation_interpolation</span> <span class="p">{</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">catmull_rom</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">cubic</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Animation Interpolation</p>
<ul>
<li>Values:<ul>
<li>linear:      linear</li>
<li>step:      step function</li>
<li>catmull_rom:      catmull-rom spline</li>
<li>cubic:      cubic bezier spline</li>
</ul>
</li>
</ul>
<h3>Struct animation</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">animation</span> <span class="p">{</span>
    <span class="n">animation_interpolation</span> <span class="n">interp</span> <span class="o">=</span> <span class="n">animation_interpolation</span><span class="o">::</span><span class="n">step</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">time</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">translation</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">quat4f</span><span class="o">&gt;</span> <span class="n">rotation</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">scale</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&gt;</span> <span class="n">morph_weights</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Keyframe data.</p>
<ul>
<li>Members:<ul>
<li>interp:      Interpolation</li>
<li>nodes:      Target nodes</li>
<li>time:      Times</li>
<li>translation:      Translation</li>
<li>rotation:      Rotation</li>
<li>scale:      Scale</li>
<li>morph_weights:      Weights for morphing</li>
</ul>
</li>
</ul>
<h3>Struct animation_group</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">animation_group</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">animation</span><span class="o">*&gt;</span> <span class="n">animations</span><span class="p">;</span>
    <span class="o">~</span><span class="n">animation_group</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Animation</p>
<ul>
<li>Members:<ul>
<li>name:      Name</li>
<li>path:      path (only used when writing files on disk with glTF)</li>
<li>animations:      Times</li>
<li>~animation_group():      cleanup</li>
</ul>
</li>
</ul>
<h3>Struct skin</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">skin</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">mat4f</span><span class="o">&gt;</span> <span class="n">pose_matrices</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*&gt;</span> <span class="n">joints</span><span class="p">;</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Skin</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>path:      path (only used when writing files on disk with glTF)</li>
<li>pose_matrices:      inverse bind matrix</li>
<li>joints:      joints</li>
<li>root:      skeleton root node</li>
</ul>
</li>
</ul>
<h3>Struct scene</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">scene</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Gltf scene</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>nodes:      instances</li>
</ul>
</li>
</ul>
<h3>Struct scene_group</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">scene_group</span> <span class="p">{</span>
    <span class="n">scene</span><span class="o">*</span> <span class="n">default_scene</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">camera</span><span class="o">*&gt;</span> <span class="n">cameras</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">material</span><span class="o">*&gt;</span> <span class="n">materials</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">texture</span><span class="o">*&gt;</span> <span class="n">textures</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">mesh</span><span class="o">*&gt;</span> <span class="n">meshes</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">scene</span><span class="o">*&gt;</span> <span class="n">scenes</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">animation_group</span><span class="o">*&gt;</span> <span class="n">animations</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">skin</span><span class="o">*&gt;</span> <span class="n">skins</span><span class="p">;</span>
    <span class="o">~</span><span class="n">scene_group</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Gltf model. Objects are shared between scenes.
Scenes and nodes are missing for mesh-only assets.</p>
<ul>
<li>Members:<ul>
<li>default_scene:      default scene (null if not present)</li>
<li>cameras:      cameras</li>
<li>materials:      materials</li>
<li>textures:      textures</li>
<li>meshes:      meshes</li>
<li>scenes:      scenes</li>
<li>nodes:      nodes</li>
<li>animations:      nodes</li>
<li>skins:      skins</li>
<li>~scene_group():      cleanup</li>
</ul>
</li>
</ul>
<h3>Function load_scenes()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">scene_group</span><span class="o">*</span> <span class="nf">load_scenes</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">load_textures</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Load scene</p>
<ul>
<li>Parameters:<ul>
<li>filename: filename</li>
<li>load_textures: whether to load textures (default to false)</li>
<li>skip_missing: whether to skip missing buffers and textures</li>
<li>err: if set, store error message on error</li>
</ul>
</li>
<li>Returns:<ul>
<li>scene (nullptr on error)</li>
</ul>
</li>
</ul>
<h3>Function save_scenes()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_scenes</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">buffer_uri</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">save_textures</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">separate_buffers</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Save scene</p>
<ul>
<li>Parameters:<ul>
<li>filename: filename</li>
<li>buffer_uri: name of the main buffer</li>
<li>scn: scene data to save</li>
<li>save_textures: whether to save textures (default to false)</li>
<li>separate_buffers: save separate buffers for each mesh</li>
<li>err: if set, store error message on error</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether an error occurred</li>
</ul>
</li>
</ul>
<h3>Function update_node_hierarchy()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_node_hierarchy</span><span class="p">(</span><span class="n">scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Update node hierarchy</p>
<h3>Function update_transforms()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_transforms</span><span class="p">(</span><span class="n">scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Update node trasforms</p>
<h3>Function get_mesh_nodes()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*&gt;</span> <span class="n">get_mesh_nodes</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Get a list of nodes with meshes</p>
<h3>Function get_camera_nodes()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*&gt;</span> <span class="n">get_camera_nodes</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Get a list of nodes with cameras</p>
<h3>Function get_animation_bounds()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">ym</span><span class="o">::</span><span class="n">vec2f</span> <span class="n">get_animation_bounds</span><span class="p">(</span><span class="k">const</span> <span class="n">scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Animation times</p>
<h3>Function get_skin_transforms()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">mat4f</span><span class="o">&gt;</span> <span class="n">get_skin_transforms</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">skin</span><span class="o">*</span> <span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">xform</span><span class="p">);</span>
</code></pre></div>


<p>Skin transforms (local-to-object) from the node transform that instances the
skin</p>
<h3>Function compute_morphing_deformation()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">compute_morphing_deformation</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">weights</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ym</span><span class="o">::</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">tangsp</span><span class="p">);</span>
</code></pre></div>


<p>Compute shape morphing</p>
<h3>Function compute_scene_bounds()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">ym</span><span class="o">::</span><span class="n">bbox3f</span> <span class="n">compute_scene_bounds</span><span class="p">(</span><span class="k">const</span> <span class="n">scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Computes a scene bounding box</p>
<h3>Function add_normals()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_normals</span><span class="p">(</span><span class="n">scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h3>Function add_radius()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_radius</span><span class="p">(</span><span class="n">scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h3>Function add_tangent_space()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_tangent_space</span><span class="p">(</span><span class="n">scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h3>Function add_nodes()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_nodes</span><span class="p">(</span><span class="n">scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h3>Function add_scene()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_scene</span><span class="p">(</span><span class="n">scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h3>Function add_texture_data()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_texture_data</span><span class="p">(</span><span class="n">scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h3>Function add_names()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_names</span><span class="p">(</span><span class="n">scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h3>Function add_default_cameras()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_default_cameras</span><span class="p">(</span><span class="n">scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add a default camera that views the entire scene.</p>
<h3>Function add_unique_path_names()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_unique_path_names</span><span class="p">(</span><span class="n">scene_group</span><span class="o">*</span> <span class="n">scns</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">buffer_uri</span><span class="p">);</span>
</code></pre></div>


<p>Set unique path names for outputting separate buffers</p>
<h3>Typedef json</h3>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">json</span> <span class="o">=</span> <span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="p">;</span>
</code></pre></div>


<p>Json alias</p>
<h3>Typedef shader_data</h3>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">shader_data</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</code></pre></div>


<p>Shader data</p>
<h3>Typedef buffer_data</h3>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">buffer_data</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>Generic buffer data.</p>
<h3>Struct image_data</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">image_data</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">datab</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">dataf</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Generic image data.</p>
<ul>
<li>Members:<ul>
<li>width:      Width</li>
<li>height:      Height</li>
<li>ncomp:      Number of Channels</li>
<li>datab:      Buffer data for 8-bit images</li>
<li>dataf:      Buffer data for float images</li>
</ul>
</li>
</ul>
<h3>Typedef extension_t</h3>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">extension_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">json</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>Extensions</p>
<h3>Typedef extras_t</h3>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">extras_t</span> <span class="o">=</span> <span class="n">json</span><span class="p">;</span>
</code></pre></div>


<p>Extras</p>
<h3>Struct glTFid</h3>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">glTFid</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">glTFid</span><span class="p">();</span> 
    <span class="k">constexpr</span> <span class="k">explicit</span> <span class="nf">glTFid</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">);</span> 
    <span class="k">constexpr</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">bool</span> <span class="nf">is_valid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>glTFid</p>
<ul>
<li>Members:<ul>
<li>glTFid():      defaoult constructor to an invalid id</li>
<li>glTFid():      explicit conversion from integer</li>
<li>operator int():      explicit convcersion to integer</li>
<li>is_valid():      check if it is valid</li>
<li>operator bool():      check if it is valid</li>
</ul>
</li>
</ul>
<h3>Struct glTFProperty</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">extension_t</span> <span class="n">extensions</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">extras_t</span> <span class="n">extras</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>No documentation in schema.</p>
<ul>
<li>Members:<ul>
<li>extensions:      No documentation in schema.</li>
<li>extras:      No documentation in schema.</li>
</ul>
</li>
</ul>
<h3>Struct glTFChildOfRootProperty</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFChildOfRootProperty</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>No documentation in schema.</p>
<ul>
<li>Members:<ul>
<li>name:      The user-defined name of this object.</li>
</ul>
</li>
</ul>
<h3>Enum glTFAccessorSparseIndicesComponentType</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFAccessorSparseIndicesComponentType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">UnsignedByte</span> <span class="o">=</span> <span class="mi">5121</span><span class="p">,</span>
    <span class="n">UnsignedShort</span> <span class="o">=</span> <span class="mi">5123</span><span class="p">,</span>
    <span class="n">UnsignedInt</span> <span class="o">=</span> <span class="mi">5125</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Enum values for glTFAccessorSparseIndices::componentType.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>UnsignedByte:      UnsignedByte</li>
<li>UnsignedShort:      UnsignedShort</li>
<li>UnsignedInt:      UnsignedInt</li>
</ul>
</li>
</ul>
<h3>Struct glTFAccessorSparseIndices</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAccessorSparseIndices</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;</span> <span class="n">bufferView</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFAccessorSparseIndicesComponentType</span> <span class="n">componentType</span> <span class="o">=</span>
        <span class="n">glTFAccessorSparseIndicesComponentType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Indices of those attributes that deviate from their initialization
value.</p>
<ul>
<li>Members:<ul>
<li>bufferView:      The index of the bufferView with sparse indices. Referenced
 bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target.
 [required]</li>
<li>byteOffset:      The offset relative to the start of the bufferView in bytes. Must be
 aligned.</li>
<li>componentType:      The indices data type. [required]</li>
</ul>
</li>
</ul>
<h3>Struct glTFAccessorSparseValues</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAccessorSparseValues</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;</span> <span class="n">bufferView</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Array of size <code>accessor.sparse.count</code> times number of components storing
the displaced accessor attributes pointed by <code>accessor.sparse.indices</code>.</p>
<ul>
<li>Members:<ul>
<li>bufferView:      The index of the bufferView with sparse values. Referenced
 bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target.
 [required]</li>
<li>byteOffset:      The offset relative to the start of the bufferView in bytes. Must be
 aligned.</li>
</ul>
</li>
</ul>
<h3>Struct glTFAccessorSparse</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAccessorSparse</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFAccessorSparseIndices</span><span class="o">*</span> <span class="n">indices</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFAccessorSparseValues</span><span class="o">*</span> <span class="n">values</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFAccessorSparse</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Sparse storage of attributes that deviate from their initialization
value.</p>
<ul>
<li>Members:<ul>
<li>count:      Number of entries stored in the sparse array. [required]</li>
<li>indices:      Index array of size <code>count</code> that points to those accessor attributes
 that deviate from their initialization value. Indices must strictly
 increase. [required]</li>
<li>values:      Array of size <code>count</code> times number of components, storing the
 displaced accessor attributes pointed by <code>indices</code>. Substituted
 values must have the same <code>componentType</code> and number of components
 as the base accessor. [required]</li>
<li>~glTFAccessorSparse():      destructor</li>
</ul>
</li>
</ul>
<h3>Enum glTFAccessorComponentType</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFAccessorComponentType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">Byte</span> <span class="o">=</span> <span class="mi">5120</span><span class="p">,</span>
    <span class="n">UnsignedByte</span> <span class="o">=</span> <span class="mi">5121</span><span class="p">,</span>
    <span class="n">Short</span> <span class="o">=</span> <span class="mi">5122</span><span class="p">,</span>
    <span class="n">UnsignedShort</span> <span class="o">=</span> <span class="mi">5123</span><span class="p">,</span>
    <span class="n">UnsignedInt</span> <span class="o">=</span> <span class="mi">5125</span><span class="p">,</span>
    <span class="n">Float</span> <span class="o">=</span> <span class="mi">5126</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Enum values for glTFAccessor::componentType.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>Byte:      Byte</li>
<li>UnsignedByte:      UnsignedByte</li>
<li>Short:      Short</li>
<li>UnsignedShort:      UnsignedShort</li>
<li>UnsignedInt:      UnsignedInt</li>
<li>Float:      Float</li>
</ul>
</li>
</ul>
<h3>Enum glTFAccessorType</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFAccessorType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">Scalar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">Vec2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">Vec3</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">Vec4</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">Mat2</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">Mat3</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">Mat4</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFAccessor::type.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>Scalar:      Scalar</li>
<li>Vec2:      Vec2</li>
<li>Vec3:      Vec3</li>
<li>Vec4:      Vec4</li>
<li>Mat2:      Mat2</li>
<li>Mat3:      Mat3</li>
<li>Mat4:      Mat4</li>
</ul>
</li>
</ul>
<h3>Struct glTFAccessor</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAccessor</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;</span> <span class="n">bufferView</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFAccessorComponentType</span> <span class="n">componentType</span> <span class="o">=</span> <span class="n">glTFAccessorComponentType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">max</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">min</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">bool</span> <span class="n">normalized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">glTFAccessorSparse</span><span class="o">*</span> <span class="n">sparse</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFAccessorType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">glTFAccessorType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFAccessor</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A typed view into a bufferView.  A bufferView contains raw binary data.
An accessor provides a typed view into a bufferView or a subset of a
bufferView similar to how WebGL's <code>vertexAttribPointer()</code> defines an
attribute in a buffer.</p>
<ul>
<li>Members:<ul>
<li>bufferView:      The index of the bufferView.</li>
<li>byteOffset:      The offset relative to the start of the bufferView in bytes.</li>
<li>componentType:      The datatype of components in the attribute. [required]</li>
<li>count:      The number of attributes referenced by this accessor. [required]</li>
<li>max:      Maximum value of each component in this attribute.</li>
<li>min:      Minimum value of each component in this attribute.</li>
<li>normalized:      Specifies whether integer data values should be normalized.</li>
<li>sparse:      Sparse storage of attributes that deviate from their initialization
 value.</li>
<li>type:      Specifies if the attribute is a scalar, vector, or matrix.
 [required]</li>
<li>~glTFAccessor():      destructor</li>
</ul>
</li>
</ul>
<h3>Enum glTFAnimationChannelTargetPath</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFAnimationChannelTargetPath</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">Translation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">Rotation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">Scale</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">Weights</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFAnimationChannelTarget::path.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>Translation:      Translation</li>
<li>Rotation:      Rotation</li>
<li>Scale:      Scale</li>
<li>Weights:      Weights</li>
</ul>
</li>
</ul>
<h3>Struct glTFAnimationChannelTarget</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAnimationChannelTarget</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAnimationChannelTargetPath</span> <span class="n">path</span> <span class="o">=</span>
        <span class="n">glTFAnimationChannelTargetPath</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>The index of the node and TRS property that an animation channel
targets.</p>
<ul>
<li>Members:<ul>
<li>node:      The index of the node to target. [required]</li>
<li>path:      The name of the node's TRS property to modify, or the "weights" of
 the Morph Targets it instantiates. [required]</li>
</ul>
</li>
</ul>
<h3>Struct glTFAnimationChannel</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAnimationChannel</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAnimationSampler</span><span class="o">&gt;</span> <span class="n">sampler</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAnimationChannelTarget</span><span class="o">*</span> <span class="n">target</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFAnimationChannel</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Targets an animation's sampler at a node's property.</p>
<ul>
<li>Members:<ul>
<li>sampler:      The index of a sampler in this animation used to compute the value
 for the target. [required]</li>
<li>target:      The index of the node and TRS property to target. [required]</li>
<li>~glTFAnimationChannel():      destructor</li>
</ul>
</li>
</ul>
<h3>Enum glTFAnimationSamplerInterpolation</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFAnimationSamplerInterpolation</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">Linear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">Step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">Catmullromspline</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">Cubicspline</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFAnimationSampler::interpolation.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>Linear:      Linear</li>
<li>Step:      Step</li>
<li>Catmullromspline:      Catmullromspline</li>
<li>Cubicspline:      Cubicspline</li>
</ul>
</li>
</ul>
<h3>Struct glTFAnimationSampler</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAnimationSampler</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;</span> <span class="n">input</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAnimationSamplerInterpolation</span> <span class="n">interpolation</span> <span class="o">=</span>
        <span class="n">glTFAnimationSamplerInterpolation</span><span class="o">::</span><span class="n">Linear</span><span class="p">;</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Combines input and output accessors with an interpolation algorithm to
define a keyframe graph (but not its target).</p>
<ul>
<li>Members:<ul>
<li>input:      The index of an accessor containing keyframe input values, e.g.,
 time. [required]</li>
<li>interpolation:      Interpolation algorithm.</li>
<li>output:      The index of an accessor, containing keyframe output values.
 [required]</li>
</ul>
</li>
</ul>
<h3>Struct glTFAnimation</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAnimation</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFAnimationChannel</span><span class="o">*&gt;</span> <span class="n">channels</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFAnimationSampler</span><span class="o">*&gt;</span> <span class="n">samplers</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAnimationChannel</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAnimationChannel</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFAnimationSampler</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAnimationSampler</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="o">~</span><span class="n">glTFAnimation</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A keyframe animation.</p>
<ul>
<li>Members:<ul>
<li>channels:      An array of channels, each of which targets an animation's sampler
 at a node's property. Different channels of the same animation can't
 have equal targets. [required]</li>
<li>samplers:      An array of samplers that combines input and output accessors with
 an interpolation algorithm to define a keyframe graph (but not its
 target). [required]</li>
<li>get():      typed access for channels</li>
<li>get():      typed access for samplers</li>
<li>~glTFAnimation():      destructor</li>
</ul>
</li>
</ul>
<h3>Struct glTFAsset</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAsset</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">copyright</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">generator</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">minVersion</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">version</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Metadata about the glTF asset.</p>
<ul>
<li>Members:<ul>
<li>copyright:      A copyright message suitable for display to credit the content
 creator.</li>
<li>generator:      Tool that generated this glTF model.  Useful for debugging.</li>
<li>minVersion:      The minimum glTF version that this asset targets.</li>
<li>version:      The glTF version that this asset targets. [required]</li>
</ul>
</li>
</ul>
<h3>Struct glTFBuffer</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFBuffer</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">byteLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uri</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">buffer_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>A buffer points to binary geometry, animation, or skins.</p>
<ul>
<li>Members:<ul>
<li>byteLength:      The length of the buffer in bytes. [required]</li>
<li>uri:      The uri of the buffer.</li>
<li>data:      Buffer data if loaded.</li>
</ul>
</li>
</ul>
<h3>Enum glTFBufferViewTarget</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFBufferViewTarget</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">ArrayBuffer</span> <span class="o">=</span> <span class="mi">34962</span><span class="p">,</span>
    <span class="n">ElementArrayBuffer</span> <span class="o">=</span> <span class="mi">34963</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Enum values for glTFBufferView::target.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>ArrayBuffer:      ArrayBuffer</li>
<li>ElementArrayBuffer:      ElementArrayBuffer</li>
</ul>
</li>
</ul>
<h3>Struct glTFBufferView</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFBufferView</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBuffer</span><span class="o">&gt;</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">byteLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">byteStride</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFBufferViewTarget</span> <span class="n">target</span> <span class="o">=</span> <span class="n">glTFBufferViewTarget</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>A view into a buffer generally representing a subset of the buffer.</p>
<ul>
<li>Members:<ul>
<li>buffer:      The index of the buffer. [required]</li>
<li>byteLength:      The length of the bufferView in bytes. [required]</li>
<li>byteOffset:      The offset into the buffer in bytes.</li>
<li>byteStride:      The stride, in bytes.</li>
<li>target:      The target that the GPU buffer should be bound to.</li>
</ul>
</li>
</ul>
<h3>Struct glTFCameraOrthographic</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFCameraOrthographic</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">xmag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">ymag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">zfar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">znear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>An orthographic camera containing properties to create an orthographic
projection matrix.</p>
<ul>
<li>Members:<ul>
<li>xmag:      The floating-point horizontal magnification of the view. [required]</li>
<li>ymag:      The floating-point vertical magnification of the view. [required]</li>
<li>zfar:      The floating-point distance to the far clipping plane. <code>zfar</code> must
 be greater than <code>znear</code>. [required]</li>
<li>znear:      The floating-point distance to the near clipping plane. [required]</li>
</ul>
</li>
</ul>
<h3>Struct glTFCameraPerspective</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFCameraPerspective</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">aspectRatio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">yfov</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">zfar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">znear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>A perspective camera containing properties to create a perspective
projection matrix.</p>
<ul>
<li>Members:<ul>
<li>aspectRatio:      The floating-point aspect ratio of the field of view.</li>
<li>yfov:      The floating-point vertical field of view in radians. [required]</li>
<li>zfar:      The floating-point distance to the far clipping plane.</li>
<li>znear:      The floating-point distance to the near clipping plane. [required]</li>
</ul>
</li>
</ul>
<h3>Enum glTFCameraType</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFCameraType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">Perspective</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">Orthographic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFCamera::type.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>Perspective:      Perspective</li>
<li>Orthographic:      Orthographic</li>
</ul>
</li>
</ul>
<h3>Struct glTFCamera</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFCamera</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFCameraOrthographic</span><span class="o">*</span> <span class="n">orthographic</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFCameraPerspective</span><span class="o">*</span> <span class="n">perspective</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFCameraType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">glTFCameraType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFCamera</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A camera's projection.  A node can reference a camera to apply a
transform to place the camera in the scene.</p>
<ul>
<li>Members:<ul>
<li>orthographic:      An orthographic camera containing properties to create an
 orthographic projection matrix.</li>
<li>perspective:      A perspective camera containing properties to create a perspective
 projection matrix.</li>
<li>type:      Specifies if the camera uses a perspective or orthographic
 projection. [required]</li>
<li>~glTFCamera():      destructor</li>
</ul>
</li>
</ul>
<h3>Enum glTFImageMimeType</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFImageMimeType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">ImageJpeg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">ImagePng</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFImage::mimeType.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>ImageJpeg:      ImageJpeg</li>
<li>ImagePng:      ImagePng</li>
</ul>
</li>
</ul>
<h3>Struct glTFImage</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFImage</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;</span> <span class="n">bufferView</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFImageMimeType</span> <span class="n">mimeType</span> <span class="o">=</span> <span class="n">glTFImageMimeType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uri</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">image_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Image data used to create a texture. Image can be referenced by URI or
<code>bufferView</code> index. <code>mimeType</code> is required in the latter case.</p>
<ul>
<li>Members:<ul>
<li>bufferView:      The index of the bufferView that contains the image. Use this
 instead of the image's uri property.</li>
<li>mimeType:      The image's MIME type.</li>
<li>uri:      The uri of the image.</li>
<li>data:      Image data if loaded.</li>
</ul>
</li>
</ul>
<h3>Struct glTFTextureInfo</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFTextureInfo</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFTexture</span><span class="o">&gt;</span> <span class="n">index</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">texCoord</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Reference to a texture.</p>
<ul>
<li>Members:<ul>
<li>index:      The index of the texture. [required]</li>
<li>texCoord:      The set index of texture's TEXCOORD attribute used for texture
 coordinate mapping.</li>
</ul>
</li>
</ul>
<h3>Struct glTFTexture</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFTexture</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFSampler</span><span class="o">&gt;</span> <span class="n">sampler</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFImage</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>A texture and its sampler.</p>
<ul>
<li>Members:<ul>
<li>sampler:      The index of the sampler used by this texture. When undefined, a
 sampler with repeat wrapping and auto filtering should be used.</li>
<li>source:      The index of the image used by this texture.</li>
</ul>
</li>
</ul>
<h3>Struct glTFMaterialNormalTextureInfo</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterialNormalTextureInfo</span> <span class="p">:</span> <span class="n">glTFTextureInfo</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>No documentation in schema.</p>
<ul>
<li>Members:<ul>
<li>scale:      The scalar multiplier applied to each normal vector of the normal
 texture.</li>
</ul>
</li>
</ul>
<h3>Struct glTFMaterialOcclusionTextureInfo</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterialOcclusionTextureInfo</span> <span class="p">:</span> <span class="n">glTFTextureInfo</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">strength</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>No documentation in schema.</p>
<ul>
<li>Members:<ul>
<li>strength:      A scalar multiplier controlling the amount of occlusion applied.</li>
</ul>
</li>
</ul>
<h3>Struct glTFMaterialPbrMetallicRoughness</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterialPbrMetallicRoughness</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec4f</span> <span class="n">baseColorFactor</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">baseColorTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">metallicFactor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">metallicRoughnessTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">roughnessFactor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFMaterialPbrMetallicRoughness</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A set of parameter values that are used to define the metallic-roughness
material model from Physically-Based Rendering (PBR) methodology.</p>
<ul>
<li>Members:<ul>
<li>baseColorFactor:      The material's base color factor.</li>
<li>baseColorTexture:      The base color texture.</li>
<li>metallicFactor:      The metalness of the material.</li>
<li>metallicRoughnessTexture:      The metallic-roughness texture.</li>
<li>roughnessFactor:      The roughness of the material.</li>
<li>~glTFMaterialPbrMetallicRoughness():      destructor</li>
</ul>
</li>
</ul>
<h3>Struct glTFMaterialPbrSpecularGlossiness</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterialPbrSpecularGlossiness</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec4f</span> <span class="n">diffuseFactor</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">diffuseTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">glossinessFactor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span> <span class="n">specularFactor</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">specularGlossinessTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFMaterialPbrSpecularGlossiness</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>glTF extension that defines the specular-glossiness material model from
Physically-Based Rendering (PBR) methodology.</p>
<ul>
<li>Members:<ul>
<li>diffuseFactor:      The reflected diffuse factor of the material.</li>
<li>diffuseTexture:      The diffuse texture.</li>
<li>glossinessFactor:      The glossiness or smoothness of the material.</li>
<li>specularFactor:      The specular RGB color of the material.</li>
<li>specularGlossinessTexture:      The specular-glossiness texture.</li>
<li>~glTFMaterialPbrSpecularGlossiness():      destructor</li>
</ul>
</li>
</ul>
<h3>Enum glTFMaterialAlphaMode</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFMaterialAlphaMode</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">Opaque</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">Mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">Blend</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFMaterial::alphaMode.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>Opaque:      Opaque</li>
<li>Mask:      Mask</li>
<li>Blend:      Blend</li>
</ul>
</li>
</ul>
<h3>Struct glTFMaterial</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterial</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">alphaCutoff</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
    <span class="n">glTFMaterialAlphaMode</span> <span class="n">alphaMode</span> <span class="o">=</span> <span class="n">glTFMaterialAlphaMode</span><span class="o">::</span><span class="n">Opaque</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">doubleSided</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span> <span class="n">emissiveFactor</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">emissiveTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFMaterialNormalTextureInfo</span><span class="o">*</span> <span class="n">normalTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFMaterialOcclusionTextureInfo</span><span class="o">*</span> <span class="n">occlusionTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFMaterialPbrMetallicRoughness</span><span class="o">*</span> <span class="n">pbrMetallicRoughness</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFMaterialPbrSpecularGlossiness</span><span class="o">*</span> <span class="n">pbrSpecularGlossiness</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFMaterial</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>The material appearance of a primitive.</p>
<ul>
<li>Members:<ul>
<li>alphaCutoff:      The alpha cutoff value of the material.</li>
<li>alphaMode:      The alpha rendering mode of the material.</li>
<li>doubleSided:      Specifies whether the material is double sided.</li>
<li>emissiveFactor:      The emissive color of the material.</li>
<li>emissiveTexture:      The emissive map texture.</li>
<li>normalTexture:      The normal map texture.</li>
<li>occlusionTexture:      The occlusion map texture.</li>
<li>pbrMetallicRoughness:      A set of parameter values that are used to define the
 metallic-roughness material model from Physically-Based Rendering
 (PBR) methodology. When not specified, all the default values of
 <code>pbrMetallicRoughness</code> apply.</li>
<li>pbrSpecularGlossiness:      A set of parameter values that are used to define the
 specular-glossiness material model from Physically-Based Rendering
 (PBR) methodology. When not specified, all the default values of
 <code>pbrMetallicRoughness</code> apply.</li>
<li>~glTFMaterial():      destructor</li>
</ul>
</li>
</ul>
<h3>Enum glTFMeshPrimitiveMode</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFMeshPrimitiveMode</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">Points</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">Lines</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">LineLoop</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">LineStrip</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">Triangles</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">TriangleStrip</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">TriangleFan</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Enum values for glTFMeshPrimitive::mode.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>Points:      Points</li>
<li>Lines:      Lines</li>
<li>LineLoop:      LineLoop</li>
<li>LineStrip:      LineStrip</li>
<li>Triangles:      Triangles</li>
<li>TriangleStrip:      TriangleStrip</li>
<li>TriangleFan:      TriangleFan</li>
</ul>
</li>
</ul>
<h3>Struct glTFMeshPrimitive</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMeshPrimitive</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;&gt;</span> <span class="n">attributes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;</span> <span class="n">indices</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFMaterial</span><span class="o">&gt;</span> <span class="n">material</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFMeshPrimitiveMode</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">glTFMeshPrimitiveMode</span><span class="o">::</span><span class="n">Triangles</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;&gt;&gt;</span> <span class="n">targets</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Geometry to be rendered with the given material.</p>
<ul>
<li>Members:<ul>
<li>attributes:      A dictionary object, where each key corresponds to mesh attribute
 semantic and each value is the index of the accessor containing
 attribute's data. [required]</li>
<li>indices:      The index of the accessor that contains the indices.</li>
<li>material:      The index of the material to apply to this primitive when rendering.</li>
<li>mode:      The type of primitives to render.</li>
<li>targets:      An array of Morph Targets, each  Morph Target is a dictionary
 mapping attributes (only <code>POSITION</code>, <code>NORMAL</code>, and <code>TANGENT</code>
 supported) to their deviations in the Morph Target.</li>
</ul>
</li>
</ul>
<h3>Struct glTFMesh</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMesh</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFMeshPrimitive</span><span class="o">*&gt;</span> <span class="n">primitives</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="o">~</span><span class="n">glTFMesh</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A set of primitives to be rendered.  A node can contain one mesh.  A
node's transform places the mesh in the scene.</p>
<ul>
<li>Members:<ul>
<li>primitives:      An array of primitives, each defining geometry to be rendered with a
 material. [required]</li>
<li>weights:      Array of weights to be applied to the Morph Targets.</li>
<li>~glTFMesh():      destructor</li>
</ul>
</li>
</ul>
<h3>Struct glTFNode</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFNode</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFCamera</span><span class="o">&gt;</span> <span class="n">camera</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">mat4f</span> <span class="n">matrix</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFMesh</span><span class="o">&gt;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">quat4f</span> <span class="n">rotation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span> <span class="n">scale</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFSkin</span><span class="o">&gt;</span> <span class="n">skin</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span> <span class="n">translation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>A node in the node hierarchy.  When the node contains <code>skin</code>, all
<code>mesh.primitives</code> must contain <code>JOINTS_0</code> and <code>WEIGHTS_0</code> attributes.  A
node can have either a <code>matrix</code> or any combination of
<code>translation</code>/<code>rotation</code>/<code>scale</code> (TRS) properties. TRS properties are
converted to matrices and postmultiplied in the <code>T * R * S</code> order to
compose the transformation matrix; first the scale is applied to the
vertices, then the rotation, and then the translation. If none are
provided, the transform is the identity. When a node is targeted for
animation (referenced by an animation.channel.target), only TRS
properties may be present; <code>matrix</code> will not be present.</p>
<ul>
<li>Members:<ul>
<li>camera:      The index of the camera referenced by this node.</li>
<li>children:      The indices of this node's children.</li>
<li>matrix:      A floating-point 4x4 transformation matrix stored in column-major
 order.</li>
<li>mesh:      The index of the mesh in this node.</li>
<li>rotation:      The node's unit quaternion rotation in the order (x, y, z, w), where
 w is the scalar.</li>
<li>scale:      The node's non-uniform scale.</li>
<li>skin:      The index of the skin referenced by this node.</li>
<li>translation:      The node's translation.</li>
<li>weights:      The weights of the instantiated Morph Target. Number of elements
 must match number of Morph Targets of used mesh.</li>
</ul>
</li>
</ul>
<h3>Enum glTFSamplerMagFilter</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFSamplerMagFilter</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">Nearest</span> <span class="o">=</span> <span class="mi">9728</span><span class="p">,</span>
    <span class="n">Linear</span> <span class="o">=</span> <span class="mi">9729</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Enum values for glTFSampler::magFilter.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>Nearest:      Nearest</li>
<li>Linear:      Linear</li>
</ul>
</li>
</ul>
<h3>Enum glTFSamplerMinFilter</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFSamplerMinFilter</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">Nearest</span> <span class="o">=</span> <span class="mi">9728</span><span class="p">,</span>
    <span class="n">Linear</span> <span class="o">=</span> <span class="mi">9729</span><span class="p">,</span>
    <span class="n">NearestMipmapNearest</span> <span class="o">=</span> <span class="mi">9984</span><span class="p">,</span>
    <span class="n">LinearMipmapNearest</span> <span class="o">=</span> <span class="mi">9985</span><span class="p">,</span>
    <span class="n">NearestMipmapLinear</span> <span class="o">=</span> <span class="mi">9986</span><span class="p">,</span>
    <span class="n">LinearMipmapLinear</span> <span class="o">=</span> <span class="mi">9987</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Enum values for glTFSampler::minFilter.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>Nearest:      Nearest</li>
<li>Linear:      Linear</li>
<li>NearestMipmapNearest:      NearestMipmapNearest</li>
<li>LinearMipmapNearest:      LinearMipmapNearest</li>
<li>NearestMipmapLinear:      NearestMipmapLinear</li>
<li>LinearMipmapLinear:      LinearMipmapLinear</li>
</ul>
</li>
</ul>
<h3>Enum glTFSamplerWrapS</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFSamplerWrapS</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">ClampToEdge</span> <span class="o">=</span> <span class="mi">33071</span><span class="p">,</span>
    <span class="n">MirroredRepeat</span> <span class="o">=</span> <span class="mi">33648</span><span class="p">,</span>
    <span class="n">Repeat</span> <span class="o">=</span> <span class="mi">10497</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Enum values for glTFSampler::wrapS.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>ClampToEdge:      ClampToEdge</li>
<li>MirroredRepeat:      MirroredRepeat</li>
<li>Repeat:      Repeat</li>
</ul>
</li>
</ul>
<h3>Enum glTFSamplerWrapT</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">glTFSamplerWrapT</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">ClampToEdge</span> <span class="o">=</span> <span class="mi">33071</span><span class="p">,</span>
    <span class="n">MirroredRepeat</span> <span class="o">=</span> <span class="mi">33648</span><span class="p">,</span>
    <span class="n">Repeat</span> <span class="o">=</span> <span class="mi">10497</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Enum values for glTFSampler::wrapT.</p>
<ul>
<li>Values:<ul>
<li>NotSet:      not set</li>
<li>ClampToEdge:      ClampToEdge</li>
<li>MirroredRepeat:      MirroredRepeat</li>
<li>Repeat:      Repeat</li>
</ul>
</li>
</ul>
<h3>Struct glTFSampler</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFSampler</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFSamplerMagFilter</span> <span class="n">magFilter</span> <span class="o">=</span> <span class="n">glTFSamplerMagFilter</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="n">glTFSamplerMinFilter</span> <span class="n">minFilter</span> <span class="o">=</span> <span class="n">glTFSamplerMinFilter</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="n">glTFSamplerWrapS</span> <span class="n">wrapS</span> <span class="o">=</span> <span class="n">glTFSamplerWrapS</span><span class="o">::</span><span class="n">Repeat</span><span class="p">;</span>
    <span class="n">glTFSamplerWrapT</span> <span class="n">wrapT</span> <span class="o">=</span> <span class="n">glTFSamplerWrapT</span><span class="o">::</span><span class="n">Repeat</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Texture sampler properties for filtering and wrapping modes.</p>
<ul>
<li>Members:<ul>
<li>magFilter:      Magnification filter.</li>
<li>minFilter:      Minification filter.</li>
<li>wrapS:      s wrapping mode.</li>
<li>wrapT:      t wrapping mode.</li>
</ul>
</li>
</ul>
<h3>Struct glTFScene</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFScene</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>The root nodes of a scene.</p>
<ul>
<li>Members:<ul>
<li>nodes:      The indices of each root node.</li>
</ul>
</li>
</ul>
<h3>Struct glTFSkin</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFSkin</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;</span> <span class="n">inverseBindMatrices</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;&gt;</span> <span class="n">joints</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;</span> <span class="n">skeleton</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Joints and matrices defining a skin.</p>
<ul>
<li>Members:<ul>
<li>inverseBindMatrices:      The index of the accessor containing the floating-point 4x4
 inverse-bind matrices.  The default is that each matrix is a 4x4
 identity matrix, which implies that inverse-bind matrices were
 pre-applied.</li>
<li>joints:      Indices of skeleton nodes, used as joints in this skin. [required]</li>
<li>skeleton:      The index of the node used as a skeleton root. When undefined,
 joints transforms resolve to scene root.</li>
</ul>
</li>
</ul>
<h3>Struct glTF</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTF</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">*&gt;</span> <span class="n">accessors</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFAnimation</span><span class="o">*&gt;</span> <span class="n">animations</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAsset</span><span class="o">*</span> <span class="n">asset</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">*&gt;</span> <span class="n">bufferViews</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFBuffer</span><span class="o">*&gt;</span> <span class="n">buffers</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFCamera</span><span class="o">*&gt;</span> <span class="n">cameras</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">extensionsRequired</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">extensionsUsed</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFImage</span><span class="o">*&gt;</span> <span class="n">images</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFMaterial</span><span class="o">*&gt;</span> <span class="n">materials</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFMesh</span><span class="o">*&gt;</span> <span class="n">meshes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">*&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFSampler</span><span class="o">*&gt;</span> <span class="n">samplers</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFScene</span><span class="o">&gt;</span> <span class="n">scene</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFScene</span><span class="o">*&gt;</span> <span class="n">scenes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFSkin</span><span class="o">*&gt;</span> <span class="n">skins</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFTexture</span><span class="o">*&gt;</span> <span class="n">textures</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAccessor</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFAnimation</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAnimation</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFBufferView</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFBuffer</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBuffer</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFCamera</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFCamera</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFImage</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFImage</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFMaterial</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFMaterial</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFMesh</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFMesh</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFNode</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFSampler</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFSampler</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFScene</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFScene</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFSkin</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFSkin</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFTexture</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFTexture</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="o">~</span><span class="n">glTF</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>The root object for a glTF asset.</p>
<ul>
<li>Members:<ul>
<li>accessors:      An array of accessors.</li>
<li>animations:      An array of keyframe animations.</li>
<li>asset:      Metadata about the glTF asset. [required]</li>
<li>bufferViews:      An array of bufferViews.</li>
<li>buffers:      An array of buffers.</li>
<li>cameras:      An array of cameras.</li>
<li>extensionsRequired:      Names of glTF extensions required to properly load this asset.</li>
<li>extensionsUsed:      Names of glTF extensions used somewhere in this asset.</li>
<li>images:      An array of images.</li>
<li>materials:      An array of materials.</li>
<li>meshes:      An array of meshes.</li>
<li>nodes:      An array of nodes.</li>
<li>samplers:      An array of samplers.</li>
<li>scene:      The index of the default scene.</li>
<li>scenes:      An array of scenes.</li>
<li>skins:      An array of skins.</li>
<li>textures:      An array of textures.</li>
<li>get():      typed access for accessors</li>
<li>get():      typed access for animations</li>
<li>get():      typed access for bufferViews</li>
<li>get():      typed access for buffers</li>
<li>get():      typed access for cameras</li>
<li>get():      typed access for images</li>
<li>get():      typed access for materials</li>
<li>get():      typed access for meshes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for samplers</li>
<li>get():      typed access for scenes</li>
<li>get():      typed access for skins</li>
<li>get():      typed access for textures</li>
<li>~glTF():      destructor</li>
</ul>
</li>
</ul>
<h3>Function load_gltf()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">glTF</span><span class="o">*</span> <span class="nf">load_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">load_bin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">load_img</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Loads a gltf file from disk</p>
<ul>
<li>Parameters:<ul>
<li>filename: scene filename</li>
<li>load_bin/load_img: load binary data</li>
<li>skip_missing: do not throw an exception if a file is missing</li>
<li>err: if set, store error message on error</li>
</ul>
</li>
<li>Returns:<ul>
<li>gltf data loaded (nullptr on error)</li>
</ul>
</li>
</ul>
<h3>Function load_binary_gltf()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">glTF</span><span class="o">*</span> <span class="nf">load_binary_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">load_bin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">load_img</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Loads a binary gltf file from disk</p>
<ul>
<li>Parameters:<ul>
<li>filename: scene filename</li>
<li>other params as above</li>
<li>err: if set, store error message on error</li>
</ul>
</li>
<li>Returns:<ul>
<li>gltf data loaded (nullptr on error)</li>
</ul>
</li>
</ul>
<h3>Function save_gltf()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">save_bin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">save_images</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Saves a scene to disk</p>
<ul>
<li>Parameters:<ul>
<li>filename: scene filename</li>
<li>gltf: data to save</li>
<li>save_bin/save_images: save binary data</li>
<li>err: if set, store error message on error</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether an error occurred</li>
</ul>
</li>
</ul>
<h3>Function save_binary_gltf()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_binary_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">save_bin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">save_images</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Saves a scene to disk</p>
<ul>
<li>Parameters:<ul>
<li>filename: scene filename</li>
<li>gltf: data to save</li>
<li>save_bin/save_images: save binary data</li>
<li>err: if set, store error message on error</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether an error occurred</li>
</ul>
</li>
</ul>
<h3>Function load_buffers()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">load_buffers</span><span class="p">(</span><span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">dirname</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Load buffer data.</p>
<ul>
<li>Parameters:<ul>
<li>dirname: directory used to resolve path references</li>
<li>skip_missing: do not throw an exception if a file is missing</li>
<li>err: if set, store error message on error</li>
</ul>
</li>
<li>Out Parameters:<ul>
<li>gltf: data to data</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether an error occurred</li>
</ul>
</li>
</ul>
<h3>Function load_images()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">load_images</span><span class="p">(</span><span class="n">glTF</span><span class="o">*</span> <span class="n">asset</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">dirname</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Loads images.</p>
<ul>
<li>Parameters:<ul>
<li>dirname: directory used to resolve path references</li>
<li>skip_missing: do not throw an exception if a file is missing</li>
<li>err: if set, store error message on error</li>
</ul>
</li>
<li>Out Parameters:<ul>
<li>gltf: data to data</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether an error occurred</li>
</ul>
</li>
</ul>
<h3>Function save_buffers()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_buffers</span><span class="p">(</span><span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">dirname</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">skip_missing</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Save buffer data.</p>
<ul>
<li>Parameters:<ul>
<li>dirname: directory used to resolve path references</li>
<li>gltf: data to save</li>
<li>skip_missing: do not throw an exception if a file is missing</li>
<li>err: if set, store error message on error</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether an error occurred</li>
</ul>
</li>
</ul>
<h3>Function save_images()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_images</span><span class="p">(</span><span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">asset</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">dirname</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">skip_missing</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Saves images.</p>
<ul>
<li>Parameters:<ul>
<li>dirname: directory used to resolve path references</li>
<li>gltf: data to save</li>
<li>skip_missing: do not throw an exception if a file is missing</li>
<li>err: if set, store error message on error</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether an error occurred</li>
</ul>
</li>
</ul>
<h3>Function gltf_to_scenes()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">scene_group</span><span class="o">*</span> <span class="nf">gltf_to_scenes</span><span class="p">(</span><span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scene_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Convert a gltf asset to flattened group of scene.</p>
<h3>Function scenes_to_gltf()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">glTF</span><span class="o">*</span> <span class="nf">scenes_to_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">scene_group</span><span class="o">*</span> <span class="n">fl_gltf</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">buffer_uri</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">separate_buffers</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Convert a flattened group of scene into a gltf. If separate_buffers,
creates a separate buffer for each each and animation and
prepend buffer_uri to its name.</p>
<h3>Function validate_gltf()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">validate_gltf</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">);</span>
</code></pre></div>


<p>Validate a gltf. Missing many validation as of this version.</p>
<h3>Function node_transform()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">ym</span><span class="o">::</span><span class="n">mat4f</span> <span class="n">node_transform</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
</code></pre></div>


<p>Computes the local node transform and its inverse.</p>
<h3>Struct accessor_view</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">accessor_view</span> <span class="p">{</span>
    <span class="n">accessor_view</span><span class="p">(</span><span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">,</span> <span class="k">const</span> <span class="n">glTFAccessor</span><span class="o">*</span> <span class="n">accessor</span><span class="p">);</span> 
    <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">count</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">ncomp</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">bool</span> <span class="nf">valid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">getv</span><span class="p">(</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">def</span> <span class="o">=</span> <span class="n">ym</span><span class="o">::</span><span class="n">zero_vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">())</span> <span class="k">const</span><span class="p">;</span> 
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">M</span><span class="o">&gt;</span> <span class="n">ym</span><span class="o">::</span><span class="n">mat</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="n">getm</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">float</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">getiv</span><span class="p">(</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">def</span> <span class="o">=</span> <span class="n">ym</span><span class="o">::</span><span class="n">zero_vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">())</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">geti</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>A view for gltf array buffers that allows for typed access.</p>
<ul>
<li>Members:<ul>
<li>accessor_view():      construct a view from an accessor</li>
<li>size():      number of elements in the view</li>
<li>count():      number of elements in the view</li>
<li>ncomp():      number of components per element</li>
<li>valid():      check whether the view is valid</li>
<li>getv():      get the idx-th element of fixes length</li>
<li>getm():      get the idx-th element of fixes length as a matrix</li>
<li>get():      get the c-th component of the idx-th element</li>
<li>getiv():      get the idx-th element as integer</li>
<li>geti():      get the c-th component of the idx-th element as integer</li>
</ul>
</li>
</ul>
        <article>
        <footer></footer>
        </body>
        </html>
    