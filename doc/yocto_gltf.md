# Yocto/glTF

Khronos GLTF loader and writer for Khronos glTF format. Supports
all the glTF spec and the Khronos extensions. All parsing and writing code
is autogenerated form the schema.
Supports glTF version 2.0 and the following extensions: `KHR_binary_glTF`,
`KHR_specular_glossiness`.

This library depends in yocto_math.h, JSON loading/writing depends on
json.hpp. Texture loading/saving depends on yocto_image.h. If the texture
loading/saving dependency is not desired, it can be disabled by defining
YGLTF_NO_IMAGE before including this file.

The library provides two interfaces. A low-level interface is a direct
C++ translation of the glTF schemas and should be used if one wants
complete control over the fromat or an application wants to have their
own scene code added. We also provide a high-level interface that is more
useful if an aplication needs direct access to shapes, textures and
animations and does not want to deal with all the intricacies of the format.
In particular all glTF buffers are resolved and normalized to standard C++
types. The high-level interface supports easy access to animation, skinning
and morphingd data.

Known limitations of the high-level interface are: (1) skinning matrices
are always in world space (waiting for the spec to be updated); (2)
spline based animation is not implemented properly yet (waiting for
official demo models).

## Usage Of High-Level Interface

1. load a group of scens with `load_scenes()`
2. look at the `scene` data structures for access to individual elements
3. to support animation, use `update_animated_transforms()`
4. to support skinning, use `get_skin_transforms()`
5. for morphing, use `compute_morphing_deformation()`
6. can also manipulate the scene by adding missing data with `add_XXX()`
   functions
7. for rendering scenes, use `get_scene_cameras()` and
   `get_scene_instances()` that avoid the need for explicirtly walking
   the glTF node hierarchy
7. use `save_scenes()` ti write the data to disk

## Usage Of Low-Level Interface

1. load a glTF data with `load_gltf()`; can load also buffer and image
   data
2. look at the `glTFXXX` data structures for access to individual elements
3. use glTF back to disk with `save_gltf()`; can also save binary blobs
4. conversion from low- to -high-level data structures with
   `scenes_to_gltf()` and `gltf_to_scenes()`


## Design Considerations

glTF is a *very* complex file format and was designed mainly with untyped
languages in mind. YOCTO_GLTF attempts to match the glTF low-level interface
to C++ as best as it can. Since the code is generated from the schema, we
follow glTF naming conventions and typing quite well. To simplify adoption
and keep the API relatively simple we use std::vector as arrays and use
pointers to reference to all glTF objects. While this makes it less effcient
than it might have been, glTF heavy use of optional values makes this
necessary. At the same time, we do not keep track of set/unset values
for basic types (int, float, bool) as a compromise for efficieny.

In the low level interface, glTF uses integer indices to access objects.
While writing code ourselves we found that we add signiicant problems
since we would use an index to access the wriong type of scene objects.
For this reasons, we use an explit index `glTFid<T>` that can only access
an object of type T. Internally this is just the same old glTF index. But
this can used to access the scene data with `scene::get<T>(index)`.


## History

- v 0.17: add per-mesh buffer on write from scene
- v 0.16: add transforms under function calls
- v 0.15: remove exception from code and add explicit error handling
- v 0.14: texture have always 4 channels
- v 0.13: change variable names for compilation on gcc
- v 0.12: removed explicit root nodes
- v 0.11: added camera near/far to high-level interface
- v 0.10: added moprhing to high-level interface
- v 0.9: use yocto_math in the interface and remove inline compilation
- v 0.8: API changes to match to GLTF 2
- v 0.7: new codegen to match to GLTF 2 (changes imposed by changing spec)
- v 0.6: switch to .h/.cpp pair
- v 0.5: bug fixes and added checks for missing files
- v 0.4: internally use pointers for performance transaprency
- v 0.4: doxygen documentation
- v 0.3: load/write interface with exceptions
- v 0.2: doxygen comments
- v 0.1: bug fix when writing names
- v 0.0: initial release

## Namespace ygltf

Reading and writing glTF fileformat.

### Struct camera

~~~ .cpp
struct camera {
    std::string name = "";
    bool ortho = false;
    float aspect = 1;
    float yfov = 2 * std::atan(0.5f);
    float near = 0;
    float far = 0;
    float focus = 1;
    float aperture = 0;
}
~~~

Camera

- Members:
    - name:      name
    - ortho:      orthographic
    - aspect:      aspect ratio
    - yfov:      vertical fov (perspective) or size (orthographic)
    - near:      near plane (0 for default)
    - far:      far plane (0 for default)
    - focus:      focus distance (extension not implemented yet)
    - aperture:      lens aperture (extension not implemented yet)


### Struct texture

~~~ .cpp
struct texture {
    std::string name = "";
    std::string path = "";
    ym::image4b* ldr = nullptr;
    ym::image4f* hdr = nullptr;
    int width() const; 
    int height() const; 
    ~texture(); 
}
~~~

Texture

- Members:
    - name:      name
    - path:      path
    - ldr:      8-bit data
    - hdr:      float data
    - width():      get texture width
    - height():      get texture height
    - ~texture():      cleanup


### Enum texture_wrap

~~~ .cpp
enum struct texture_wrap {
    repeat = 1,
    clamp = 2,
    mirror = 3,
}
~~~

Texture wrap mode

- Values:
    - repeat:      repeat
    - clamp:      clamp
    - mirror:      mirror


### Enum texture_filter

~~~ .cpp
enum struct texture_filter {
    linear = 1,
    nearest = 2,
    linear_mipmap_linear = 3,
    nearest_mipmap_nearest = 4,
    linear_mipmap_nearest = 5,
    nearest_mipmap_linear = 6,
}
~~~

Texture filter mode

- Values:
    - linear:      linear
    - nearest:      nearest
    - linear_mipmap_linear:      linear mipmap linear
    - nearest_mipmap_nearest:      nearest mipmap nearest
    - linear_mipmap_nearest:      linear mipmap nearest
    - nearest_mipmap_linear:      nearest mipmap linear


### Struct texture_info

~~~ .cpp
struct texture_info {
    texture_wrap wrap_s = texture_wrap::repeat;
    texture_wrap wrap_t = texture_wrap::repeat;
    texture_filter filter_mag = texture_filter::linear;
    texture_filter filter_min = texture_filter::linear_mipmap_linear;
    float scale = 1;
    bool is_default() const; 
}
~~~

Texture information

- Members:
    - wrap_s:      wrap mode for s coordinate
    - wrap_t:      wrap mdoe for t coordinate
    - filter_mag:      filter mode
    - filter_min:      filter mode
    - scale:      texture strength (occlusion and normal)
    - is_default():      check if it is default


### Struct material_metallic_rooughness

~~~ .cpp
struct material_metallic_rooughness {
    ym::vec3f base = {0, 0, 0};
    float opacity = 1;
    float metallic = 0;
    float roughness = 0;
    texture* base_txt = nullptr;
    texture* metallic_txt = nullptr;
    texture_info* base_txt_info = nullptr;
    texture_info* metallic_txt_info = nullptr;
    ~material_metallic_rooughness(); 
}
~~~

Material PBR metallic roughness

- Members:
    - base:      base color
    - opacity:      opacity
    - metallic:      metallic factor
    - roughness:      metallic roughness
    - base_txt:      base texture (kb.x, kb.y, kb.z, op)
    - metallic_txt:      metallic-roughness texture (n/a, roughness, metallic, n/a)
    - base_txt_info:      texture information for base_txt
    - metallic_txt_info:      texture information for metallic_txt
    - ~material_metallic_rooughness():      cleanup


### Struct material_specular_glossiness

~~~ .cpp
struct material_specular_glossiness {
    ym::vec3f diffuse = {0, 0, 0};
    float opacity = 1;
    ym::vec3f specular = {0, 0, 0};
    float glossiness = 1;
    texture* diffuse_txt = nullptr;
    texture* specular_txt = nullptr;
    texture_info* diffuse_txt_info = nullptr;
    texture_info* specular_txt_info = nullptr;
    ~material_specular_glossiness(); 
}
~~~

Material PBR specular glossiness

- Members:
    - diffuse:      diffuse color and opacity
    - opacity:      opacity
    - specular:      specular color (spec.x, spec.y, spec.z, opacity)
    - glossiness:      specular glossiness
    - diffuse_txt:      diffuse texture (diff.x, diff.y, diff.z, opacity)
    - specular_txt:      specular-glossiness texture (spec.x, spec.y, spec.z, gloss)
    - diffuse_txt_info:      texture information for base_txt
    - specular_txt_info:      texture information for metallic_txt
    - ~material_specular_glossiness():      cleanup


### Struct material

~~~ .cpp
struct material {
    std::string name = "";
    ym::vec3f emission = {0, 0, 0};
    texture* emission_txt = nullptr;
    texture_info* emission_txt_info = nullptr;
    material_metallic_rooughness* metallic_roughness = nullptr;
    material_specular_glossiness* specular_glossiness = nullptr;
    texture* occlusion_txt = nullptr;
    texture* normal_txt = nullptr;
    texture_info* occlusion_txt_info = nullptr;
    texture_info* normal_txt_info = nullptr;
    bool double_sided = true;
    ~material(); 
}
~~~

Material

glTF 2.0 has two physically-based aterial models: pbrMetallicRoughness
and pbrSpecularGlossiness, the latter as an extension. Here we support both
by including which one is defined. While it would have been more appropriate
to convert them, this requires a rewrite of texture data which w prefer to
avoid.

- Members:
    - name:      name
    - emission:      emission color
    - emission_txt:      emissive texture reference
    - emission_txt_info:      texture information for normal_txt
    - metallic_roughness:      metallic roughnesss
    - specular_glossiness:      specular glossiness
    - occlusion_txt:      occlusion texture
    - normal_txt:      normal texture
    - occlusion_txt_info:      texture information for collusion_txt
    - normal_txt_info:      texture information for normal_txt
    - double_sided:      double sided
    - ~material():      cleanup


### Struct shape_morph

~~~ .cpp
struct shape_morph {
    std::vector<ym::vec3f> pos;
    std::vector<ym::vec3f> norm;
    std::vector<ym::vec3f> tangsp;
    float weight = 0;
}
~~~

Morph information for shapes

- Members:
    - pos:      morph position
    - norm:      morph normal
    - tangsp:      morph tangent
    - weight:      default weight (the same for each shape in a mesh)


### Struct shape

~~~ .cpp

struct shape {
    std::string name = "";
    material* mat = nullptr;
    std::vector<ym::vec3f> pos;
    std::vector<ym::vec3f> norm;
    std::vector<ym::vec2f> texcoord;
    std::vector<ym::vec2f> texcoord1;
    std::vector<ym::vec4f> color;
    std::vector<float> radius;
    std::vector<ym::vec4f> tangsp;
    std::vector<ym::vec4f> skin_weights;
    std::vector<ym::vec4i> skin_joints;
    std::vector<int> points;
    std::vector<ym::vec2i> lines;
    std::vector<ym::vec3i> triangles;
    std::vector<shape_morph*> morph_targets;
    ~shape(); 
}
~~~

Primitives

- Members:
    - name:      name of the mesh that enclosed it
    - mat:      material reference
    - pos:      vertex position
    - norm:      vertex normal
    - texcoord:      vertex texcoord
    - texcoord1:      vertex additional texcoord
    - color:      vertex color
    - radius:      vertex radius
    - tangsp:      vertex tangent space
    - skin_weights:      vertex skinning weights
    - skin_joints:      vertex skinning joint indices
    - points:      point elements
    - lines:      line elements
    - triangles:      triangle elements
    - morph_targets:      morph targets
    - ~shape():      cleanup


### Struct mesh

~~~ .cpp
struct mesh {
    std::string name = "";
    std::vector<shape*> shapes;
    ~mesh(); 
}
~~~

Gltf mesh.

- Members:
    - name:      name
    - shapes:      primitives references
    - ~mesh():      cleanup


### Struct node

~~~ .cpp
struct node {
    std::string name = "";
    camera* cam = nullptr;
    mesh* msh = nullptr;
    skin* skn = nullptr;
    std::vector<node*> children;
    ym::mat4f matrix = ym::identity_mat4f;
    ym::quat4f rotation = {0, 0, 0, 1};
    ym::vec3f scale = {1, 1, 1};
    ym::vec3f translation = {0, 0, 0};
    std::vector<float> morph_weights;
    node* parent = nullptr;
    ym::mat4f xform() const; 
    ym::mat4f local_xform() const; 
    ym::mat4f skin_xform() const; 
    ym::mat4f _xform = ym::identity_mat4f;
    ym::mat4f _local_xform = ym::identity_mat4f;
    ym::mat4f _skin_xform = ym::identity_mat4f;
}
~~~

Node in the hierarchy.

- Members:
    - name:      name
    - cam:      camera reference
    - msh:      mesh reference
    - skn:      mesh reference
    - children:      children
    - matrix:      A floating-point 4x4 transformation matrix stored in column-major order.
    - rotation:      The node's unit quaternion rotation in the order (x, y, z, w), where w
     is the scalar.
    - scale:      The node's non-uniform scale.
    - translation:      The node's translation.
    - morph_weights:      morph target weights
    - parent:      parent node (computed during update_node_hierarchy())
    - xform():      transform (computed during update_transforms())
    - local_xform():      local transform (computed during update_transforms())
    - skin_xform():      skin transform (computed during update_transforms())
    - _xform:      transform (computed during update_transforms())
    - _local_xform:      local transform (computed during update_transforms())
    - _skin_xform:      skin transform (computed during update_transforms())


### Enum animation_interpolation

~~~ .cpp
enum struct animation_interpolation {
    linear = 0,
    step = 1,
    catmull_rom = 2,
    cubic = 3,
}
~~~

Animation Interpolation

- Values:
    - linear:      linear
    - step:      step function
    - catmull_rom:      catmull-rom spline
    - cubic:      cubic bezier spline


### Struct animation

~~~ .cpp
struct animation {
    animation_interpolation interp = animation_interpolation::step;
    std::vector<node*> nodes;
    std::vector<float> time;
    std::vector<ym::vec3f> translation;
    std::vector<ym::quat4f> rotation;
    std::vector<ym::vec3f> scale;
    std::vector<std::vector<float>> morph_weights;
}
~~~

Keyframe data.

- Members:
    - interp:      Interpolation
    - nodes:      Target nodes
    - time:      Times
    - translation:      Translation
    - rotation:      Rotation
    - scale:      Scale
    - morph_weights:      Weights for morphing


### Struct animation_group

~~~ .cpp
struct animation_group {
    std::string name;
    std::vector<animation*> animations;
    ~animation_group(); 
}
~~~

Animation

- Members:
    - name:      Name
    - animations:      Times
    - ~animation_group():      cleanup


### Struct skin

~~~ .cpp
struct skin {
    std::string name = "";
    std::vector<ym::mat4f> pose_matrices;
    std::vector<node*> joints;
    node* root = nullptr;
}
~~~

Skin

- Members:
    - name:      name
    - pose_matrices:      inverse bind matrix
    - joints:      joints
    - root:      skeleton root node


### Struct scene

~~~ .cpp
struct scene {
    std::string name = "";
    std::vector<node*> nodes;
}
~~~

Gltf scene

- Members:
    - name:      name
    - nodes:      instances


### Struct scene_group

~~~ .cpp
struct scene_group {
    scene* default_scene = nullptr;
    std::vector<camera*> cameras;
    std::vector<material*> materials;
    std::vector<texture*> textures;
    std::vector<mesh*> meshes;
    std::vector<scene*> scenes;
    std::vector<node*> nodes;
    std::vector<animation_group*> animations;
    std::vector<skin*> skins;
    ~scene_group(); 
}
~~~

Gltf model. Objects are shared between scenes.
Scenes and nodes are missing for mesh-only assets.

- Members:
    - default_scene:      default scene (null if not present)
    - cameras:      cameras
    - materials:      materials
    - textures:      textures
    - meshes:      meshes
    - scenes:      scenes
    - nodes:      nodes
    - animations:      nodes
    - skins:      skins
    - ~scene_group():      cleanup


### Function load_scenes()

~~~ .cpp
scene_group* load_scenes(const std::string& filename, bool load_textures,
    bool skip_missing = true, std::string* err = nullptr);
~~~

Load scene

- Parameters:
    - filename: filename
    - load_textures: whether to load textures (default to false)
    - skip_missing: whether to skip missing buffers and textures
    - err: if set, store error message on error
- Returns:
    - scene (nullptr on error)

### Function save_scenes()

~~~ .cpp
bool save_scenes(const std::string& filename, const scene_group* scn,
    bool save_textures, bool separate_buffers = false,
    std::string* err = nullptr);
~~~

Save scene

- Parameters:
    - filename: filename
    - scn: scene data to save
    - save_textures: whether to save textures (default to false)
    - separate_buffers: save separate buffers for each mesh
    - err: if set, store error message on error
- Returns:
    - whether an error occurred

### Function update_node_hierarchy()

~~~ .cpp
void update_node_hierarchy(scene_group* scn);
~~~

Update node hierarchy

### Function update_transforms()

~~~ .cpp
void update_transforms(scene_group* scn);
~~~

Update node trasforms

### Function get_mesh_nodes()

~~~ .cpp
std::vector<node*> get_mesh_nodes(const scene* scn);
~~~

Get a list of nodes with meshes

### Function get_camera_nodes()

~~~ .cpp
std::vector<node*> get_camera_nodes(const scene* scn);
~~~

Get a list of nodes with cameras

### Function get_animation_bounds()

~~~ .cpp
ym::vec2f get_animation_bounds(const scene_group* scn);
~~~

Animation times

### Function get_skin_transforms()

~~~ .cpp
std::vector<ym::mat4f> get_skin_transforms(
    const skin* sk, const ym::mat4f& xform);
~~~

Skin transforms (local-to-object) from the node transform that instances the
skin

### Function compute_morphing_deformation()

~~~ .cpp
void compute_morphing_deformation(const shape* shp,
    const std::vector<float>& weights, std::vector<ym::vec3f>& pos,
    std::vector<ym::vec3f>& norm, std::vector<ym::vec4f>& tangsp);
~~~

Compute shape morphing

### Function compute_scene_bounds()

~~~ .cpp
ym::bbox3f compute_scene_bounds(const scene_group* scn);
~~~

Computes a scene bounding box

### Function add_normals()

~~~ .cpp
void add_normals(scene_group* scn);
~~~

Add missing data to the scene.

### Function add_radius()

~~~ .cpp
void add_radius(scene_group* scn, float radius);
~~~

Add missing data to the scene.

### Function add_tangent_space()

~~~ .cpp
void add_tangent_space(scene_group* scn);
~~~

Add missing data to the scene.

### Function add_nodes()

~~~ .cpp
void add_nodes(scene_group* scn);
~~~

Add missing data to the scene.

### Function add_scene()

~~~ .cpp
void add_scene(scene_group* scn);
~~~

Add missing data to the scene.

### Function add_texture_data()

~~~ .cpp
void add_texture_data(scene_group* scn);
~~~

Add missing data to the scene.

### Function add_names()

~~~ .cpp
void add_names(scene_group* scn);
~~~

Add missing data to the scene.

### Function add_default_cameras()

~~~ .cpp
void add_default_cameras(scene_group* scn);
~~~

Add a default camera that views the entire scene.

### Typedef json

~~~ .cpp
using json = nlohmann::json;
~~~

Json alias

### Typedef shader_data

~~~ .cpp
using shader_data = std::string;
~~~

Shader data

### Typedef buffer_data

~~~ .cpp
using buffer_data = std::vector<unsigned char>;
~~~

Generic buffer data.

### Struct image_data

~~~ .cpp
struct image_data {
    int width = 0;
    int height = 0;
    int ncomp = 0;
    std::vector<uint8_t> datab;
    std::vector<float> dataf;
}
~~~

Generic image data.

- Members:
    - width:      Width
    - height:      Height
    - ncomp:      Number of Channels
    - datab:      Buffer data for 8-bit images
    - dataf:      Buffer data for float images


### Typedef extension_t

~~~ .cpp
using extension_t = std::map<std::string, json>;
~~~

Extensions

### Typedef extras_t

~~~ .cpp
using extras_t = json;
~~~

Extras

### Struct glTFid

~~~ .cpp
template <typename T>
struct glTFid {
    constexpr glTFid(); 
    constexpr explicit glTFid(int id); 
    constexpr explicit operator int() const; 
    bool is_valid() const; 
    explicit operator bool() const; 
}
~~~

glTFid

- Members:
    - glTFid():      defaoult constructor to an invalid id
    - glTFid():      explicit conversion from integer
    - operator int():      explicit convcersion to integer
    - is_valid():      check if it is valid
    - operator bool():      check if it is valid


### Struct glTFProperty

~~~ .cpp
struct glTFProperty {
    extension_t extensions = {};
    extras_t extras = {};
}
~~~

No documentation in schema.

- Members:
    - extensions:      No documentation in schema.
    - extras:      No documentation in schema.


### Struct glTFChildOfRootProperty

~~~ .cpp
struct glTFChildOfRootProperty : glTFProperty {
    std::string name = "";
}
~~~

No documentation in schema.

- Members:
    - name:      The user-defined name of this object.


### Enum glTFAccessorSparseIndicesComponentType

~~~ .cpp
enum struct glTFAccessorSparseIndicesComponentType {
    NotSet = -1,
    UnsignedByte = 5121,
    UnsignedShort = 5123,
    UnsignedInt = 5125,
}
~~~

Enum values for glTFAccessorSparseIndices::componentType.

- Values:
    - NotSet:      not set
    - UnsignedByte:      UnsignedByte
    - UnsignedShort:      UnsignedShort
    - UnsignedInt:      UnsignedInt


### Struct glTFAccessorSparseIndices

~~~ .cpp
struct glTFAccessorSparseIndices : glTFProperty {
    glTFid<glTFBufferView> bufferView = {};
    int byteOffset = 0;
    glTFAccessorSparseIndicesComponentType componentType =
        glTFAccessorSparseIndicesComponentType::NotSet;
}
~~~

Indices of those attributes that deviate from their initialization value.

- Members:
    - bufferView:      The index of the bufferView with sparse indices. Referenced bufferView
     can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target. [required]
    - byteOffset:      The offset relative to the start of the bufferView in bytes. Must be
     aligned.
    - componentType:      The indices data type. [required]


### Struct glTFAccessorSparseValues

~~~ .cpp
struct glTFAccessorSparseValues : glTFProperty {
    glTFid<glTFBufferView> bufferView = {};
    int byteOffset = 0;
}
~~~

Array of size `accessor.sparse.count` times number of components storing the
displaced accessor attributes pointed by `accessor.sparse.indices`.

- Members:
    - bufferView:      The index of the bufferView with sparse values. Referenced bufferView
     can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target. [required]
    - byteOffset:      The offset relative to the start of the bufferView in bytes. Must be
     aligned.


### Struct glTFAccessorSparse

~~~ .cpp
struct glTFAccessorSparse : glTFProperty {
    int count = 0;
    glTFAccessorSparseIndices* indices = nullptr;
    glTFAccessorSparseValues* values = nullptr;
    ~glTFAccessorSparse(); 
}
~~~

Sparse storage of attributes that deviate from their initialization value.

- Members:
    - count:      Number of entries stored in the sparse array. [required]
    - indices:      Index array of size `count` that points to those accessor attributes
     that deviate from their initialization value. Indices must strictly
     increase. [required]
    - values:      Array of size `count` times number of components, storing the displaced
     accessor attributes pointed by `indices`. Substituted values must have
     the same `componentType` and number of components as the base accessor.
     [required]
    - ~glTFAccessorSparse():      destructor


### Enum glTFAccessorComponentType

~~~ .cpp
enum struct glTFAccessorComponentType {
    NotSet = -1,
    Byte = 5120,
    UnsignedByte = 5121,
    Short = 5122,
    UnsignedShort = 5123,
    UnsignedInt = 5125,
    Float = 5126,
}
~~~

Enum values for glTFAccessor::componentType.

- Values:
    - NotSet:      not set
    - Byte:      Byte
    - UnsignedByte:      UnsignedByte
    - Short:      Short
    - UnsignedShort:      UnsignedShort
    - UnsignedInt:      UnsignedInt
    - Float:      Float


### Enum glTFAccessorType

~~~ .cpp
enum struct glTFAccessorType {
    NotSet = -1,
    Scalar = 0,
    Vec2 = 1,
    Vec3 = 2,
    Vec4 = 3,
    Mat2 = 4,
    Mat3 = 5,
    Mat4 = 6,
}
~~~

Values for glTFAccessor::type.

- Values:
    - NotSet:      not set
    - Scalar:      Scalar
    - Vec2:      Vec2
    - Vec3:      Vec3
    - Vec4:      Vec4
    - Mat2:      Mat2
    - Mat3:      Mat3
    - Mat4:      Mat4


### Struct glTFAccessor

~~~ .cpp
struct glTFAccessor : glTFChildOfRootProperty {
    glTFid<glTFBufferView> bufferView = {};
    int byteOffset = 0;
    glTFAccessorComponentType componentType = glTFAccessorComponentType::NotSet;
    int count = 0;
    std::vector<float> max = {};
    std::vector<float> min = {};
    bool normalized = false;
    glTFAccessorSparse* sparse = nullptr;
    glTFAccessorType type = glTFAccessorType::NotSet;
    ~glTFAccessor(); 
}
~~~

A typed view into a bufferView.  A bufferView contains raw binary data.  An
accessor provides a typed view into a bufferView or a subset of a bufferView
similar to how WebGL's `vertexAttribPointer()` defines an attribute in a
buffer.

- Members:
    - bufferView:      The index of the bufferView.
    - byteOffset:      The offset relative to the start of the bufferView in bytes.
    - componentType:      The datatype of components in the attribute. [required]
    - count:      The number of attributes referenced by this accessor. [required]
    - max:      Maximum value of each component in this attribute.
    - min:      Minimum value of each component in this attribute.
    - normalized:      Specifies whether integer data values should be normalized.
    - sparse:      Sparse storage of attributes that deviate from their initialization
     value.
    - type:      Specifies if the attribute is a scalar, vector, or matrix. [required]
    - ~glTFAccessor():      destructor


### Enum glTFAnimationChannelTargetPath

~~~ .cpp
enum struct glTFAnimationChannelTargetPath {
    NotSet = -1,
    Translation = 0,
    Rotation = 1,
    Scale = 2,
    Weights = 3,
}
~~~

Values for glTFAnimationChannelTarget::path.

- Values:
    - NotSet:      not set
    - Translation:      Translation
    - Rotation:      Rotation
    - Scale:      Scale
    - Weights:      Weights


### Struct glTFAnimationChannelTarget

~~~ .cpp
struct glTFAnimationChannelTarget : glTFProperty {
    glTFid<glTFNode> node = {};
    glTFAnimationChannelTargetPath path =
        glTFAnimationChannelTargetPath::NotSet;
}
~~~

The index of the node and TRS property that an animation channel targets.

- Members:
    - node:      The index of the node to target. [required]
    - path:      The name of the node's TRS property to modify, or the "weights" of the
     Morph Targets it instantiates. [required]


### Struct glTFAnimationChannel

~~~ .cpp
struct glTFAnimationChannel : glTFProperty {
    glTFid<glTFAnimationSampler> sampler = {};
    glTFAnimationChannelTarget* target = nullptr;
    ~glTFAnimationChannel(); 
}
~~~

Targets an animation's sampler at a node's property.

- Members:
    - sampler:      The index of a sampler in this animation used to compute the value for
     the target. [required]
    - target:      The index of the node and TRS property to target. [required]
    - ~glTFAnimationChannel():      destructor


### Enum glTFAnimationSamplerInterpolation

~~~ .cpp
enum struct glTFAnimationSamplerInterpolation {
    NotSet = -1,
    Linear = 0,
    Step = 1,
    Catmullromspline = 2,
    Cubicspline = 3,
}
~~~

Values for glTFAnimationSampler::interpolation.

- Values:
    - NotSet:      not set
    - Linear:      Linear
    - Step:      Step
    - Catmullromspline:      Catmullromspline
    - Cubicspline:      Cubicspline


### Struct glTFAnimationSampler

~~~ .cpp
struct glTFAnimationSampler : glTFProperty {
    glTFid<glTFAccessor> input = {};
    glTFAnimationSamplerInterpolation interpolation =
        glTFAnimationSamplerInterpolation::Linear;
    glTFid<glTFAccessor> output = {};
}
~~~

Combines input and output accessors with an interpolation algorithm to
define a keyframe graph (but not its target).

- Members:
    - input:      The index of an accessor containing keyframe input values, e.g., time.
     [required]
    - interpolation:      Interpolation algorithm.
    - output:      The index of an accessor, containing keyframe output values. [required]


### Struct glTFAnimation

~~~ .cpp
struct glTFAnimation : glTFChildOfRootProperty {
    std::vector<glTFAnimationChannel*> channels = {};
    std::vector<glTFAnimationSampler*> samplers = {};
    glTFAnimationChannel* get(const glTFid<glTFAnimationChannel>& id) const; 
    glTFAnimationSampler* get(const glTFid<glTFAnimationSampler>& id) const; 
    ~glTFAnimation(); 
}
~~~

A keyframe animation.

- Members:
    - channels:      An array of channels, each of which targets an animation's sampler at a
     node's property. Different channels of the same animation can't have
     equal targets. [required]
    - samplers:      An array of samplers that combines input and output accessors with an
     interpolation algorithm to define a keyframe graph (but not its target).
     [required]
    - get():      typed access for channels
    - get():      typed access for samplers
    - ~glTFAnimation():      destructor


### Struct glTFAsset

~~~ .cpp
struct glTFAsset : glTFProperty {
    std::string copyright = "";
    std::string generator = "";
    std::string minVersion = "";
    std::string version = "";
}
~~~

Metadata about the glTF asset.

- Members:
    - copyright:      A copyright message suitable for display to credit the content creator.
    - generator:      Tool that generated this glTF model.  Useful for debugging.
    - minVersion:      The minimum glTF version that this asset targets.
    - version:      The glTF version that this asset targets. [required]


### Struct glTFBuffer

~~~ .cpp
struct glTFBuffer : glTFChildOfRootProperty {
    int byteLength = 0;
    std::string uri = "";
    buffer_data data = {};
}
~~~

A buffer points to binary geometry, animation, or skins.

- Members:
    - byteLength:      The length of the buffer in bytes. [required]
    - uri:      The uri of the buffer.
    - data:      Buffer data if loaded.


### Enum glTFBufferViewTarget

~~~ .cpp
enum struct glTFBufferViewTarget {
    NotSet = -1,
    ArrayBuffer = 34962,
    ElementArrayBuffer = 34963,
}
~~~

Enum values for glTFBufferView::target.

- Values:
    - NotSet:      not set
    - ArrayBuffer:      ArrayBuffer
    - ElementArrayBuffer:      ElementArrayBuffer


### Struct glTFBufferView

~~~ .cpp
struct glTFBufferView : glTFChildOfRootProperty {
    glTFid<glTFBuffer> buffer = {};
    int byteLength = 0;
    int byteOffset = 0;
    int byteStride = 0;
    glTFBufferViewTarget target = glTFBufferViewTarget::NotSet;
}
~~~

A view into a buffer generally representing a subset of the buffer.

- Members:
    - buffer:      The index of the buffer. [required]
    - byteLength:      The length of the bufferView in bytes. [required]
    - byteOffset:      The offset into the buffer in bytes.
    - byteStride:      The stride, in bytes.
    - target:      The target that the GPU buffer should be bound to.


### Struct glTFCameraOrthographic

~~~ .cpp
struct glTFCameraOrthographic : glTFProperty {
    float xmag = 0;
    float ymag = 0;
    float zfar = 0;
    float znear = 0;
}
~~~

An orthographic camera containing properties to create an orthographic
projection matrix.

- Members:
    - xmag:      The floating-point horizontal magnification of the view. [required]
    - ymag:      The floating-point vertical magnification of the view. [required]
    - zfar:      The floating-point distance to the far clipping plane. `zfar` must be
     greater than `znear`. [required]
    - znear:      The floating-point distance to the near clipping plane. [required]


### Struct glTFCameraPerspective

~~~ .cpp
struct glTFCameraPerspective : glTFProperty {
    float aspectRatio = 0;
    float yfov = 0;
    float zfar = 0;
    float znear = 0;
}
~~~

A perspective camera containing properties to create a perspective
projection matrix.

- Members:
    - aspectRatio:      The floating-point aspect ratio of the field of view.
    - yfov:      The floating-point vertical field of view in radians. [required]
    - zfar:      The floating-point distance to the far clipping plane.
    - znear:      The floating-point distance to the near clipping plane. [required]


### Enum glTFCameraType

~~~ .cpp
enum struct glTFCameraType {
    NotSet = -1,
    Perspective = 0,
    Orthographic = 1,
}
~~~

Values for glTFCamera::type.

- Values:
    - NotSet:      not set
    - Perspective:      Perspective
    - Orthographic:      Orthographic


### Struct glTFCamera

~~~ .cpp
struct glTFCamera : glTFChildOfRootProperty {
    glTFCameraOrthographic* orthographic = nullptr;
    glTFCameraPerspective* perspective = nullptr;
    glTFCameraType type = glTFCameraType::NotSet;
    ~glTFCamera(); 
}
~~~

A camera's projection.  A node can reference a camera to apply a transform
to place the camera in the scene.

- Members:
    - orthographic:      An orthographic camera containing properties to create an orthographic
     projection matrix.
    - perspective:      A perspective camera containing properties to create a perspective
     projection matrix.
    - type:      Specifies if the camera uses a perspective or orthographic projection.
     [required]
    - ~glTFCamera():      destructor


### Enum glTFImageMimeType

~~~ .cpp
enum struct glTFImageMimeType {
    NotSet = -1,
    ImageJpeg = 0,
    ImagePng = 1,
}
~~~

Values for glTFImage::mimeType.

- Values:
    - NotSet:      not set
    - ImageJpeg:      ImageJpeg
    - ImagePng:      ImagePng


### Struct glTFImage

~~~ .cpp
struct glTFImage : glTFChildOfRootProperty {
    glTFid<glTFBufferView> bufferView = {};
    glTFImageMimeType mimeType = glTFImageMimeType::NotSet;
    std::string uri = "";
    image_data data = {};
}
~~~

Image data used to create a texture. Image can be referenced by URI or
`bufferView` index. `mimeType` is required in the latter case.

- Members:
    - bufferView:      The index of the bufferView that contains the image. Use this instead of
     the image's uri property.
    - mimeType:      The image's MIME type.
    - uri:      The uri of the image.
    - data:      Image data if loaded.


### Struct glTFTextureInfo

~~~ .cpp
struct glTFTextureInfo : glTFProperty {
    glTFid<glTFTexture> index = {};
    int texCoord = 0;
}
~~~

Reference to a texture.

- Members:
    - index:      The index of the texture. [required]
    - texCoord:      The set index of texture's TEXCOORD attribute used for texture
     coordinate mapping.


### Struct glTFTexture

~~~ .cpp
struct glTFTexture : glTFChildOfRootProperty {
    glTFid<glTFSampler> sampler = {};
    glTFid<glTFImage> source = {};
}
~~~

A texture and its sampler.

- Members:
    - sampler:      The index of the sampler used by this texture. When undefined, a sampler
     with repeat wrapping and auto filtering should be used.
    - source:      The index of the image used by this texture.


### Struct glTFMaterialNormalTextureInfo

~~~ .cpp
struct glTFMaterialNormalTextureInfo : glTFTextureInfo {
    float scale = 1;
}
~~~

No documentation in schema.

- Members:
    - scale:      The scalar multiplier applied to each normal vector of the normal
     texture.


### Struct glTFMaterialOcclusionTextureInfo

~~~ .cpp
struct glTFMaterialOcclusionTextureInfo : glTFTextureInfo {
    float strength = 1;
}
~~~

No documentation in schema.

- Members:
    - strength:      A scalar multiplier controlling the amount of occlusion applied.


### Struct glTFMaterialPbrMetallicRoughness

~~~ .cpp
struct glTFMaterialPbrMetallicRoughness : glTFProperty {
    ym::vec4f baseColorFactor = {1, 1, 1, 1};
    glTFTextureInfo* baseColorTexture = nullptr;
    float metallicFactor = 1;
    glTFTextureInfo* metallicRoughnessTexture = nullptr;
    float roughnessFactor = 1;
    ~glTFMaterialPbrMetallicRoughness(); 
}
~~~

A set of parameter values that are used to define the metallic-roughness
material model from Physically-Based Rendering (PBR) methodology.

- Members:
    - baseColorFactor:      The material's base color factor.
    - baseColorTexture:      The base color texture.
    - metallicFactor:      The metalness of the material.
    - metallicRoughnessTexture:      The metallic-roughness texture.
    - roughnessFactor:      The roughness of the material.
    - ~glTFMaterialPbrMetallicRoughness():      destructor


### Struct glTFMaterialPbrSpecularGlossiness

~~~ .cpp
struct glTFMaterialPbrSpecularGlossiness : glTFProperty {
    ym::vec4f diffuseFactor = {1, 1, 1, 1};
    glTFTextureInfo* diffuseTexture = nullptr;
    float glossinessFactor = 1;
    ym::vec3f specularFactor = {1, 1, 1};
    glTFTextureInfo* specularGlossinessTexture = nullptr;
    ~glTFMaterialPbrSpecularGlossiness(); 
}
~~~

glTF extension that defines the specular-glossiness material model from
Physically-Based Rendering (PBR) methodology.

- Members:
    - diffuseFactor:      The reflected diffuse factor of the material.
    - diffuseTexture:      The diffuse texture.
    - glossinessFactor:      The glossiness or smoothness of the material.
    - specularFactor:      The specular RGB color of the material.
    - specularGlossinessTexture:      The specular-glossiness texture.
    - ~glTFMaterialPbrSpecularGlossiness():      destructor


### Enum glTFMaterialAlphaMode

~~~ .cpp
enum struct glTFMaterialAlphaMode {
    NotSet = -1,
    Opaque = 0,
    Mask = 1,
    Blend = 2,
}
~~~

Values for glTFMaterial::alphaMode.

- Values:
    - NotSet:      not set
    - Opaque:      Opaque
    - Mask:      Mask
    - Blend:      Blend


### Struct glTFMaterial

~~~ .cpp
struct glTFMaterial : glTFChildOfRootProperty {
    float alphaCutoff = 0.5;
    glTFMaterialAlphaMode alphaMode = glTFMaterialAlphaMode::Opaque;
    bool doubleSided = false;
    ym::vec3f emissiveFactor = {0, 0, 0};
    glTFTextureInfo* emissiveTexture = nullptr;
    glTFMaterialNormalTextureInfo* normalTexture = nullptr;
    glTFMaterialOcclusionTextureInfo* occlusionTexture = nullptr;
    glTFMaterialPbrMetallicRoughness* pbrMetallicRoughness = nullptr;
    glTFMaterialPbrSpecularGlossiness* pbrSpecularGlossiness = nullptr;
    ~glTFMaterial(); 
}
~~~

The material appearance of a primitive.

- Members:
    - alphaCutoff:      The alpha cutoff value of the material.
    - alphaMode:      The alpha rendering mode of the material.
    - doubleSided:      Specifies whether the material is double sided.
    - emissiveFactor:      The emissive color of the material.
    - emissiveTexture:      The emissive map texture.
    - normalTexture:      The normal map texture.
    - occlusionTexture:      The occlusion map texture.
    - pbrMetallicRoughness:      A set of parameter values that are used to define the metallic-roughness
     material model from Physically-Based Rendering (PBR) methodology. When
     not specified, all the default values of `pbrMetallicRoughness` apply.
    - pbrSpecularGlossiness:      A set of parameter values that are used to define the
     specular-glossiness material model from Physically-Based Rendering (PBR)
     methodology. When not specified, all the default values of
     `pbrMetallicRoughness` apply.
    - ~glTFMaterial():      destructor


### Enum glTFMeshPrimitiveMode

~~~ .cpp
enum struct glTFMeshPrimitiveMode {
    NotSet = -1,
    Points = 0,
    Lines = 1,
    LineLoop = 2,
    LineStrip = 3,
    Triangles = 4,
    TriangleStrip = 5,
    TriangleFan = 6,
}
~~~

Enum values for glTFMeshPrimitive::mode.

- Values:
    - NotSet:      not set
    - Points:      Points
    - Lines:      Lines
    - LineLoop:      LineLoop
    - LineStrip:      LineStrip
    - Triangles:      Triangles
    - TriangleStrip:      TriangleStrip
    - TriangleFan:      TriangleFan


### Struct glTFMeshPrimitive

~~~ .cpp
struct glTFMeshPrimitive : glTFProperty {
    std::map<std::string, glTFid<glTFAccessor>> attributes = {};
    glTFid<glTFAccessor> indices = {};
    glTFid<glTFMaterial> material = {};
    glTFMeshPrimitiveMode mode = glTFMeshPrimitiveMode::Triangles;
    std::vector<std::map<std::string, glTFid<glTFAccessor>>> targets = {};
}
~~~

Geometry to be rendered with the given material.

- Members:
    - attributes:      A dictionary object, where each key corresponds to mesh attribute
     semantic and each value is the index of the accessor containing
     attribute's data. [required]
    - indices:      The index of the accessor that contains the indices.
    - material:      The index of the material to apply to this primitive when rendering.
    - mode:      The type of primitives to render.
    - targets:      An array of Morph Targets, each  Morph Target is a dictionary mapping
     attributes (only `POSITION`, `NORMAL`, and `TANGENT` supported) to their
     deviations in the Morph Target.


### Struct glTFMesh

~~~ .cpp
struct glTFMesh : glTFChildOfRootProperty {
    std::vector<glTFMeshPrimitive*> primitives = {};
    std::vector<float> weights = {};
    ~glTFMesh(); 
}
~~~

A set of primitives to be rendered.  A node can contain one mesh.  A node's
transform places the mesh in the scene.

- Members:
    - primitives:      An array of primitives, each defining geometry to be rendered with a
     material. [required]
    - weights:      Array of weights to be applied to the Morph Targets.
    - ~glTFMesh():      destructor


### Struct glTFNode

~~~ .cpp
struct glTFNode : glTFChildOfRootProperty {
    glTFid<glTFCamera> camera = {};
    std::vector<glTFid<glTFNode>> children = {};
    ym::mat4f matrix = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}};
    glTFid<glTFMesh> mesh = {};
    ym::quat4f rotation = {0, 0, 0, 1};
    ym::vec3f scale = {1, 1, 1};
    glTFid<glTFSkin> skin = {};
    ym::vec3f translation = {0, 0, 0};
    std::vector<float> weights = {};
}
~~~

A node in the node hierarchy.  When the node contains `skin`, all
`mesh.primitives` must contain `JOINTS_0` and `WEIGHTS_0` attributes.  A
node can have either a `matrix` or any combination of
`translation`/`rotation`/`scale` (TRS) properties. TRS properties are
converted to matrices and postmultiplied in the `T * R * S` order to compose
the transformation matrix; first the scale is applied to the vertices, then
the rotation, and then the translation. If none are provided, the transform
is the identity. When a node is targeted for animation (referenced by an
animation.channel.target), only TRS properties may be present; `matrix` will
not be present.

- Members:
    - camera:      The index of the camera referenced by this node.
    - children:      The indices of this node's children.
    - matrix:      A floating-point 4x4 transformation matrix stored in column-major order.
    - mesh:      The index of the mesh in this node.
    - rotation:      The node's unit quaternion rotation in the order (x, y, z, w), where w
     is the scalar.
    - scale:      The node's non-uniform scale.
    - skin:      The index of the skin referenced by this node.
    - translation:      The node's translation.
    - weights:      The weights of the instantiated Morph Target. Number of elements must
     match number of Morph Targets of used mesh.


### Enum glTFSamplerMagFilter

~~~ .cpp
enum struct glTFSamplerMagFilter {
    NotSet = -1,
    Nearest = 9728,
    Linear = 9729,
}
~~~

Enum values for glTFSampler::magFilter.

- Values:
    - NotSet:      not set
    - Nearest:      Nearest
    - Linear:      Linear


### Enum glTFSamplerMinFilter

~~~ .cpp
enum struct glTFSamplerMinFilter {
    NotSet = -1,
    Nearest = 9728,
    Linear = 9729,
    NearestMipmapNearest = 9984,
    LinearMipmapNearest = 9985,
    NearestMipmapLinear = 9986,
    LinearMipmapLinear = 9987,
}
~~~

Enum values for glTFSampler::minFilter.

- Values:
    - NotSet:      not set
    - Nearest:      Nearest
    - Linear:      Linear
    - NearestMipmapNearest:      NearestMipmapNearest
    - LinearMipmapNearest:      LinearMipmapNearest
    - NearestMipmapLinear:      NearestMipmapLinear
    - LinearMipmapLinear:      LinearMipmapLinear


### Enum glTFSamplerWrapS

~~~ .cpp
enum struct glTFSamplerWrapS {
    NotSet = -1,
    ClampToEdge = 33071,
    MirroredRepeat = 33648,
    Repeat = 10497,
}
~~~

Enum values for glTFSampler::wrapS.

- Values:
    - NotSet:      not set
    - ClampToEdge:      ClampToEdge
    - MirroredRepeat:      MirroredRepeat
    - Repeat:      Repeat


### Enum glTFSamplerWrapT

~~~ .cpp
enum struct glTFSamplerWrapT {
    NotSet = -1,
    ClampToEdge = 33071,
    MirroredRepeat = 33648,
    Repeat = 10497,
}
~~~

Enum values for glTFSampler::wrapT.

- Values:
    - NotSet:      not set
    - ClampToEdge:      ClampToEdge
    - MirroredRepeat:      MirroredRepeat
    - Repeat:      Repeat


### Struct glTFSampler

~~~ .cpp
struct glTFSampler : glTFChildOfRootProperty {
    glTFSamplerMagFilter magFilter = glTFSamplerMagFilter::NotSet;
    glTFSamplerMinFilter minFilter = glTFSamplerMinFilter::NotSet;
    glTFSamplerWrapS wrapS = glTFSamplerWrapS::Repeat;
    glTFSamplerWrapT wrapT = glTFSamplerWrapT::Repeat;
}
~~~

Texture sampler properties for filtering and wrapping modes.

- Members:
    - magFilter:      Magnification filter.
    - minFilter:      Minification filter.
    - wrapS:      s wrapping mode.
    - wrapT:      t wrapping mode.


### Struct glTFScene

~~~ .cpp
struct glTFScene : glTFChildOfRootProperty {
    std::vector<glTFid<glTFNode>> nodes = {};
}
~~~

The root nodes of a scene.

- Members:
    - nodes:      The indices of each root node.


### Struct glTFSkin

~~~ .cpp
struct glTFSkin : glTFChildOfRootProperty {
    glTFid<glTFAccessor> inverseBindMatrices = {};
    std::vector<glTFid<glTFNode>> joints = {};
    glTFid<glTFNode> skeleton = {};
}
~~~

Joints and matrices defining a skin.

- Members:
    - inverseBindMatrices:      The index of the accessor containing the floating-point 4x4 inverse-bind
     matrices.  The default is that each matrix is a 4x4 identity matrix,
     which implies that inverse-bind matrices were pre-applied.
    - joints:      Indices of skeleton nodes, used as joints in this skin. [required]
    - skeleton:      The index of the node used as a skeleton root. When undefined, joints
     transforms resolve to scene root.


### Struct glTF

~~~ .cpp
struct glTF : glTFProperty {
    std::vector<glTFAccessor*> accessors = {};
    std::vector<glTFAnimation*> animations = {};
    glTFAsset* asset = nullptr;
    std::vector<glTFBufferView*> bufferViews = {};
    std::vector<glTFBuffer*> buffers = {};
    std::vector<glTFCamera*> cameras = {};
    std::vector<std::string> extensionsRequired = {};
    std::vector<std::string> extensionsUsed = {};
    std::vector<glTFImage*> images = {};
    std::vector<glTFMaterial*> materials = {};
    std::vector<glTFMesh*> meshes = {};
    std::vector<glTFNode*> nodes = {};
    std::vector<glTFSampler*> samplers = {};
    glTFid<glTFScene> scene = {};
    std::vector<glTFScene*> scenes = {};
    std::vector<glTFSkin*> skins = {};
    std::vector<glTFTexture*> textures = {};
    glTFAccessor* get(const glTFid<glTFAccessor>& id) const; 
    glTFAnimation* get(const glTFid<glTFAnimation>& id) const; 
    glTFBufferView* get(const glTFid<glTFBufferView>& id) const; 
    glTFBuffer* get(const glTFid<glTFBuffer>& id) const; 
    glTFCamera* get(const glTFid<glTFCamera>& id) const; 
    glTFImage* get(const glTFid<glTFImage>& id) const; 
    glTFMaterial* get(const glTFid<glTFMaterial>& id) const; 
    glTFMesh* get(const glTFid<glTFMesh>& id) const; 
    glTFNode* get(const glTFid<glTFNode>& id) const; 
    glTFSampler* get(const glTFid<glTFSampler>& id) const; 
    glTFScene* get(const glTFid<glTFScene>& id) const; 
    glTFSkin* get(const glTFid<glTFSkin>& id) const; 
    glTFTexture* get(const glTFid<glTFTexture>& id) const; 
    ~glTF(); 
}
~~~

The root object for a glTF asset.

- Members:
    - accessors:      An array of accessors.
    - animations:      An array of keyframe animations.
    - asset:      Metadata about the glTF asset. [required]
    - bufferViews:      An array of bufferViews.
    - buffers:      An array of buffers.
    - cameras:      An array of cameras.
    - extensionsRequired:      Names of glTF extensions required to properly load this asset.
    - extensionsUsed:      Names of glTF extensions used somewhere in this asset.
    - images:      An array of images.
    - materials:      An array of materials.
    - meshes:      An array of meshes.
    - nodes:      An array of nodes.
    - samplers:      An array of samplers.
    - scene:      The index of the default scene.
    - scenes:      An array of scenes.
    - skins:      An array of skins.
    - textures:      An array of textures.
    - get():      typed access for accessors
    - get():      typed access for animations
    - get():      typed access for bufferViews
    - get():      typed access for buffers
    - get():      typed access for cameras
    - get():      typed access for images
    - get():      typed access for materials
    - get():      typed access for meshes
    - get():      typed access for nodes
    - get():      typed access for samplers
    - get():      typed access for scenes
    - get():      typed access for skins
    - get():      typed access for textures
    - ~glTF():      destructor


### Function load_gltf()

~~~ .cpp
glTF* load_gltf(const std::string& filename, bool load_bin = true,
    bool load_img = false, bool skip_missing = false,
    std::string* err = nullptr);
~~~

Loads a gltf file from disk

- Parameters:
    - filename: scene filename
    - load_bin/load_img: load binary data
    - skip_missing: do not throw an exception if a file is missing
    - err: if set, store error message on error
- Returns:
    - gltf data loaded (nullptr on error)

### Function load_binary_gltf()

~~~ .cpp
glTF* load_binary_gltf(const std::string& filename, bool load_bin = true,
    bool load_img = false, bool skip_missing = false,
    std::string* err = nullptr);
~~~

Loads a binary gltf file from disk

- Parameters:
    - filename: scene filename
    - other params as above
    - err: if set, store error message on error
- Returns:
    - gltf data loaded (nullptr on error)

### Function save_gltf()

~~~ .cpp
bool save_gltf(const std::string& filename, const glTF* gltf,
    bool save_bin = true, bool save_images = false, std::string* err = nullptr);
~~~

Saves a scene to disk

- Parameters:
    - filename: scene filename
    - gltf: data to save
    - save_bin/save_images: save binary data
    - err: if set, store error message on error
- Returns:
    - whether an error occurred

### Function save_binary_gltf()

~~~ .cpp
bool save_binary_gltf(const std::string& filename, const glTF* gltf,
    bool save_bin = true, bool save_images = false, std::string* err = nullptr);
~~~

Saves a scene to disk

- Parameters:
    - filename: scene filename
    - gltf: data to save
    - save_bin/save_images: save binary data
    - err: if set, store error message on error
- Returns:
    - whether an error occurred

### Function load_buffers()

~~~ .cpp
bool load_buffers(glTF* gltf, const std::string& dirname,
    bool skip_missing = false, std::string* err = nullptr);
~~~

Load buffer data.

- Parameters:
    - dirname: directory used to resolve path references
    - skip_missing: do not throw an exception if a file is missing
    - err: if set, store error message on error
- Out Parameters:
    - gltf: data to data
- Returns:
    - whether an error occurred

### Function load_images()

~~~ .cpp
bool load_images(glTF* asset, const std::string& dirname,
    bool skip_missing = false, std::string* err = nullptr);
~~~

Loads images.

- Parameters:
    - dirname: directory used to resolve path references
    - skip_missing: do not throw an exception if a file is missing
    - err: if set, store error message on error
- Out Parameters:
    - gltf: data to data
- Returns:
    - whether an error occurred

### Function save_buffers()

~~~ .cpp
bool save_buffers(const glTF* gltf, const std::string& dirname,
    bool skip_missing, std::string* err = nullptr);
~~~

Save buffer data.

- Parameters:
    - dirname: directory used to resolve path references
    - gltf: data to save
    - skip_missing: do not throw an exception if a file is missing
    - err: if set, store error message on error
- Returns:
    - whether an error occurred

### Function save_images()

~~~ .cpp
bool save_images(const glTF* asset, const std::string& dirname,
    bool skip_missing, std::string* err = nullptr);
~~~

Saves images.

- Parameters:
    - dirname: directory used to resolve path references
    - gltf: data to save
    - skip_missing: do not throw an exception if a file is missing
    - err: if set, store error message on error
- Returns:
    - whether an error occurred

### Function gltf_to_scenes()

~~~ .cpp
scene_group* gltf_to_scenes(const glTF* gltf, int scene_idx = -1);
~~~

Convert a gltf asset to flattened group of scene.

### Function scenes_to_gltf()

~~~ .cpp
glTF* scenes_to_gltf(const scene_group* fl_gltf, const std::string& buffer_uri,
    bool separate_buffers = false);
~~~

Convert a flattened group of scene into a gltf. If separate_buffers,
creates a separate buffer for each each and animation and
prepend buffer_uri to its name.

### Function validate_gltf()

~~~ .cpp
std::vector<std::pair<std::string, std::string>> validate_gltf(
    const glTF* gltf);
~~~

Validate a gltf. Missing many validation as of this version.

### Struct vec_array_view

~~~ .cpp
struct vec_array_view {
~~~

A view for gltf array buffers that allows for typed access.

### Struct element_array_view

~~~ .cpp
struct element_array_view {
~~~

A view for gltf element array buffers that allows for typed access.

### Function node_transform()

~~~ .cpp
ym::mat4f node_transform(const glTFNode* node);
~~~

Computes the local node transform and its inverse.

### Struct buffer_section

~~~ .cpp
struct buffer_section {
    int refcount = 0;
    int start = 0;
    int size = 0;
    int stride = 0;
    int count = 0;
    glTFAccessorType type = glTFAccessorType::NotSet;
    glTFAccessorComponentType ctype = glTFAccessorComponentType::NotSet;
    int ncomp = 0;
    int csize = 0;
}
~~~

buffer section

- Members:
    - refcount:      number of times it is references
    - start:      starting byte
    - size:      size in byte
    - stride:      stride in byte
    - count:      number of elements
    - type:      type
    - ctype:      component type
    - ncomp:      number of element component
    - csize:      component size in byte


### Struct buffer_descr

~~~ .cpp
struct buffer_descr {
    int buffer = -1;
    std::string name = "";
    std::string uri = "";
    int size = -1;
    std::vector<buffer_section*> sections;
    ~buffer_descr(); 
}
~~~

Buffer descriptor

- Members:
    - buffer:      buffer index
    - name:      buffer name
    - uri:      buffer uri
    - size:      buffer size
    - sections:      sections
    - ~buffer_descr():      cleanup


### Function gen_buffer_descriptors()

~~~ .cpp
std::vector<buffer_descr*> gen_buffer_descriptors(const glTF* gltf);
~~~

Generate buffer descriptions.

