
        <!DOCTYPE html>
        <html lang="en">
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
          <link rel="stylesheet" href="style.css">
        </head>
        <body>
        <header></header>
        <article>
        <h1>Yocto/Trace</h1>
<p>Path tracer implementation for support for textured mesh
lights, GGX/Phong materials, environment mapping. The interface supports
progressive parallel execution with any splitting strategy, by
generating per-sample random number sequences or fully deterministic
hash-based sampling.</p>
<p>The raytraced scene is a list of instances of basic shapes. Each shape
is a collection of points, lines or triangles with associated normals.
Shapes are instanced by creating instances with soecific local-to-world
trasforms. Instancing shares memory so large scenes can be created easily.
Shaope data is in fact shared with the application and not copied
internally.</p>
<p>Materials are represented as sums of an emission term, a diffuse term and
a specular microfacet term (GGX or Phong). Only opaque for now. We pick
a proper material type for each shape element type (points, lines,
triangles).</p>
<p>Lights are defined as any shape with a material emission term. Additionally
one can also add an environment map. But even if you can, you might want to
add a large triangle mesh with inward normals instead. The latter is more
general (you can even more an arbitrary shape sun). For now only the first
env is used.</p>
<p>We generate our own random numbers guarantying that there is one random
sequence per path. This means you can run the path tracer in any order
serially or in parallel.</p>
<p>For now, we support a straightforward path tracer with explicit direct
illumination using MIS. Also added simpler shaders for a quick preview
and a direct-only renderer.</p>
<p>The library can support raytracing either by building an internal
acceleration structure with Yocto/Bvh or with user supplied intersection
routines for custom intersection.</p>
<p>This library depends in yocto_math.h. Optionally depend on yocto_bvh.h/.cpp
for internal acceleration. Disable this by setting YTRACE_NO_BVH.</p>
<h2>Usage for Scene Creation</h2>
<ol>
<li>create a scene with <code>make_scene()</code></li>
<li>add cameras with <code>add_camera()</code>, <code>set_camera()</code></li>
<li>add add texture with <code>add_texture()</code></li>
<li>create material with <code>add_XXX_material()</code></li>
<li>add shapes with <code>add_XXX_shape()</code></li>
<li>add instances with <code>add_instance()</code></li>
<li>add environment maps with <code>add_environment()</code></li>
</ol>
<h2>Usage for Rendering</h2>
<ol>
<li>either build the ray-tracing acceleration structure with
  <code>init_intersection()</code> or supply your own with
  <code>set_intersection_callbacks()</code></li>
<li>if desired, add logging with <code>set_logging_callbacks()</code></li>
<li>prepare lights for rendering <code>init_lights()</code></li>
<li>define rendering params with the <code>trace_params</code> structure</li>
<li>render blocks of samples with <code>trace_block()</code></li>
</ol>
<h2>Usage for Progressive Rendering</h2>
<ol>
<li>either build the ray-tracing acceleration structure with
  <code>init_intersection()</code> or supply your own with
  <code>set_intersection_callbacks()</code></li>
<li>if desired, add logging with <code>set_logging_callbacks()</code></li>
<li>prepare lights for rendering <code>init_lights()</code></li>
<li>define rendering params with the <code>trace_params</code> structure</li>
<li>initoialize the prograssive rendering state with <code>init_state()</code></li>
<li>either render sames successively with <code>trace_next_samples()</code>
   or starts an asynchronousn renderer</li>
<li>get the rendered image with <code>get_traced_image()</code></li>
</ol>
<h2>History</h2>
<ul>
<li>v 0.21: added filters</li>
<li>v 0.20: state-based api</li>
<li>v 0.19: explicit material models</li>
<li>v 0.18: simpler texture creation functions</li>
<li>v 0.17: move to rgba per-vertex color</li>
<li>v 0.16: use yocto_math in the interface and remove inline compilation</li>
<li>v 0.15: move to add api</li>
<li>v 1.16: internally use yocto_bvh if desired</li>
<li>v 1.15: added gltf/generic material properties (deprecate old interface)</li>
<li>v 1.14: normal mapping</li>
<li>v 1.13: simpler Fresnel handling</li>
<li>v 1.12: significantly better path tracing</li>
<li>v 1.11: add progressive sampling to rendering params</li>
<li>v 0.10: switch to .h/.cpp pair</li>
<li>v 0.9: doxygen comments</li>
<li>v 0.8: opaque API (allows for changing internals without altering API)</li>
<li>v 0.7: internally use pointers for performance transparency</li>
<li>v 0.6: minor API change for blocks</li>
<li>v 0.5: [major API change] move to modern C++ interface</li>
<li>v 0.4: C++ API</li>
<li>v 0.3: removal of C interface</li>
<li>v 0.2: use of STL containers</li>
<li>v 0.1: C++ implementation</li>
<li>v 0.0: initial release in C99</li>
</ul>
<h2>Namespace ytrace</h2>
<p>Path tracer with MIS support.</p>
<h3>Struct scene</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">scene</span><span class="p">;</span>
</code></pre></div>


<p>Trace scene.</p>
<h3>Function make_scene()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">scene</span><span class="o">*</span> <span class="nf">make_scene</span><span class="p">();</span>
</code></pre></div>


<p>Initialize the scene with the proper number of objects.</p>
<h3>Function free_scene()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">free_scene</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Free scene.</p>
<h3>Function add_camera()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">add_camera</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">frame</span><span class="p">,</span> <span class="kt">float</span> <span class="n">yfov</span><span class="p">,</span> <span class="kt">float</span> <span class="n">aspect</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">aperture</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">focus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Adds a camera in the scene.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>frame: local-to-world frame (x, y, z, o in column major order)</li>
<li>yfov: field of view</li>
<li>aspect: aspect ratio</li>
<li>aperture: lens aperture</li>
<li>focus: focus plane distance (cannot be zero)</li>
</ul>
</li>
<li>Returns:<ul>
<li>camera id</li>
</ul>
</li>
</ul>
<h3>Function set_camera()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_camera</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cid</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">frame</span><span class="p">,</span> <span class="kt">float</span> <span class="n">yfov</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">aspect</span><span class="p">,</span> <span class="kt">float</span> <span class="n">aperture</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">focus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Sets a camera in the scene.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>cid: camera id</li>
<li>frame: local-to-world frame (x, y, z, o in column major order)</li>
<li>yfov: field of view</li>
<li>aspect: aspect ratio</li>
<li>aperture: lens aperture</li>
<li>focus: focus plane distance (cannot be zero)</li>
</ul>
</li>
</ul>
<h3>Function add_texture()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">add_texture</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec4f</span><span class="o">*</span> <span class="n">hdr</span><span class="p">);</span>
</code></pre></div>


<p>Adds a texture in the scene.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>tid: texture id</li>
<li>width: width</li>
<li>height: height</li>
<li>hdr: hdr pixels</li>
</ul>
</li>
<li>Returns:<ul>
<li>texture id</li>
</ul>
</li>
</ul>
<h3>Function add_texture()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">add_texture</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec4b</span><span class="o">*</span> <span class="n">ldr</span><span class="p">);</span>
</code></pre></div>


<p>Sets a texture in the scene.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>tid: texture id</li>
<li>width: width</li>
<li>height: height</li>
<li>ldr: ldr pixels (sRGB)</li>
</ul>
</li>
<li>Returns:<ul>
<li>texture id</li>
</ul>
</li>
</ul>
<h3>Function add_texture()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">add_texture</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">image4f</span><span class="o">*</span> <span class="n">img</span><span class="p">);</span>
</code></pre></div>


<p>Adds a texture in the scene.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>hdr: hdr image</li>
</ul>
</li>
<li>Returns:<ul>
<li>texture id</li>
</ul>
</li>
</ul>
<h3>Function add_texture()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">add_texture</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">image4b</span><span class="o">*</span> <span class="n">ldr</span><span class="p">);</span>
</code></pre></div>


<p>Sets a texture in the scene.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>ldr: ldr image (sRGB)</li>
</ul>
</li>
<li>Returns:<ul>
<li>texture id</li>
</ul>
</li>
</ul>
<h3>Function add_material()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">add_material</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Adds a black material to the scene. Use set_material_XXX() functions to
customize it.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
</ul>
</li>
<li>Returns:<ul>
<li>material id</li>
</ul>
</li>
</ul>
<h3>Function set_material_emission()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_material_emission</span><span class="p">(</span>
    <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ke</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ke_txt</span><span class="p">);</span>
</code></pre></div>


<p>Sets the material emission.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>mid: material id</li>
<li>ke: emission, term</li>
<li>ke_txt: emission texture (-1 for none)</li>
</ul>
</li>
</ul>
<h3>Function set_material_normal()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_material_normal</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">norm_txt</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Sets the material normal map.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>mid: material id</li>
<li>norm_txt: normal map (-1 for none)</li>
<li>scale: normal scale</li>
</ul>
</li>
</ul>
<h3>Function set_material_occlusion()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_material_occlusion</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">occ_txt</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Sets the material normal map.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>mid: material id</li>
<li>occ_txt: occlusion map (-1 for none)</li>
<li>scale: occlusion scale</li>
</ul>
</li>
</ul>
<h3>Function set_material_microfacet()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_material_microfacet</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">kd</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ks</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rs</span><span class="p">,</span> <span class="kt">float</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kd_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ks_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rs_txt</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">op_txt</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">use_phong</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Sets a material reflectance as a microfacet model in the scene.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>mid: material id</li>
<li>kd: diffuse term</li>
<li>ks: specular term</li>
<li>rs: specular roughness</li>
<li>kd_txt, ks_txt, rs_txt: texture indices (-1 for
none)</li>
<li>use_phong: whether to use phong</li>
</ul>
</li>
</ul>
<h3>Function set_material_gltf_metallic_roughness()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_material_gltf_metallic_roughness</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">kb</span><span class="p">,</span> <span class="kt">float</span> <span class="n">km</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rs</span><span class="p">,</span> <span class="kt">float</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kd_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">km_txt</span><span class="p">);</span>
</code></pre></div>


<p>Sets a gltf metallic roughness material reflectance.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>mid: material id</li>
<li>kb: base color term</li>
<li>km: metallic term</li>
<li>rs: specular roughness</li>
<li>kd_txt, km_txt: texture indices (-1 for none)</li>
</ul>
</li>
</ul>
<h3>Function set_material_gltf_specular_glossiness()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_material_gltf_specular_glossiness</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">kd</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ks</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rs</span><span class="p">,</span> <span class="kt">float</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kd_txt</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">ks_txt</span><span class="p">);</span>
</code></pre></div>


<p>Sets a gltf metallic specular glossiness reflectance.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>mid: material id</li>
<li>ke: emission, term</li>
<li>kd: diffuse term</li>
<li>ks: specular term</li>
<li>rs: specular glossiness</li>
<li>kd_txt, ks_txt, norm_txt: texture indices (-1 for
none)</li>
</ul>
</li>
<li>use_phong: whether to use phong</li>
</ul>
<h3>Function add_material()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">add_material</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ke</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">kd</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ks</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">kt</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rs</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ke_txt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">kd_txt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ks_txt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kt_txt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rs_txt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">norm_txt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">use_phong</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Sets a material in the scene. [DEPRECATED]</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>ke: emission, term</li>
<li>kd: diffuse term</li>
<li>ks: specular term</li>
<li>rs: specular roughness</li>
<li>ke_txt, kd_txt, ks_txt, rs_txt, norm_txt: texture indices (-1 for
none) - use_phong: whether to use phong</li>
</ul>
</li>
<li>Returns:<ul>
<li>material id</li>
</ul>
</li>
</ul>
<h3>Function add_material_uber()</h3>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add_material_uber</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ke</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">kd</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ks</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">kt</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rs</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ke_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kd_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ks_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kt_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rs_txt</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">op_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">norm_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">occ_txt</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">use_phong</span><span class="p">);</span>
</code></pre></div>


<p>Sets a material in the scene with the most customization possible.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>ke: emission, term</li>
<li>kd: diffuse term</li>
<li>ks: specular term</li>
<li>kt: transmission term</li>
<li>rs: specular roughness</li>
<li>ke_txt, kd_txt, ks_txt, rs_txt, norm_txt, occ_txt: texture indices (-1
for none) - use_phong: whether to use phong</li>
</ul>
</li>
<li>Returns:<ul>
<li>material id</li>
</ul>
</li>
</ul>
<h3>Function add_material_gltf_metallic_roughness()</h3>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add_material_gltf_metallic_roughness</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ke</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">kb</span><span class="p">,</span> <span class="kt">float</span> <span class="n">km</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rs</span><span class="p">,</span> <span class="kt">float</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ke_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kb_txt</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">km_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">norm_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">occ_txt</span><span class="p">);</span>
</code></pre></div>


<p>Sets a gltf metallic roughness material.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>ke: emission, term</li>
<li>kd: base color</li>
<li>km: metallic term</li>
<li>rs: specular roughness</li>
<li>ke_txt, kb_txt, km_txt, norm_txt, occ_txt: texture indices (-1 for
none)</li>
</ul>
</li>
<li>Returns:<ul>
<li>material id</li>
</ul>
</li>
</ul>
<h3>Function add_material_gltf_specular_glossiness()</h3>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add_material_gltf_specular_glossiness</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ke</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">kd</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ks</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rs</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ke_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kd_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ks_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">norm_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">occ_txt</span><span class="p">);</span>
</code></pre></div>


<p>Sets a gltf metallic specular glossiness.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>ke: emission, term</li>
<li>kd: diffuse term</li>
<li>ks: specular term</li>
<li>rs: specular roughness</li>
<li>ke_txt, kd_txt, ks_txt, rs_txt, norm_txt: texture indices (-1 for
none)</li>
</ul>
</li>
<li>Returns:<ul>
<li>material id</li>
</ul>
</li>
</ul>
<h3>Function add_material_emission_only()</h3>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add_material_emission_only</span><span class="p">(</span>
    <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ke</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ke_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">norm_txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">occ_txt</span><span class="p">);</span>
</code></pre></div>


<p>Sets a gltf emission only material.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>mid: material id</li>
<li>ke: emission, term</li>
<li>kd: diffuse term</li>
<li>ks: specular term</li>
<li>rs: specular roughness</li>
<li>ke_txt, kd_txt, ks_txt, rs_txt, norm_txt: texture indices (-1 for
none)</li>
<li>use_phong: whether to use phong</li>
</ul>
</li>
<li>Returns:<ul>
<li>material id</li>
</ul>
</li>
</ul>
<h3>Function add_environment()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">add_environment</span><span class="p">(</span>
    <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">frame</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ke</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txt_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Sets an environment in the scene.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>frame: local-to-world frame (x, y, z, o in column major order)</li>
<li>ke: emission</li>
<li>ke_txt: emission texture (-1 for none)</li>
</ul>
</li>
<li>Returns:<ul>
<li>environment id</li>
</ul>
</li>
</ul>
<h3>Function add_triangle_shape()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">add_triangle_shape</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ntriangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3i</span><span class="o">*</span> <span class="n">triangles</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">nverts</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">*</span> <span class="n">norm</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec2f</span><span class="o">*</span> <span class="n">texcoord</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec4f</span><span class="o">*</span> <span class="n">color</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec4f</span><span class="o">*</span> <span class="n">tangsp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Sets a shape in the scene.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>frame: local-to-world frame (x, y, z, o in column major order)</li>
<li>mid: material id</li>
<li>npoints/nlines/ntriangles: number of elements</li>
<li>points/lines/tiangles: elem data</li>
<li>nverts: number of vertices</li>
<li>pos: vertex positions</li>
<li>norm/tang: vertex normals/tangents</li>
<li>texcoord: vertex texcoord</li>
<li>color: vertex color</li>
<li>tangsp: tangent space for normal and bump mapping</li>
</ul>
</li>
<li>Returns:<ul>
<li>shape id</li>
</ul>
</li>
</ul>
<h3>Function add_point_shape()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">add_point_shape</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">npoints</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">points</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nverts</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">*</span> <span class="n">norm</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec2f</span><span class="o">*</span> <span class="n">texcoord</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec4f</span><span class="o">*</span> <span class="n">color</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">radius</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Sets a shape in the scene.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>sid: shape id</li>
<li>frame: local-to-world frame (x, y, z, o in column major order)</li>
<li>mid: material id</li>
<li>npoints/nlines/ntriangles: number of elements</li>
<li>points/lines/tiangles: elem data</li>
<li>nverts: number of vertices</li>
<li>pos: vertex positions</li>
<li>norm/tang: vertex normals/tangents</li>
<li>texcoord: vertex texcoord</li>
<li>color: vertex color</li>
<li>radius: vertex radius</li>
</ul>
</li>
<li>Returns:<ul>
<li>shape id</li>
</ul>
</li>
</ul>
<h3>Function add_line_shape()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">add_line_shape</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nlines</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec2i</span><span class="o">*</span> <span class="n">lines</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nverts</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">*</span> <span class="n">tang</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec2f</span><span class="o">*</span> <span class="n">texcoord</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec4f</span><span class="o">*</span> <span class="n">color</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">radius</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Sets a shape in the scene.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>frame: local-to-world frame (x, y, z, o in column major order)</li>
<li>mid: material id</li>
<li>npoints/nlines/ntriangles: number of elements</li>
<li>points/lines/tiangles: elem data</li>
<li>nverts: number of vertices</li>
<li>pos: vertex positions</li>
<li>norm/tang: vertex normals/tangents</li>
<li>texcoord: vertex texcoord</li>
<li>color: vertex color</li>
<li>radius: vertex radius</li>
</ul>
</li>
<li>Returns:<ul>
<li>shape id</li>
</ul>
</li>
</ul>
<h3>Function add_instance()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">add_instance</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">frame</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">);</span>
</code></pre></div>


<p>Adds an instance in the scene.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene</li>
<li>iid: instance id</li>
<li>frame: local-to-world frame (x, y, z, o in column major order)</li>
<li>sid: shape id</li>
<li>mid: material id</li>
</ul>
</li>
<li>Returns:<ul>
<li>instance id</li>
</ul>
</li>
</ul>
<h3>Function specular_exponent_to_roughness()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">specular_exponent_to_roughness</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div>


<p>Convert a Phong exponent to GGX/Phong roughness</p>
<h3>Function specular_fresnel_from_ks()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">specular_fresnel_from_ks</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ks</span><span class="p">,</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">,</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">esk</span><span class="p">);</span>
</code></pre></div>


<p>Estimates the fresnel coefficient es from ks at normal incidence</p>
<h3>Struct intersect_point</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">intersect_point</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">iid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">eid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span> <span class="n">euv</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>Ray-scene Intersection.</p>
<ul>
<li>Members:<ul>
<li>dist:      ray distance</li>
<li>iid:      instance index</li>
<li>sid:      shape index</li>
<li>eid:      element distance</li>
<li>euv:      element baricentric coordinates</li>
<li>operator bool():      check whether it was a hit</li>
</ul>
</li>
</ul>
<h3>Typedef intersect_first_cb</h3>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">intersect_first_cb</span> <span class="o">=</span> <span class="n">intersect_point</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">);</span>
</code></pre></div>


<p>Ray-scene closest intersection callback.</p>
<ul>
<li>Parameters:<ul>
<li>ctx: context</li>
<li>ray: ray</li>
</ul>
</li>
<li>Return:<ul>
<li>intersection point</li>
</ul>
</li>
</ul>
<h3>Typedef intersect_any_cb</h3>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">intersect_any_cb</span> <span class="o">=</span> <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">ym</span><span class="o">::</span><span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">);</span>
</code></pre></div>


<p>Ray-scene intersection callback</p>
<ul>
<li>Parameters:<ul>
<li>ctx: context</li>
<li>ray: ray</li>
</ul>
</li>
<li>Return:<ul>
<li>whether we intersect or not</li>
</ul>
</li>
</ul>
<h3>Function set_intersection_callbacks()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_intersection_callbacks</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ctx</span><span class="p">,</span>
    <span class="n">intersect_first_cb</span> <span class="n">intersect_first</span><span class="p">,</span> <span class="n">intersect_any_cb</span> <span class="n">intersect_any</span><span class="p">);</span>
</code></pre></div>


<p>Sets the intersection callbacks</p>
<h3>Function init_intersection()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">init_intersection</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Initialize acceleration structure.</p>
<ul>
<li>Parameters:<ul>
<li>scn: trace scene</li>
</ul>
</li>
</ul>
<h3>Typedef logging_msg_cb</h3>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">logging_msg_cb</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Logger callback</p>
<h3>Function set_logging_callbacks()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_logging_callbacks</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">logging_msg_cb</span> <span class="n">log</span><span class="p">);</span>
</code></pre></div>


<p>Logger</p>
<h3>Function init_lights()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">init_lights</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Initialize lighting.</p>
<ul>
<li>Parameters:<ul>
<li>scn: trace scene</li>
</ul>
</li>
</ul>
<h3>Enum shader_type</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">shader_type</span> <span class="p">{</span>
    <span class="n">pathtrace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">eyelight</span><span class="p">,</span>
    <span class="n">direct</span><span class="p">,</span>
    <span class="n">direct_ao</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Type of rendering algorithm (shader)</p>
<ul>
<li>Values:<ul>
<li>pathtrace:      pathtrace</li>
<li>eyelight:      eye hight for quick previews</li>
<li>direct:      direct illumination</li>
<li>direct_ao:      direct illumination with ambient occlusion</li>
</ul>
</li>
</ul>
<h3>Enum rng_type</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">rng_type</span> <span class="p">{</span>
    <span class="n">uniform</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">stratified</span><span class="p">,</span>
    <span class="n">cmjs</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Random number generator type</p>
<ul>
<li>Values:<ul>
<li>uniform:      uniform random numbers</li>
<li>stratified:      stratified random numbers</li>
<li>cmjs:      correlated multi-jittered sampling</li>
</ul>
</li>
</ul>
<h3>Enum filter_type</h3>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">filter_type</span> <span class="p">{</span>
    <span class="n">box</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">triangle</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">cubic</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">catmull_rom</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">mitchell</span> <span class="o">=</span> <span class="mi">5</span>

<span class="p">}</span>
</code></pre></div>


<p>Filter type</p>
<ul>
<li>Values:<ul>
<li>box:      box filter</li>
<li>triangle:      hat filter</li>
<li>cubic:      cubic spline</li>
<li>catmull_rom:      Catmull-Rom spline</li>
<li>mitchell:      Mitchell-Netrevalli</li>
</ul>
</li>
</ul>
<h3>Struct trace_params</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">trace_params</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">camera_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nsamples</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
    <span class="n">shader_type</span> <span class="n">stype</span> <span class="o">=</span> <span class="n">shader_type</span><span class="o">::</span><span class="n">pathtrace</span><span class="p">;</span>
    <span class="n">rng_type</span> <span class="n">rtype</span> <span class="o">=</span> <span class="n">rng_type</span><span class="o">::</span><span class="n">stratified</span><span class="p">;</span>
    <span class="n">filter_type</span> <span class="n">ftype</span> <span class="o">=</span> <span class="n">filter_type</span><span class="o">::</span><span class="n">box</span><span class="p">;</span>
    <span class="n">ym</span><span class="o">::</span><span class="n">vec3f</span> <span class="n">amb</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">bool</span> <span class="n">envmap_invisible</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min_depth</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max_depth</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">pixel_clamp</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">ray_eps</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Rendering params</p>
<ul>
<li>Members:<ul>
<li>camera_id:      camera id</li>
<li>width:      width</li>
<li>height:      height</li>
<li>nsamples:      number of samples</li>
<li>stype:      sampler type</li>
<li>rtype:      random number generation type</li>
<li>ftype:      filter type</li>
<li>amb:      ambient lighting</li>
<li>envmap_invisible:      view environment map</li>
<li>min_depth:      minimum ray depth</li>
<li>max_depth:      maximum ray depth</li>
<li>pixel_clamp:      final pixel clamping</li>
<li>ray_eps:      ray intersection epsilon</li>
</ul>
</li>
</ul>
<h3>Function trace_block()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">trace_block</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">ym</span><span class="o">::</span><span class="n">vec4f</span><span class="o">*</span> <span class="n">img</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block_x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block_y</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">block_width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block_height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">samples_min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">samples_max</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Renders a block of sample</p>
<p>Notes: It is safe to call the function in parallel on different blocks.
But two threads should not access the same pixels at the same time.
Also blocks with different samples should be called sequentially if
accumulate is true.</p>
<ul>
<li>Parameters:<ul>
<li>scn: trace scene</li>
<li>cid: camera id</li>
<li>img: pixel data in RGBA format (width/height in params)</li>
<li>nsamples: number of samples</li>
<li>block_x, block_y: block corner</li>
<li>block_width, block_height: block width and height</li>
<li>samples_min, samples_max: sample block to render
  [sample_min, sample_max]; max values are excluded</li>
</ul>
</li>
</ul>
<h3>Struct trace_state</h3>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">trace_state</span><span class="p">;</span>
</code></pre></div>


<p>State for progressive rendering and denoising</p>
<h3>Function make_state()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">trace_state</span><span class="o">*</span> <span class="nf">make_state</span><span class="p">();</span>
</code></pre></div>


<p>Creates state</p>
<h3>Function init_state()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">init_state</span><span class="p">(</span>
    <span class="n">trace_state</span><span class="o">*</span> <span class="n">state</span><span class="p">,</span> <span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Initialize state</p>
<h3>Function free_state()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">free_state</span><span class="p">(</span><span class="n">trace_state</span><span class="o">*&amp;</span> <span class="n">state</span><span class="p">);</span>
</code></pre></div>


<p>Clear state</p>
<h3>Function get_traced_image()</h3>
<div class="codehilite"><pre><code><span></span><span class="n">ym</span><span class="o">::</span><span class="n">image4f</span><span class="o">&amp;</span> <span class="n">get_traced_image</span><span class="p">(</span><span class="n">trace_state</span><span class="o">*</span> <span class="n">state</span><span class="p">);</span>
</code></pre></div>


<p>Grabs a reference to the image from the state</p>
<h3>Function get_cur_sample()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">get_cur_sample</span><span class="p">(</span><span class="k">const</span> <span class="n">trace_state</span><span class="o">*</span> <span class="n">state</span><span class="p">);</span>
</code></pre></div>


<p>Gets the current sample number</p>
<h3>Function trace_next_samples()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">trace_next_samples</span><span class="p">(</span><span class="n">trace_state</span><span class="o">*</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nsamples</span><span class="p">);</span>
</code></pre></div>


<p>Trace the next nsamples samples.</p>
<h3>Function trace_image()</h3>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ym</span><span class="o">::</span><span class="n">image4f</span> <span class="n">trace_image</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Trace the whole image</p>
<h3>Function trace_async_start()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">trace_async_start</span><span class="p">(</span><span class="n">trace_state</span><span class="o">*</span> <span class="n">state</span><span class="p">);</span>
</code></pre></div>


<p>Starts an anyncrhounous renderer with a maximum of 256 samples.</p>
<h3>Function trace_async_stop()</h3>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">trace_async_stop</span><span class="p">(</span><span class="n">trace_state</span><span class="o">*</span> <span class="n">state</span><span class="p">);</span>
</code></pre></div>


<p>Stop the asynchronous renderer.</p>
        <article>
        <footer></footer>
        </body>
        </html>
    